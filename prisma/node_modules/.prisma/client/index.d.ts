
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Camion
 * 
 */
export type Camion = $Result.DefaultSelection<Prisma.$CamionPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model DetailFacture
 * 
 */
export type DetailFacture = $Result.DefaultSelection<Prisma.$DetailFacturePayload>
/**
 * Model FactureImport
 * 
 */
export type FactureImport = $Result.DefaultSelection<Prisma.$FactureImportPayload>
/**
 * Model Journal
 * 
 */
export type Journal = $Result.DefaultSelection<Prisma.$JournalPayload>
/**
 * Model JournalType
 * 
 */
export type JournalType = $Result.DefaultSelection<Prisma.$JournalTypePayload>
/**
 * Model Marchandise
 * 
 */
export type Marchandise = $Result.DefaultSelection<Prisma.$MarchandisePayload>
/**
 * Model Paiement
 * 
 */
export type Paiement = $Result.DefaultSelection<Prisma.$PaiementPayload>
/**
 * Model RubriqueFacture
 * 
 */
export type RubriqueFacture = $Result.DefaultSelection<Prisma.$RubriqueFacturePayload>
/**
 * Model Utilisateur
 * 
 */
export type Utilisateur = $Result.DefaultSelection<Prisma.$UtilisateurPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const STATUSFACTURE: {
  B: 'B',
  C: 'C'
};

export type STATUSFACTURE = (typeof STATUSFACTURE)[keyof typeof STATUSFACTURE]


export const StatusRow: {
  A: 'A',
  B: 'B',
  D: 'D'
};

export type StatusRow = (typeof StatusRow)[keyof typeof StatusRow]


export const TYPEFACTURATION: {
  G: 'G',
  C: 'C',
  E: 'E'
};

export type TYPEFACTURATION = (typeof TYPEFACTURATION)[keyof typeof TYPEFACTURATION]


export const NIVEAUSAISIE: {
  R: 'R',
  A: 'A',
  N: 'N'
};

export type NIVEAUSAISIE = (typeof NIVEAUSAISIE)[keyof typeof NIVEAUSAISIE]

}

export type STATUSFACTURE = $Enums.STATUSFACTURE

export const STATUSFACTURE: typeof $Enums.STATUSFACTURE

export type StatusRow = $Enums.StatusRow

export const StatusRow: typeof $Enums.StatusRow

export type TYPEFACTURATION = $Enums.TYPEFACTURATION

export const TYPEFACTURATION: typeof $Enums.TYPEFACTURATION

export type NIVEAUSAISIE = $Enums.NIVEAUSAISIE

export const NIVEAUSAISIE: typeof $Enums.NIVEAUSAISIE

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Camions
 * const camions = await prisma.camion.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Camions
   * const camions = await prisma.camion.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.camion`: Exposes CRUD operations for the **Camion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Camions
    * const camions = await prisma.camion.findMany()
    * ```
    */
  get camion(): Prisma.CamionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.detailFacture`: Exposes CRUD operations for the **DetailFacture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DetailFactures
    * const detailFactures = await prisma.detailFacture.findMany()
    * ```
    */
  get detailFacture(): Prisma.DetailFactureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.factureImport`: Exposes CRUD operations for the **FactureImport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FactureImports
    * const factureImports = await prisma.factureImport.findMany()
    * ```
    */
  get factureImport(): Prisma.FactureImportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journal`: Exposes CRUD operations for the **Journal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Journals
    * const journals = await prisma.journal.findMany()
    * ```
    */
  get journal(): Prisma.JournalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journalType`: Exposes CRUD operations for the **JournalType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalTypes
    * const journalTypes = await prisma.journalType.findMany()
    * ```
    */
  get journalType(): Prisma.JournalTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marchandise`: Exposes CRUD operations for the **Marchandise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Marchandises
    * const marchandises = await prisma.marchandise.findMany()
    * ```
    */
  get marchandise(): Prisma.MarchandiseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paiement`: Exposes CRUD operations for the **Paiement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Paiements
    * const paiements = await prisma.paiement.findMany()
    * ```
    */
  get paiement(): Prisma.PaiementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rubriqueFacture`: Exposes CRUD operations for the **RubriqueFacture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RubriqueFactures
    * const rubriqueFactures = await prisma.rubriqueFacture.findMany()
    * ```
    */
  get rubriqueFacture(): Prisma.RubriqueFactureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.utilisateur`: Exposes CRUD operations for the **Utilisateur** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Utilisateurs
    * const utilisateurs = await prisma.utilisateur.findMany()
    * ```
    */
  get utilisateur(): Prisma.UtilisateurDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Camion: 'Camion',
    Client: 'Client',
    DetailFacture: 'DetailFacture',
    FactureImport: 'FactureImport',
    Journal: 'Journal',
    JournalType: 'JournalType',
    Marchandise: 'Marchandise',
    Paiement: 'Paiement',
    RubriqueFacture: 'RubriqueFacture',
    Utilisateur: 'Utilisateur'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "camion" | "client" | "detailFacture" | "factureImport" | "journal" | "journalType" | "marchandise" | "paiement" | "rubriqueFacture" | "utilisateur"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Camion: {
        payload: Prisma.$CamionPayload<ExtArgs>
        fields: Prisma.CamionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CamionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CamionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CamionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CamionPayload>
          }
          findFirst: {
            args: Prisma.CamionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CamionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CamionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CamionPayload>
          }
          findMany: {
            args: Prisma.CamionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CamionPayload>[]
          }
          create: {
            args: Prisma.CamionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CamionPayload>
          }
          createMany: {
            args: Prisma.CamionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CamionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CamionPayload>[]
          }
          delete: {
            args: Prisma.CamionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CamionPayload>
          }
          update: {
            args: Prisma.CamionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CamionPayload>
          }
          deleteMany: {
            args: Prisma.CamionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CamionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CamionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CamionPayload>[]
          }
          upsert: {
            args: Prisma.CamionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CamionPayload>
          }
          aggregate: {
            args: Prisma.CamionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCamion>
          }
          groupBy: {
            args: Prisma.CamionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CamionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CamionCountArgs<ExtArgs>
            result: $Utils.Optional<CamionCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      DetailFacture: {
        payload: Prisma.$DetailFacturePayload<ExtArgs>
        fields: Prisma.DetailFactureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DetailFactureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailFacturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DetailFactureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailFacturePayload>
          }
          findFirst: {
            args: Prisma.DetailFactureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailFacturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DetailFactureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailFacturePayload>
          }
          findMany: {
            args: Prisma.DetailFactureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailFacturePayload>[]
          }
          create: {
            args: Prisma.DetailFactureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailFacturePayload>
          }
          createMany: {
            args: Prisma.DetailFactureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DetailFactureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailFacturePayload>[]
          }
          delete: {
            args: Prisma.DetailFactureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailFacturePayload>
          }
          update: {
            args: Prisma.DetailFactureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailFacturePayload>
          }
          deleteMany: {
            args: Prisma.DetailFactureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DetailFactureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DetailFactureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailFacturePayload>[]
          }
          upsert: {
            args: Prisma.DetailFactureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailFacturePayload>
          }
          aggregate: {
            args: Prisma.DetailFactureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDetailFacture>
          }
          groupBy: {
            args: Prisma.DetailFactureGroupByArgs<ExtArgs>
            result: $Utils.Optional<DetailFactureGroupByOutputType>[]
          }
          count: {
            args: Prisma.DetailFactureCountArgs<ExtArgs>
            result: $Utils.Optional<DetailFactureCountAggregateOutputType> | number
          }
        }
      }
      FactureImport: {
        payload: Prisma.$FactureImportPayload<ExtArgs>
        fields: Prisma.FactureImportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FactureImportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactureImportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FactureImportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactureImportPayload>
          }
          findFirst: {
            args: Prisma.FactureImportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactureImportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FactureImportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactureImportPayload>
          }
          findMany: {
            args: Prisma.FactureImportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactureImportPayload>[]
          }
          create: {
            args: Prisma.FactureImportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactureImportPayload>
          }
          createMany: {
            args: Prisma.FactureImportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FactureImportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactureImportPayload>[]
          }
          delete: {
            args: Prisma.FactureImportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactureImportPayload>
          }
          update: {
            args: Prisma.FactureImportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactureImportPayload>
          }
          deleteMany: {
            args: Prisma.FactureImportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FactureImportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FactureImportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactureImportPayload>[]
          }
          upsert: {
            args: Prisma.FactureImportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactureImportPayload>
          }
          aggregate: {
            args: Prisma.FactureImportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFactureImport>
          }
          groupBy: {
            args: Prisma.FactureImportGroupByArgs<ExtArgs>
            result: $Utils.Optional<FactureImportGroupByOutputType>[]
          }
          count: {
            args: Prisma.FactureImportCountArgs<ExtArgs>
            result: $Utils.Optional<FactureImportCountAggregateOutputType> | number
          }
        }
      }
      Journal: {
        payload: Prisma.$JournalPayload<ExtArgs>
        fields: Prisma.JournalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          findFirst: {
            args: Prisma.JournalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          findMany: {
            args: Prisma.JournalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>[]
          }
          create: {
            args: Prisma.JournalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          createMany: {
            args: Prisma.JournalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>[]
          }
          delete: {
            args: Prisma.JournalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          update: {
            args: Prisma.JournalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          deleteMany: {
            args: Prisma.JournalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>[]
          }
          upsert: {
            args: Prisma.JournalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          aggregate: {
            args: Prisma.JournalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournal>
          }
          groupBy: {
            args: Prisma.JournalGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalCountArgs<ExtArgs>
            result: $Utils.Optional<JournalCountAggregateOutputType> | number
          }
        }
      }
      JournalType: {
        payload: Prisma.$JournalTypePayload<ExtArgs>
        fields: Prisma.JournalTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTypePayload>
          }
          findFirst: {
            args: Prisma.JournalTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTypePayload>
          }
          findMany: {
            args: Prisma.JournalTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTypePayload>[]
          }
          create: {
            args: Prisma.JournalTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTypePayload>
          }
          createMany: {
            args: Prisma.JournalTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTypePayload>[]
          }
          delete: {
            args: Prisma.JournalTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTypePayload>
          }
          update: {
            args: Prisma.JournalTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTypePayload>
          }
          deleteMany: {
            args: Prisma.JournalTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTypePayload>[]
          }
          upsert: {
            args: Prisma.JournalTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalTypePayload>
          }
          aggregate: {
            args: Prisma.JournalTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalType>
          }
          groupBy: {
            args: Prisma.JournalTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalTypeCountArgs<ExtArgs>
            result: $Utils.Optional<JournalTypeCountAggregateOutputType> | number
          }
        }
      }
      Marchandise: {
        payload: Prisma.$MarchandisePayload<ExtArgs>
        fields: Prisma.MarchandiseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarchandiseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarchandiseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandisePayload>
          }
          findFirst: {
            args: Prisma.MarchandiseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarchandiseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandisePayload>
          }
          findMany: {
            args: Prisma.MarchandiseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandisePayload>[]
          }
          create: {
            args: Prisma.MarchandiseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandisePayload>
          }
          createMany: {
            args: Prisma.MarchandiseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarchandiseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandisePayload>[]
          }
          delete: {
            args: Prisma.MarchandiseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandisePayload>
          }
          update: {
            args: Prisma.MarchandiseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandisePayload>
          }
          deleteMany: {
            args: Prisma.MarchandiseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarchandiseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MarchandiseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandisePayload>[]
          }
          upsert: {
            args: Prisma.MarchandiseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarchandisePayload>
          }
          aggregate: {
            args: Prisma.MarchandiseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarchandise>
          }
          groupBy: {
            args: Prisma.MarchandiseGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarchandiseGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarchandiseCountArgs<ExtArgs>
            result: $Utils.Optional<MarchandiseCountAggregateOutputType> | number
          }
        }
      }
      Paiement: {
        payload: Prisma.$PaiementPayload<ExtArgs>
        fields: Prisma.PaiementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaiementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaiementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          findFirst: {
            args: Prisma.PaiementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaiementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          findMany: {
            args: Prisma.PaiementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>[]
          }
          create: {
            args: Prisma.PaiementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          createMany: {
            args: Prisma.PaiementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaiementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>[]
          }
          delete: {
            args: Prisma.PaiementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          update: {
            args: Prisma.PaiementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          deleteMany: {
            args: Prisma.PaiementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaiementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaiementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>[]
          }
          upsert: {
            args: Prisma.PaiementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          aggregate: {
            args: Prisma.PaiementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaiement>
          }
          groupBy: {
            args: Prisma.PaiementGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaiementGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaiementCountArgs<ExtArgs>
            result: $Utils.Optional<PaiementCountAggregateOutputType> | number
          }
        }
      }
      RubriqueFacture: {
        payload: Prisma.$RubriqueFacturePayload<ExtArgs>
        fields: Prisma.RubriqueFactureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RubriqueFactureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubriqueFacturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RubriqueFactureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubriqueFacturePayload>
          }
          findFirst: {
            args: Prisma.RubriqueFactureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubriqueFacturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RubriqueFactureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubriqueFacturePayload>
          }
          findMany: {
            args: Prisma.RubriqueFactureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubriqueFacturePayload>[]
          }
          create: {
            args: Prisma.RubriqueFactureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubriqueFacturePayload>
          }
          createMany: {
            args: Prisma.RubriqueFactureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RubriqueFactureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubriqueFacturePayload>[]
          }
          delete: {
            args: Prisma.RubriqueFactureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubriqueFacturePayload>
          }
          update: {
            args: Prisma.RubriqueFactureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubriqueFacturePayload>
          }
          deleteMany: {
            args: Prisma.RubriqueFactureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RubriqueFactureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RubriqueFactureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubriqueFacturePayload>[]
          }
          upsert: {
            args: Prisma.RubriqueFactureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RubriqueFacturePayload>
          }
          aggregate: {
            args: Prisma.RubriqueFactureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRubriqueFacture>
          }
          groupBy: {
            args: Prisma.RubriqueFactureGroupByArgs<ExtArgs>
            result: $Utils.Optional<RubriqueFactureGroupByOutputType>[]
          }
          count: {
            args: Prisma.RubriqueFactureCountArgs<ExtArgs>
            result: $Utils.Optional<RubriqueFactureCountAggregateOutputType> | number
          }
        }
      }
      Utilisateur: {
        payload: Prisma.$UtilisateurPayload<ExtArgs>
        fields: Prisma.UtilisateurFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UtilisateurFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UtilisateurFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          findFirst: {
            args: Prisma.UtilisateurFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UtilisateurFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          findMany: {
            args: Prisma.UtilisateurFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>[]
          }
          create: {
            args: Prisma.UtilisateurCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          createMany: {
            args: Prisma.UtilisateurCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UtilisateurCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>[]
          }
          delete: {
            args: Prisma.UtilisateurDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          update: {
            args: Prisma.UtilisateurUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          deleteMany: {
            args: Prisma.UtilisateurDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UtilisateurUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UtilisateurUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>[]
          }
          upsert: {
            args: Prisma.UtilisateurUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          aggregate: {
            args: Prisma.UtilisateurAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUtilisateur>
          }
          groupBy: {
            args: Prisma.UtilisateurGroupByArgs<ExtArgs>
            result: $Utils.Optional<UtilisateurGroupByOutputType>[]
          }
          count: {
            args: Prisma.UtilisateurCountArgs<ExtArgs>
            result: $Utils.Optional<UtilisateurCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    camion?: CamionOmit
    client?: ClientOmit
    detailFacture?: DetailFactureOmit
    factureImport?: FactureImportOmit
    journal?: JournalOmit
    journalType?: JournalTypeOmit
    marchandise?: MarchandiseOmit
    paiement?: PaiementOmit
    rubriqueFacture?: RubriqueFactureOmit
    utilisateur?: UtilisateurOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CamionCountOutputType
   */

  export type CamionCountOutputType = {
    factures: number
  }

  export type CamionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    factures?: boolean | CamionCountOutputTypeCountFacturesArgs
  }

  // Custom InputTypes
  /**
   * CamionCountOutputType without action
   */
  export type CamionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CamionCountOutputType
     */
    select?: CamionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CamionCountOutputType without action
   */
  export type CamionCountOutputTypeCountFacturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FactureImportWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    paiement: number
    journalType: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paiement?: boolean | ClientCountOutputTypeCountPaiementArgs
    journalType?: boolean | ClientCountOutputTypeCountJournalTypeArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountPaiementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaiementWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountJournalTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalTypeWhereInput
  }


  /**
   * Count Type FactureImportCountOutputType
   */

  export type FactureImportCountOutputType = {
    detailFacture: number
  }

  export type FactureImportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detailFacture?: boolean | FactureImportCountOutputTypeCountDetailFactureArgs
  }

  // Custom InputTypes
  /**
   * FactureImportCountOutputType without action
   */
  export type FactureImportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactureImportCountOutputType
     */
    select?: FactureImportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FactureImportCountOutputType without action
   */
  export type FactureImportCountOutputTypeCountDetailFactureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetailFactureWhereInput
  }


  /**
   * Count Type JournalTypeCountOutputType
   */

  export type JournalTypeCountOutputType = {
    journals: number
    FactureImport: number
  }

  export type JournalTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journals?: boolean | JournalTypeCountOutputTypeCountJournalsArgs
    FactureImport?: boolean | JournalTypeCountOutputTypeCountFactureImportArgs
  }

  // Custom InputTypes
  /**
   * JournalTypeCountOutputType without action
   */
  export type JournalTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalTypeCountOutputType
     */
    select?: JournalTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JournalTypeCountOutputType without action
   */
  export type JournalTypeCountOutputTypeCountJournalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalWhereInput
  }

  /**
   * JournalTypeCountOutputType without action
   */
  export type JournalTypeCountOutputTypeCountFactureImportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FactureImportWhereInput
  }


  /**
   * Count Type MarchandiseCountOutputType
   */

  export type MarchandiseCountOutputType = {
    factures: number
  }

  export type MarchandiseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    factures?: boolean | MarchandiseCountOutputTypeCountFacturesArgs
  }

  // Custom InputTypes
  /**
   * MarchandiseCountOutputType without action
   */
  export type MarchandiseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarchandiseCountOutputType
     */
    select?: MarchandiseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MarchandiseCountOutputType without action
   */
  export type MarchandiseCountOutputTypeCountFacturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FactureImportWhereInput
  }


  /**
   * Count Type RubriqueFactureCountOutputType
   */

  export type RubriqueFactureCountOutputType = {
    detailFacture: number
  }

  export type RubriqueFactureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detailFacture?: boolean | RubriqueFactureCountOutputTypeCountDetailFactureArgs
  }

  // Custom InputTypes
  /**
   * RubriqueFactureCountOutputType without action
   */
  export type RubriqueFactureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RubriqueFactureCountOutputType
     */
    select?: RubriqueFactureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RubriqueFactureCountOutputType without action
   */
  export type RubriqueFactureCountOutputTypeCountDetailFactureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetailFactureWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Camion
   */

  export type AggregateCamion = {
    _count: CamionCountAggregateOutputType | null
    _min: CamionMinAggregateOutputType | null
    _max: CamionMaxAggregateOutputType | null
  }

  export type CamionMinAggregateOutputType = {
    id: string | null
    libelle: string | null
  }

  export type CamionMaxAggregateOutputType = {
    id: string | null
    libelle: string | null
  }

  export type CamionCountAggregateOutputType = {
    id: number
    libelle: number
    _all: number
  }


  export type CamionMinAggregateInputType = {
    id?: true
    libelle?: true
  }

  export type CamionMaxAggregateInputType = {
    id?: true
    libelle?: true
  }

  export type CamionCountAggregateInputType = {
    id?: true
    libelle?: true
    _all?: true
  }

  export type CamionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Camion to aggregate.
     */
    where?: CamionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Camions to fetch.
     */
    orderBy?: CamionOrderByWithRelationInput | CamionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CamionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Camions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Camions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Camions
    **/
    _count?: true | CamionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CamionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CamionMaxAggregateInputType
  }

  export type GetCamionAggregateType<T extends CamionAggregateArgs> = {
        [P in keyof T & keyof AggregateCamion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCamion[P]>
      : GetScalarType<T[P], AggregateCamion[P]>
  }




  export type CamionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CamionWhereInput
    orderBy?: CamionOrderByWithAggregationInput | CamionOrderByWithAggregationInput[]
    by: CamionScalarFieldEnum[] | CamionScalarFieldEnum
    having?: CamionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CamionCountAggregateInputType | true
    _min?: CamionMinAggregateInputType
    _max?: CamionMaxAggregateInputType
  }

  export type CamionGroupByOutputType = {
    id: string
    libelle: string
    _count: CamionCountAggregateOutputType | null
    _min: CamionMinAggregateOutputType | null
    _max: CamionMaxAggregateOutputType | null
  }

  type GetCamionGroupByPayload<T extends CamionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CamionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CamionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CamionGroupByOutputType[P]>
            : GetScalarType<T[P], CamionGroupByOutputType[P]>
        }
      >
    >


  export type CamionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    libelle?: boolean
    factures?: boolean | Camion$facturesArgs<ExtArgs>
    _count?: boolean | CamionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["camion"]>

  export type CamionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    libelle?: boolean
  }, ExtArgs["result"]["camion"]>

  export type CamionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    libelle?: boolean
  }, ExtArgs["result"]["camion"]>

  export type CamionSelectScalar = {
    id?: boolean
    libelle?: boolean
  }

  export type CamionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "libelle", ExtArgs["result"]["camion"]>
  export type CamionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    factures?: boolean | Camion$facturesArgs<ExtArgs>
    _count?: boolean | CamionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CamionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CamionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CamionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Camion"
    objects: {
      factures: Prisma.$FactureImportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      libelle: string
    }, ExtArgs["result"]["camion"]>
    composites: {}
  }

  type CamionGetPayload<S extends boolean | null | undefined | CamionDefaultArgs> = $Result.GetResult<Prisma.$CamionPayload, S>

  type CamionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CamionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CamionCountAggregateInputType | true
    }

  export interface CamionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Camion'], meta: { name: 'Camion' } }
    /**
     * Find zero or one Camion that matches the filter.
     * @param {CamionFindUniqueArgs} args - Arguments to find a Camion
     * @example
     * // Get one Camion
     * const camion = await prisma.camion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CamionFindUniqueArgs>(args: SelectSubset<T, CamionFindUniqueArgs<ExtArgs>>): Prisma__CamionClient<$Result.GetResult<Prisma.$CamionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Camion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CamionFindUniqueOrThrowArgs} args - Arguments to find a Camion
     * @example
     * // Get one Camion
     * const camion = await prisma.camion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CamionFindUniqueOrThrowArgs>(args: SelectSubset<T, CamionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CamionClient<$Result.GetResult<Prisma.$CamionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Camion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CamionFindFirstArgs} args - Arguments to find a Camion
     * @example
     * // Get one Camion
     * const camion = await prisma.camion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CamionFindFirstArgs>(args?: SelectSubset<T, CamionFindFirstArgs<ExtArgs>>): Prisma__CamionClient<$Result.GetResult<Prisma.$CamionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Camion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CamionFindFirstOrThrowArgs} args - Arguments to find a Camion
     * @example
     * // Get one Camion
     * const camion = await prisma.camion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CamionFindFirstOrThrowArgs>(args?: SelectSubset<T, CamionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CamionClient<$Result.GetResult<Prisma.$CamionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Camions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CamionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Camions
     * const camions = await prisma.camion.findMany()
     * 
     * // Get first 10 Camions
     * const camions = await prisma.camion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const camionWithIdOnly = await prisma.camion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CamionFindManyArgs>(args?: SelectSubset<T, CamionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CamionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Camion.
     * @param {CamionCreateArgs} args - Arguments to create a Camion.
     * @example
     * // Create one Camion
     * const Camion = await prisma.camion.create({
     *   data: {
     *     // ... data to create a Camion
     *   }
     * })
     * 
     */
    create<T extends CamionCreateArgs>(args: SelectSubset<T, CamionCreateArgs<ExtArgs>>): Prisma__CamionClient<$Result.GetResult<Prisma.$CamionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Camions.
     * @param {CamionCreateManyArgs} args - Arguments to create many Camions.
     * @example
     * // Create many Camions
     * const camion = await prisma.camion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CamionCreateManyArgs>(args?: SelectSubset<T, CamionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Camions and returns the data saved in the database.
     * @param {CamionCreateManyAndReturnArgs} args - Arguments to create many Camions.
     * @example
     * // Create many Camions
     * const camion = await prisma.camion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Camions and only return the `id`
     * const camionWithIdOnly = await prisma.camion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CamionCreateManyAndReturnArgs>(args?: SelectSubset<T, CamionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CamionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Camion.
     * @param {CamionDeleteArgs} args - Arguments to delete one Camion.
     * @example
     * // Delete one Camion
     * const Camion = await prisma.camion.delete({
     *   where: {
     *     // ... filter to delete one Camion
     *   }
     * })
     * 
     */
    delete<T extends CamionDeleteArgs>(args: SelectSubset<T, CamionDeleteArgs<ExtArgs>>): Prisma__CamionClient<$Result.GetResult<Prisma.$CamionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Camion.
     * @param {CamionUpdateArgs} args - Arguments to update one Camion.
     * @example
     * // Update one Camion
     * const camion = await prisma.camion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CamionUpdateArgs>(args: SelectSubset<T, CamionUpdateArgs<ExtArgs>>): Prisma__CamionClient<$Result.GetResult<Prisma.$CamionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Camions.
     * @param {CamionDeleteManyArgs} args - Arguments to filter Camions to delete.
     * @example
     * // Delete a few Camions
     * const { count } = await prisma.camion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CamionDeleteManyArgs>(args?: SelectSubset<T, CamionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Camions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CamionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Camions
     * const camion = await prisma.camion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CamionUpdateManyArgs>(args: SelectSubset<T, CamionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Camions and returns the data updated in the database.
     * @param {CamionUpdateManyAndReturnArgs} args - Arguments to update many Camions.
     * @example
     * // Update many Camions
     * const camion = await prisma.camion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Camions and only return the `id`
     * const camionWithIdOnly = await prisma.camion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CamionUpdateManyAndReturnArgs>(args: SelectSubset<T, CamionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CamionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Camion.
     * @param {CamionUpsertArgs} args - Arguments to update or create a Camion.
     * @example
     * // Update or create a Camion
     * const camion = await prisma.camion.upsert({
     *   create: {
     *     // ... data to create a Camion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Camion we want to update
     *   }
     * })
     */
    upsert<T extends CamionUpsertArgs>(args: SelectSubset<T, CamionUpsertArgs<ExtArgs>>): Prisma__CamionClient<$Result.GetResult<Prisma.$CamionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Camions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CamionCountArgs} args - Arguments to filter Camions to count.
     * @example
     * // Count the number of Camions
     * const count = await prisma.camion.count({
     *   where: {
     *     // ... the filter for the Camions we want to count
     *   }
     * })
    **/
    count<T extends CamionCountArgs>(
      args?: Subset<T, CamionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CamionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Camion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CamionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CamionAggregateArgs>(args: Subset<T, CamionAggregateArgs>): Prisma.PrismaPromise<GetCamionAggregateType<T>>

    /**
     * Group by Camion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CamionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CamionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CamionGroupByArgs['orderBy'] }
        : { orderBy?: CamionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CamionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCamionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Camion model
   */
  readonly fields: CamionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Camion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CamionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    factures<T extends Camion$facturesArgs<ExtArgs> = {}>(args?: Subset<T, Camion$facturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactureImportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Camion model
   */
  interface CamionFieldRefs {
    readonly id: FieldRef<"Camion", 'String'>
    readonly libelle: FieldRef<"Camion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Camion findUnique
   */
  export type CamionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Camion
     */
    select?: CamionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Camion
     */
    omit?: CamionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CamionInclude<ExtArgs> | null
    /**
     * Filter, which Camion to fetch.
     */
    where: CamionWhereUniqueInput
  }

  /**
   * Camion findUniqueOrThrow
   */
  export type CamionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Camion
     */
    select?: CamionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Camion
     */
    omit?: CamionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CamionInclude<ExtArgs> | null
    /**
     * Filter, which Camion to fetch.
     */
    where: CamionWhereUniqueInput
  }

  /**
   * Camion findFirst
   */
  export type CamionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Camion
     */
    select?: CamionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Camion
     */
    omit?: CamionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CamionInclude<ExtArgs> | null
    /**
     * Filter, which Camion to fetch.
     */
    where?: CamionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Camions to fetch.
     */
    orderBy?: CamionOrderByWithRelationInput | CamionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Camions.
     */
    cursor?: CamionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Camions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Camions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Camions.
     */
    distinct?: CamionScalarFieldEnum | CamionScalarFieldEnum[]
  }

  /**
   * Camion findFirstOrThrow
   */
  export type CamionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Camion
     */
    select?: CamionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Camion
     */
    omit?: CamionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CamionInclude<ExtArgs> | null
    /**
     * Filter, which Camion to fetch.
     */
    where?: CamionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Camions to fetch.
     */
    orderBy?: CamionOrderByWithRelationInput | CamionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Camions.
     */
    cursor?: CamionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Camions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Camions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Camions.
     */
    distinct?: CamionScalarFieldEnum | CamionScalarFieldEnum[]
  }

  /**
   * Camion findMany
   */
  export type CamionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Camion
     */
    select?: CamionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Camion
     */
    omit?: CamionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CamionInclude<ExtArgs> | null
    /**
     * Filter, which Camions to fetch.
     */
    where?: CamionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Camions to fetch.
     */
    orderBy?: CamionOrderByWithRelationInput | CamionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Camions.
     */
    cursor?: CamionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Camions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Camions.
     */
    skip?: number
    distinct?: CamionScalarFieldEnum | CamionScalarFieldEnum[]
  }

  /**
   * Camion create
   */
  export type CamionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Camion
     */
    select?: CamionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Camion
     */
    omit?: CamionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CamionInclude<ExtArgs> | null
    /**
     * The data needed to create a Camion.
     */
    data: XOR<CamionCreateInput, CamionUncheckedCreateInput>
  }

  /**
   * Camion createMany
   */
  export type CamionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Camions.
     */
    data: CamionCreateManyInput | CamionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Camion createManyAndReturn
   */
  export type CamionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Camion
     */
    select?: CamionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Camion
     */
    omit?: CamionOmit<ExtArgs> | null
    /**
     * The data used to create many Camions.
     */
    data: CamionCreateManyInput | CamionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Camion update
   */
  export type CamionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Camion
     */
    select?: CamionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Camion
     */
    omit?: CamionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CamionInclude<ExtArgs> | null
    /**
     * The data needed to update a Camion.
     */
    data: XOR<CamionUpdateInput, CamionUncheckedUpdateInput>
    /**
     * Choose, which Camion to update.
     */
    where: CamionWhereUniqueInput
  }

  /**
   * Camion updateMany
   */
  export type CamionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Camions.
     */
    data: XOR<CamionUpdateManyMutationInput, CamionUncheckedUpdateManyInput>
    /**
     * Filter which Camions to update
     */
    where?: CamionWhereInput
    /**
     * Limit how many Camions to update.
     */
    limit?: number
  }

  /**
   * Camion updateManyAndReturn
   */
  export type CamionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Camion
     */
    select?: CamionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Camion
     */
    omit?: CamionOmit<ExtArgs> | null
    /**
     * The data used to update Camions.
     */
    data: XOR<CamionUpdateManyMutationInput, CamionUncheckedUpdateManyInput>
    /**
     * Filter which Camions to update
     */
    where?: CamionWhereInput
    /**
     * Limit how many Camions to update.
     */
    limit?: number
  }

  /**
   * Camion upsert
   */
  export type CamionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Camion
     */
    select?: CamionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Camion
     */
    omit?: CamionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CamionInclude<ExtArgs> | null
    /**
     * The filter to search for the Camion to update in case it exists.
     */
    where: CamionWhereUniqueInput
    /**
     * In case the Camion found by the `where` argument doesn't exist, create a new Camion with this data.
     */
    create: XOR<CamionCreateInput, CamionUncheckedCreateInput>
    /**
     * In case the Camion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CamionUpdateInput, CamionUncheckedUpdateInput>
  }

  /**
   * Camion delete
   */
  export type CamionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Camion
     */
    select?: CamionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Camion
     */
    omit?: CamionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CamionInclude<ExtArgs> | null
    /**
     * Filter which Camion to delete.
     */
    where: CamionWhereUniqueInput
  }

  /**
   * Camion deleteMany
   */
  export type CamionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Camions to delete
     */
    where?: CamionWhereInput
    /**
     * Limit how many Camions to delete.
     */
    limit?: number
  }

  /**
   * Camion.factures
   */
  export type Camion$facturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactureImport
     */
    select?: FactureImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactureImport
     */
    omit?: FactureImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureImportInclude<ExtArgs> | null
    where?: FactureImportWhereInput
    orderBy?: FactureImportOrderByWithRelationInput | FactureImportOrderByWithRelationInput[]
    cursor?: FactureImportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FactureImportScalarFieldEnum | FactureImportScalarFieldEnum[]
  }

  /**
   * Camion without action
   */
  export type CamionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Camion
     */
    select?: CamionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Camion
     */
    omit?: CamionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CamionInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    nom_client: string | null
    code: string | null
    num_nif: string | null
    adresse: string | null
    telephone: string | null
    email: string | null
    rccm: string | null
    idNat: string | null
    isFacturedForImport: string | null
    isFacturedForExport: string | null
    isFacturedForTva: string | null
    lastPrintedDeclation: Date | null
    enabled: string | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    nom_client: string | null
    code: string | null
    num_nif: string | null
    adresse: string | null
    telephone: string | null
    email: string | null
    rccm: string | null
    idNat: string | null
    isFacturedForImport: string | null
    isFacturedForExport: string | null
    isFacturedForTva: string | null
    lastPrintedDeclation: Date | null
    enabled: string | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    nom_client: number
    code: number
    num_nif: number
    adresse: number
    telephone: number
    email: number
    rccm: number
    idNat: number
    isFacturedForImport: number
    isFacturedForExport: number
    isFacturedForTva: number
    lastPrintedDeclation: number
    enabled: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    nom_client?: true
    code?: true
    num_nif?: true
    adresse?: true
    telephone?: true
    email?: true
    rccm?: true
    idNat?: true
    isFacturedForImport?: true
    isFacturedForExport?: true
    isFacturedForTva?: true
    lastPrintedDeclation?: true
    enabled?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    nom_client?: true
    code?: true
    num_nif?: true
    adresse?: true
    telephone?: true
    email?: true
    rccm?: true
    idNat?: true
    isFacturedForImport?: true
    isFacturedForExport?: true
    isFacturedForTva?: true
    lastPrintedDeclation?: true
    enabled?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    nom_client?: true
    code?: true
    num_nif?: true
    adresse?: true
    telephone?: true
    email?: true
    rccm?: true
    idNat?: true
    isFacturedForImport?: true
    isFacturedForExport?: true
    isFacturedForTva?: true
    lastPrintedDeclation?: true
    enabled?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    nom_client: string | null
    code: string | null
    num_nif: string | null
    adresse: string | null
    telephone: string | null
    email: string | null
    rccm: string | null
    idNat: string | null
    isFacturedForImport: string | null
    isFacturedForExport: string | null
    isFacturedForTva: string | null
    lastPrintedDeclation: Date | null
    enabled: string | null
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom_client?: boolean
    code?: boolean
    num_nif?: boolean
    adresse?: boolean
    telephone?: boolean
    email?: boolean
    rccm?: boolean
    idNat?: boolean
    isFacturedForImport?: boolean
    isFacturedForExport?: boolean
    isFacturedForTva?: boolean
    lastPrintedDeclation?: boolean
    enabled?: boolean
    paiement?: boolean | Client$paiementArgs<ExtArgs>
    journalType?: boolean | Client$journalTypeArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom_client?: boolean
    code?: boolean
    num_nif?: boolean
    adresse?: boolean
    telephone?: boolean
    email?: boolean
    rccm?: boolean
    idNat?: boolean
    isFacturedForImport?: boolean
    isFacturedForExport?: boolean
    isFacturedForTva?: boolean
    lastPrintedDeclation?: boolean
    enabled?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom_client?: boolean
    code?: boolean
    num_nif?: boolean
    adresse?: boolean
    telephone?: boolean
    email?: boolean
    rccm?: boolean
    idNat?: boolean
    isFacturedForImport?: boolean
    isFacturedForExport?: boolean
    isFacturedForTva?: boolean
    lastPrintedDeclation?: boolean
    enabled?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    nom_client?: boolean
    code?: boolean
    num_nif?: boolean
    adresse?: boolean
    telephone?: boolean
    email?: boolean
    rccm?: boolean
    idNat?: boolean
    isFacturedForImport?: boolean
    isFacturedForExport?: boolean
    isFacturedForTva?: boolean
    lastPrintedDeclation?: boolean
    enabled?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom_client" | "code" | "num_nif" | "adresse" | "telephone" | "email" | "rccm" | "idNat" | "isFacturedForImport" | "isFacturedForExport" | "isFacturedForTva" | "lastPrintedDeclation" | "enabled", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paiement?: boolean | Client$paiementArgs<ExtArgs>
    journalType?: boolean | Client$journalTypeArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      paiement: Prisma.$PaiementPayload<ExtArgs>[]
      journalType: Prisma.$JournalTypePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nom_client: string | null
      code: string | null
      num_nif: string | null
      adresse: string | null
      telephone: string | null
      email: string | null
      rccm: string | null
      idNat: string | null
      isFacturedForImport: string | null
      isFacturedForExport: string | null
      isFacturedForTva: string | null
      lastPrintedDeclation: Date | null
      enabled: string | null
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paiement<T extends Client$paiementArgs<ExtArgs> = {}>(args?: Subset<T, Client$paiementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    journalType<T extends Client$journalTypeArgs<ExtArgs> = {}>(args?: Subset<T, Client$journalTypeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly nom_client: FieldRef<"Client", 'String'>
    readonly code: FieldRef<"Client", 'String'>
    readonly num_nif: FieldRef<"Client", 'String'>
    readonly adresse: FieldRef<"Client", 'String'>
    readonly telephone: FieldRef<"Client", 'String'>
    readonly email: FieldRef<"Client", 'String'>
    readonly rccm: FieldRef<"Client", 'String'>
    readonly idNat: FieldRef<"Client", 'String'>
    readonly isFacturedForImport: FieldRef<"Client", 'String'>
    readonly isFacturedForExport: FieldRef<"Client", 'String'>
    readonly isFacturedForTva: FieldRef<"Client", 'String'>
    readonly lastPrintedDeclation: FieldRef<"Client", 'DateTime'>
    readonly enabled: FieldRef<"Client", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data?: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.paiement
   */
  export type Client$paiementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    where?: PaiementWhereInput
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    cursor?: PaiementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Client.journalType
   */
  export type Client$journalTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalType
     */
    select?: JournalTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalType
     */
    omit?: JournalTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTypeInclude<ExtArgs> | null
    where?: JournalTypeWhereInput
    orderBy?: JournalTypeOrderByWithRelationInput | JournalTypeOrderByWithRelationInput[]
    cursor?: JournalTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalTypeScalarFieldEnum | JournalTypeScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model DetailFacture
   */

  export type AggregateDetailFacture = {
    _count: DetailFactureCountAggregateOutputType | null
    _avg: DetailFactureAvgAggregateOutputType | null
    _sum: DetailFactureSumAggregateOutputType | null
    _min: DetailFactureMinAggregateOutputType | null
    _max: DetailFactureMaxAggregateOutputType | null
  }

  export type DetailFactureAvgAggregateOutputType = {
    qte: number | null
    prix: number | null
  }

  export type DetailFactureSumAggregateOutputType = {
    qte: number | null
    prix: number | null
  }

  export type DetailFactureMinAggregateOutputType = {
    id: string | null
    factureId: string | null
    rubriqueFactureId: string | null
    qte: number | null
    prix: number | null
  }

  export type DetailFactureMaxAggregateOutputType = {
    id: string | null
    factureId: string | null
    rubriqueFactureId: string | null
    qte: number | null
    prix: number | null
  }

  export type DetailFactureCountAggregateOutputType = {
    id: number
    factureId: number
    rubriqueFactureId: number
    qte: number
    prix: number
    _all: number
  }


  export type DetailFactureAvgAggregateInputType = {
    qte?: true
    prix?: true
  }

  export type DetailFactureSumAggregateInputType = {
    qte?: true
    prix?: true
  }

  export type DetailFactureMinAggregateInputType = {
    id?: true
    factureId?: true
    rubriqueFactureId?: true
    qte?: true
    prix?: true
  }

  export type DetailFactureMaxAggregateInputType = {
    id?: true
    factureId?: true
    rubriqueFactureId?: true
    qte?: true
    prix?: true
  }

  export type DetailFactureCountAggregateInputType = {
    id?: true
    factureId?: true
    rubriqueFactureId?: true
    qte?: true
    prix?: true
    _all?: true
  }

  export type DetailFactureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetailFacture to aggregate.
     */
    where?: DetailFactureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetailFactures to fetch.
     */
    orderBy?: DetailFactureOrderByWithRelationInput | DetailFactureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DetailFactureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetailFactures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetailFactures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DetailFactures
    **/
    _count?: true | DetailFactureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DetailFactureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DetailFactureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DetailFactureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DetailFactureMaxAggregateInputType
  }

  export type GetDetailFactureAggregateType<T extends DetailFactureAggregateArgs> = {
        [P in keyof T & keyof AggregateDetailFacture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetailFacture[P]>
      : GetScalarType<T[P], AggregateDetailFacture[P]>
  }




  export type DetailFactureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetailFactureWhereInput
    orderBy?: DetailFactureOrderByWithAggregationInput | DetailFactureOrderByWithAggregationInput[]
    by: DetailFactureScalarFieldEnum[] | DetailFactureScalarFieldEnum
    having?: DetailFactureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DetailFactureCountAggregateInputType | true
    _avg?: DetailFactureAvgAggregateInputType
    _sum?: DetailFactureSumAggregateInputType
    _min?: DetailFactureMinAggregateInputType
    _max?: DetailFactureMaxAggregateInputType
  }

  export type DetailFactureGroupByOutputType = {
    id: string
    factureId: string
    rubriqueFactureId: string
    qte: number
    prix: number
    _count: DetailFactureCountAggregateOutputType | null
    _avg: DetailFactureAvgAggregateOutputType | null
    _sum: DetailFactureSumAggregateOutputType | null
    _min: DetailFactureMinAggregateOutputType | null
    _max: DetailFactureMaxAggregateOutputType | null
  }

  type GetDetailFactureGroupByPayload<T extends DetailFactureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DetailFactureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DetailFactureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DetailFactureGroupByOutputType[P]>
            : GetScalarType<T[P], DetailFactureGroupByOutputType[P]>
        }
      >
    >


  export type DetailFactureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    factureId?: boolean
    rubriqueFactureId?: boolean
    qte?: boolean
    prix?: boolean
    facture?: boolean | FactureImportDefaultArgs<ExtArgs>
    rubriqueFacture?: boolean | RubriqueFactureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detailFacture"]>

  export type DetailFactureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    factureId?: boolean
    rubriqueFactureId?: boolean
    qte?: boolean
    prix?: boolean
    facture?: boolean | FactureImportDefaultArgs<ExtArgs>
    rubriqueFacture?: boolean | RubriqueFactureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detailFacture"]>

  export type DetailFactureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    factureId?: boolean
    rubriqueFactureId?: boolean
    qte?: boolean
    prix?: boolean
    facture?: boolean | FactureImportDefaultArgs<ExtArgs>
    rubriqueFacture?: boolean | RubriqueFactureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detailFacture"]>

  export type DetailFactureSelectScalar = {
    id?: boolean
    factureId?: boolean
    rubriqueFactureId?: boolean
    qte?: boolean
    prix?: boolean
  }

  export type DetailFactureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "factureId" | "rubriqueFactureId" | "qte" | "prix", ExtArgs["result"]["detailFacture"]>
  export type DetailFactureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facture?: boolean | FactureImportDefaultArgs<ExtArgs>
    rubriqueFacture?: boolean | RubriqueFactureDefaultArgs<ExtArgs>
  }
  export type DetailFactureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facture?: boolean | FactureImportDefaultArgs<ExtArgs>
    rubriqueFacture?: boolean | RubriqueFactureDefaultArgs<ExtArgs>
  }
  export type DetailFactureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facture?: boolean | FactureImportDefaultArgs<ExtArgs>
    rubriqueFacture?: boolean | RubriqueFactureDefaultArgs<ExtArgs>
  }

  export type $DetailFacturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DetailFacture"
    objects: {
      facture: Prisma.$FactureImportPayload<ExtArgs>
      rubriqueFacture: Prisma.$RubriqueFacturePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      factureId: string
      rubriqueFactureId: string
      qte: number
      prix: number
    }, ExtArgs["result"]["detailFacture"]>
    composites: {}
  }

  type DetailFactureGetPayload<S extends boolean | null | undefined | DetailFactureDefaultArgs> = $Result.GetResult<Prisma.$DetailFacturePayload, S>

  type DetailFactureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DetailFactureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DetailFactureCountAggregateInputType | true
    }

  export interface DetailFactureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DetailFacture'], meta: { name: 'DetailFacture' } }
    /**
     * Find zero or one DetailFacture that matches the filter.
     * @param {DetailFactureFindUniqueArgs} args - Arguments to find a DetailFacture
     * @example
     * // Get one DetailFacture
     * const detailFacture = await prisma.detailFacture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DetailFactureFindUniqueArgs>(args: SelectSubset<T, DetailFactureFindUniqueArgs<ExtArgs>>): Prisma__DetailFactureClient<$Result.GetResult<Prisma.$DetailFacturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DetailFacture that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DetailFactureFindUniqueOrThrowArgs} args - Arguments to find a DetailFacture
     * @example
     * // Get one DetailFacture
     * const detailFacture = await prisma.detailFacture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DetailFactureFindUniqueOrThrowArgs>(args: SelectSubset<T, DetailFactureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DetailFactureClient<$Result.GetResult<Prisma.$DetailFacturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DetailFacture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailFactureFindFirstArgs} args - Arguments to find a DetailFacture
     * @example
     * // Get one DetailFacture
     * const detailFacture = await prisma.detailFacture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DetailFactureFindFirstArgs>(args?: SelectSubset<T, DetailFactureFindFirstArgs<ExtArgs>>): Prisma__DetailFactureClient<$Result.GetResult<Prisma.$DetailFacturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DetailFacture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailFactureFindFirstOrThrowArgs} args - Arguments to find a DetailFacture
     * @example
     * // Get one DetailFacture
     * const detailFacture = await prisma.detailFacture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DetailFactureFindFirstOrThrowArgs>(args?: SelectSubset<T, DetailFactureFindFirstOrThrowArgs<ExtArgs>>): Prisma__DetailFactureClient<$Result.GetResult<Prisma.$DetailFacturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DetailFactures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailFactureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DetailFactures
     * const detailFactures = await prisma.detailFacture.findMany()
     * 
     * // Get first 10 DetailFactures
     * const detailFactures = await prisma.detailFacture.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detailFactureWithIdOnly = await prisma.detailFacture.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DetailFactureFindManyArgs>(args?: SelectSubset<T, DetailFactureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetailFacturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DetailFacture.
     * @param {DetailFactureCreateArgs} args - Arguments to create a DetailFacture.
     * @example
     * // Create one DetailFacture
     * const DetailFacture = await prisma.detailFacture.create({
     *   data: {
     *     // ... data to create a DetailFacture
     *   }
     * })
     * 
     */
    create<T extends DetailFactureCreateArgs>(args: SelectSubset<T, DetailFactureCreateArgs<ExtArgs>>): Prisma__DetailFactureClient<$Result.GetResult<Prisma.$DetailFacturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DetailFactures.
     * @param {DetailFactureCreateManyArgs} args - Arguments to create many DetailFactures.
     * @example
     * // Create many DetailFactures
     * const detailFacture = await prisma.detailFacture.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DetailFactureCreateManyArgs>(args?: SelectSubset<T, DetailFactureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DetailFactures and returns the data saved in the database.
     * @param {DetailFactureCreateManyAndReturnArgs} args - Arguments to create many DetailFactures.
     * @example
     * // Create many DetailFactures
     * const detailFacture = await prisma.detailFacture.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DetailFactures and only return the `id`
     * const detailFactureWithIdOnly = await prisma.detailFacture.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DetailFactureCreateManyAndReturnArgs>(args?: SelectSubset<T, DetailFactureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetailFacturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DetailFacture.
     * @param {DetailFactureDeleteArgs} args - Arguments to delete one DetailFacture.
     * @example
     * // Delete one DetailFacture
     * const DetailFacture = await prisma.detailFacture.delete({
     *   where: {
     *     // ... filter to delete one DetailFacture
     *   }
     * })
     * 
     */
    delete<T extends DetailFactureDeleteArgs>(args: SelectSubset<T, DetailFactureDeleteArgs<ExtArgs>>): Prisma__DetailFactureClient<$Result.GetResult<Prisma.$DetailFacturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DetailFacture.
     * @param {DetailFactureUpdateArgs} args - Arguments to update one DetailFacture.
     * @example
     * // Update one DetailFacture
     * const detailFacture = await prisma.detailFacture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DetailFactureUpdateArgs>(args: SelectSubset<T, DetailFactureUpdateArgs<ExtArgs>>): Prisma__DetailFactureClient<$Result.GetResult<Prisma.$DetailFacturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DetailFactures.
     * @param {DetailFactureDeleteManyArgs} args - Arguments to filter DetailFactures to delete.
     * @example
     * // Delete a few DetailFactures
     * const { count } = await prisma.detailFacture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DetailFactureDeleteManyArgs>(args?: SelectSubset<T, DetailFactureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DetailFactures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailFactureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DetailFactures
     * const detailFacture = await prisma.detailFacture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DetailFactureUpdateManyArgs>(args: SelectSubset<T, DetailFactureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DetailFactures and returns the data updated in the database.
     * @param {DetailFactureUpdateManyAndReturnArgs} args - Arguments to update many DetailFactures.
     * @example
     * // Update many DetailFactures
     * const detailFacture = await prisma.detailFacture.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DetailFactures and only return the `id`
     * const detailFactureWithIdOnly = await prisma.detailFacture.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DetailFactureUpdateManyAndReturnArgs>(args: SelectSubset<T, DetailFactureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetailFacturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DetailFacture.
     * @param {DetailFactureUpsertArgs} args - Arguments to update or create a DetailFacture.
     * @example
     * // Update or create a DetailFacture
     * const detailFacture = await prisma.detailFacture.upsert({
     *   create: {
     *     // ... data to create a DetailFacture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DetailFacture we want to update
     *   }
     * })
     */
    upsert<T extends DetailFactureUpsertArgs>(args: SelectSubset<T, DetailFactureUpsertArgs<ExtArgs>>): Prisma__DetailFactureClient<$Result.GetResult<Prisma.$DetailFacturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DetailFactures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailFactureCountArgs} args - Arguments to filter DetailFactures to count.
     * @example
     * // Count the number of DetailFactures
     * const count = await prisma.detailFacture.count({
     *   where: {
     *     // ... the filter for the DetailFactures we want to count
     *   }
     * })
    **/
    count<T extends DetailFactureCountArgs>(
      args?: Subset<T, DetailFactureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DetailFactureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DetailFacture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailFactureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DetailFactureAggregateArgs>(args: Subset<T, DetailFactureAggregateArgs>): Prisma.PrismaPromise<GetDetailFactureAggregateType<T>>

    /**
     * Group by DetailFacture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailFactureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DetailFactureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DetailFactureGroupByArgs['orderBy'] }
        : { orderBy?: DetailFactureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DetailFactureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetailFactureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DetailFacture model
   */
  readonly fields: DetailFactureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DetailFacture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DetailFactureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facture<T extends FactureImportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FactureImportDefaultArgs<ExtArgs>>): Prisma__FactureImportClient<$Result.GetResult<Prisma.$FactureImportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rubriqueFacture<T extends RubriqueFactureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RubriqueFactureDefaultArgs<ExtArgs>>): Prisma__RubriqueFactureClient<$Result.GetResult<Prisma.$RubriqueFacturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DetailFacture model
   */
  interface DetailFactureFieldRefs {
    readonly id: FieldRef<"DetailFacture", 'String'>
    readonly factureId: FieldRef<"DetailFacture", 'String'>
    readonly rubriqueFactureId: FieldRef<"DetailFacture", 'String'>
    readonly qte: FieldRef<"DetailFacture", 'Int'>
    readonly prix: FieldRef<"DetailFacture", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * DetailFacture findUnique
   */
  export type DetailFactureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailFacture
     */
    select?: DetailFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailFacture
     */
    omit?: DetailFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailFactureInclude<ExtArgs> | null
    /**
     * Filter, which DetailFacture to fetch.
     */
    where: DetailFactureWhereUniqueInput
  }

  /**
   * DetailFacture findUniqueOrThrow
   */
  export type DetailFactureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailFacture
     */
    select?: DetailFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailFacture
     */
    omit?: DetailFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailFactureInclude<ExtArgs> | null
    /**
     * Filter, which DetailFacture to fetch.
     */
    where: DetailFactureWhereUniqueInput
  }

  /**
   * DetailFacture findFirst
   */
  export type DetailFactureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailFacture
     */
    select?: DetailFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailFacture
     */
    omit?: DetailFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailFactureInclude<ExtArgs> | null
    /**
     * Filter, which DetailFacture to fetch.
     */
    where?: DetailFactureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetailFactures to fetch.
     */
    orderBy?: DetailFactureOrderByWithRelationInput | DetailFactureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetailFactures.
     */
    cursor?: DetailFactureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetailFactures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetailFactures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetailFactures.
     */
    distinct?: DetailFactureScalarFieldEnum | DetailFactureScalarFieldEnum[]
  }

  /**
   * DetailFacture findFirstOrThrow
   */
  export type DetailFactureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailFacture
     */
    select?: DetailFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailFacture
     */
    omit?: DetailFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailFactureInclude<ExtArgs> | null
    /**
     * Filter, which DetailFacture to fetch.
     */
    where?: DetailFactureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetailFactures to fetch.
     */
    orderBy?: DetailFactureOrderByWithRelationInput | DetailFactureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetailFactures.
     */
    cursor?: DetailFactureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetailFactures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetailFactures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetailFactures.
     */
    distinct?: DetailFactureScalarFieldEnum | DetailFactureScalarFieldEnum[]
  }

  /**
   * DetailFacture findMany
   */
  export type DetailFactureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailFacture
     */
    select?: DetailFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailFacture
     */
    omit?: DetailFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailFactureInclude<ExtArgs> | null
    /**
     * Filter, which DetailFactures to fetch.
     */
    where?: DetailFactureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetailFactures to fetch.
     */
    orderBy?: DetailFactureOrderByWithRelationInput | DetailFactureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DetailFactures.
     */
    cursor?: DetailFactureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetailFactures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetailFactures.
     */
    skip?: number
    distinct?: DetailFactureScalarFieldEnum | DetailFactureScalarFieldEnum[]
  }

  /**
   * DetailFacture create
   */
  export type DetailFactureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailFacture
     */
    select?: DetailFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailFacture
     */
    omit?: DetailFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailFactureInclude<ExtArgs> | null
    /**
     * The data needed to create a DetailFacture.
     */
    data: XOR<DetailFactureCreateInput, DetailFactureUncheckedCreateInput>
  }

  /**
   * DetailFacture createMany
   */
  export type DetailFactureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DetailFactures.
     */
    data: DetailFactureCreateManyInput | DetailFactureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DetailFacture createManyAndReturn
   */
  export type DetailFactureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailFacture
     */
    select?: DetailFactureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DetailFacture
     */
    omit?: DetailFactureOmit<ExtArgs> | null
    /**
     * The data used to create many DetailFactures.
     */
    data: DetailFactureCreateManyInput | DetailFactureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailFactureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DetailFacture update
   */
  export type DetailFactureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailFacture
     */
    select?: DetailFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailFacture
     */
    omit?: DetailFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailFactureInclude<ExtArgs> | null
    /**
     * The data needed to update a DetailFacture.
     */
    data: XOR<DetailFactureUpdateInput, DetailFactureUncheckedUpdateInput>
    /**
     * Choose, which DetailFacture to update.
     */
    where: DetailFactureWhereUniqueInput
  }

  /**
   * DetailFacture updateMany
   */
  export type DetailFactureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DetailFactures.
     */
    data: XOR<DetailFactureUpdateManyMutationInput, DetailFactureUncheckedUpdateManyInput>
    /**
     * Filter which DetailFactures to update
     */
    where?: DetailFactureWhereInput
    /**
     * Limit how many DetailFactures to update.
     */
    limit?: number
  }

  /**
   * DetailFacture updateManyAndReturn
   */
  export type DetailFactureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailFacture
     */
    select?: DetailFactureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DetailFacture
     */
    omit?: DetailFactureOmit<ExtArgs> | null
    /**
     * The data used to update DetailFactures.
     */
    data: XOR<DetailFactureUpdateManyMutationInput, DetailFactureUncheckedUpdateManyInput>
    /**
     * Filter which DetailFactures to update
     */
    where?: DetailFactureWhereInput
    /**
     * Limit how many DetailFactures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailFactureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DetailFacture upsert
   */
  export type DetailFactureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailFacture
     */
    select?: DetailFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailFacture
     */
    omit?: DetailFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailFactureInclude<ExtArgs> | null
    /**
     * The filter to search for the DetailFacture to update in case it exists.
     */
    where: DetailFactureWhereUniqueInput
    /**
     * In case the DetailFacture found by the `where` argument doesn't exist, create a new DetailFacture with this data.
     */
    create: XOR<DetailFactureCreateInput, DetailFactureUncheckedCreateInput>
    /**
     * In case the DetailFacture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DetailFactureUpdateInput, DetailFactureUncheckedUpdateInput>
  }

  /**
   * DetailFacture delete
   */
  export type DetailFactureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailFacture
     */
    select?: DetailFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailFacture
     */
    omit?: DetailFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailFactureInclude<ExtArgs> | null
    /**
     * Filter which DetailFacture to delete.
     */
    where: DetailFactureWhereUniqueInput
  }

  /**
   * DetailFacture deleteMany
   */
  export type DetailFactureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetailFactures to delete
     */
    where?: DetailFactureWhereInput
    /**
     * Limit how many DetailFactures to delete.
     */
    limit?: number
  }

  /**
   * DetailFacture without action
   */
  export type DetailFactureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailFacture
     */
    select?: DetailFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailFacture
     */
    omit?: DetailFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailFactureInclude<ExtArgs> | null
  }


  /**
   * Model FactureImport
   */

  export type AggregateFactureImport = {
    _count: FactureImportCountAggregateOutputType | null
    _avg: FactureImportAvgAggregateOutputType | null
    _sum: FactureImportSumAggregateOutputType | null
    _min: FactureImportMinAggregateOutputType | null
    _max: FactureImportMaxAggregateOutputType | null
  }

  export type FactureImportAvgAggregateOutputType = {
    quittanceMontant: number | null
    montant: number | null
  }

  export type FactureImportSumAggregateOutputType = {
    quittanceMontant: number | null
    montant: number | null
  }

  export type FactureImportMinAggregateOutputType = {
    id: string | null
    dossier: string | null
    dateFacture: Date | null
    journalTypeId: string | null
    manifeste: string | null
    t1: string | null
    camionId: string | null
    marchandiseId: string | null
    declarationId: string | null
    declarationDate: Date | null
    liquidationId: string | null
    liquidationDate: Date | null
    quittanceId: string | null
    quittanceDate: Date | null
    quittanceMontant: number | null
    poids: string | null
    colis: string | null
    status: $Enums.STATUSFACTURE | null
    createdAt: Date | null
    montant: number | null
    typeFact: $Enums.TYPEFACTURATION | null
    niveauSaisie: $Enums.NIVEAUSAISIE | null
    numeroFacture: string | null
  }

  export type FactureImportMaxAggregateOutputType = {
    id: string | null
    dossier: string | null
    dateFacture: Date | null
    journalTypeId: string | null
    manifeste: string | null
    t1: string | null
    camionId: string | null
    marchandiseId: string | null
    declarationId: string | null
    declarationDate: Date | null
    liquidationId: string | null
    liquidationDate: Date | null
    quittanceId: string | null
    quittanceDate: Date | null
    quittanceMontant: number | null
    poids: string | null
    colis: string | null
    status: $Enums.STATUSFACTURE | null
    createdAt: Date | null
    montant: number | null
    typeFact: $Enums.TYPEFACTURATION | null
    niveauSaisie: $Enums.NIVEAUSAISIE | null
    numeroFacture: string | null
  }

  export type FactureImportCountAggregateOutputType = {
    id: number
    dossier: number
    dateFacture: number
    journalTypeId: number
    manifeste: number
    t1: number
    camionId: number
    marchandiseId: number
    declarationId: number
    declarationDate: number
    liquidationId: number
    liquidationDate: number
    quittanceId: number
    quittanceDate: number
    quittanceMontant: number
    poids: number
    colis: number
    status: number
    createdAt: number
    montant: number
    typeFact: number
    niveauSaisie: number
    numeroFacture: number
    _all: number
  }


  export type FactureImportAvgAggregateInputType = {
    quittanceMontant?: true
    montant?: true
  }

  export type FactureImportSumAggregateInputType = {
    quittanceMontant?: true
    montant?: true
  }

  export type FactureImportMinAggregateInputType = {
    id?: true
    dossier?: true
    dateFacture?: true
    journalTypeId?: true
    manifeste?: true
    t1?: true
    camionId?: true
    marchandiseId?: true
    declarationId?: true
    declarationDate?: true
    liquidationId?: true
    liquidationDate?: true
    quittanceId?: true
    quittanceDate?: true
    quittanceMontant?: true
    poids?: true
    colis?: true
    status?: true
    createdAt?: true
    montant?: true
    typeFact?: true
    niveauSaisie?: true
    numeroFacture?: true
  }

  export type FactureImportMaxAggregateInputType = {
    id?: true
    dossier?: true
    dateFacture?: true
    journalTypeId?: true
    manifeste?: true
    t1?: true
    camionId?: true
    marchandiseId?: true
    declarationId?: true
    declarationDate?: true
    liquidationId?: true
    liquidationDate?: true
    quittanceId?: true
    quittanceDate?: true
    quittanceMontant?: true
    poids?: true
    colis?: true
    status?: true
    createdAt?: true
    montant?: true
    typeFact?: true
    niveauSaisie?: true
    numeroFacture?: true
  }

  export type FactureImportCountAggregateInputType = {
    id?: true
    dossier?: true
    dateFacture?: true
    journalTypeId?: true
    manifeste?: true
    t1?: true
    camionId?: true
    marchandiseId?: true
    declarationId?: true
    declarationDate?: true
    liquidationId?: true
    liquidationDate?: true
    quittanceId?: true
    quittanceDate?: true
    quittanceMontant?: true
    poids?: true
    colis?: true
    status?: true
    createdAt?: true
    montant?: true
    typeFact?: true
    niveauSaisie?: true
    numeroFacture?: true
    _all?: true
  }

  export type FactureImportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FactureImport to aggregate.
     */
    where?: FactureImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FactureImports to fetch.
     */
    orderBy?: FactureImportOrderByWithRelationInput | FactureImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FactureImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FactureImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FactureImports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FactureImports
    **/
    _count?: true | FactureImportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FactureImportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FactureImportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FactureImportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FactureImportMaxAggregateInputType
  }

  export type GetFactureImportAggregateType<T extends FactureImportAggregateArgs> = {
        [P in keyof T & keyof AggregateFactureImport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactureImport[P]>
      : GetScalarType<T[P], AggregateFactureImport[P]>
  }




  export type FactureImportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FactureImportWhereInput
    orderBy?: FactureImportOrderByWithAggregationInput | FactureImportOrderByWithAggregationInput[]
    by: FactureImportScalarFieldEnum[] | FactureImportScalarFieldEnum
    having?: FactureImportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FactureImportCountAggregateInputType | true
    _avg?: FactureImportAvgAggregateInputType
    _sum?: FactureImportSumAggregateInputType
    _min?: FactureImportMinAggregateInputType
    _max?: FactureImportMaxAggregateInputType
  }

  export type FactureImportGroupByOutputType = {
    id: string
    dossier: string | null
    dateFacture: Date | null
    journalTypeId: string
    manifeste: string | null
    t1: string | null
    camionId: string
    marchandiseId: string
    declarationId: string | null
    declarationDate: Date | null
    liquidationId: string | null
    liquidationDate: Date | null
    quittanceId: string | null
    quittanceDate: Date | null
    quittanceMontant: number
    poids: string | null
    colis: string | null
    status: $Enums.STATUSFACTURE
    createdAt: Date
    montant: number | null
    typeFact: $Enums.TYPEFACTURATION | null
    niveauSaisie: $Enums.NIVEAUSAISIE
    numeroFacture: string | null
    _count: FactureImportCountAggregateOutputType | null
    _avg: FactureImportAvgAggregateOutputType | null
    _sum: FactureImportSumAggregateOutputType | null
    _min: FactureImportMinAggregateOutputType | null
    _max: FactureImportMaxAggregateOutputType | null
  }

  type GetFactureImportGroupByPayload<T extends FactureImportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FactureImportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FactureImportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FactureImportGroupByOutputType[P]>
            : GetScalarType<T[P], FactureImportGroupByOutputType[P]>
        }
      >
    >


  export type FactureImportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dossier?: boolean
    dateFacture?: boolean
    journalTypeId?: boolean
    manifeste?: boolean
    t1?: boolean
    camionId?: boolean
    marchandiseId?: boolean
    declarationId?: boolean
    declarationDate?: boolean
    liquidationId?: boolean
    liquidationDate?: boolean
    quittanceId?: boolean
    quittanceDate?: boolean
    quittanceMontant?: boolean
    poids?: boolean
    colis?: boolean
    status?: boolean
    createdAt?: boolean
    montant?: boolean
    typeFact?: boolean
    niveauSaisie?: boolean
    numeroFacture?: boolean
    journalType?: boolean | JournalTypeDefaultArgs<ExtArgs>
    camion?: boolean | CamionDefaultArgs<ExtArgs>
    marchandise?: boolean | MarchandiseDefaultArgs<ExtArgs>
    detailFacture?: boolean | FactureImport$detailFactureArgs<ExtArgs>
    _count?: boolean | FactureImportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["factureImport"]>

  export type FactureImportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dossier?: boolean
    dateFacture?: boolean
    journalTypeId?: boolean
    manifeste?: boolean
    t1?: boolean
    camionId?: boolean
    marchandiseId?: boolean
    declarationId?: boolean
    declarationDate?: boolean
    liquidationId?: boolean
    liquidationDate?: boolean
    quittanceId?: boolean
    quittanceDate?: boolean
    quittanceMontant?: boolean
    poids?: boolean
    colis?: boolean
    status?: boolean
    createdAt?: boolean
    montant?: boolean
    typeFact?: boolean
    niveauSaisie?: boolean
    numeroFacture?: boolean
    journalType?: boolean | JournalTypeDefaultArgs<ExtArgs>
    camion?: boolean | CamionDefaultArgs<ExtArgs>
    marchandise?: boolean | MarchandiseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["factureImport"]>

  export type FactureImportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dossier?: boolean
    dateFacture?: boolean
    journalTypeId?: boolean
    manifeste?: boolean
    t1?: boolean
    camionId?: boolean
    marchandiseId?: boolean
    declarationId?: boolean
    declarationDate?: boolean
    liquidationId?: boolean
    liquidationDate?: boolean
    quittanceId?: boolean
    quittanceDate?: boolean
    quittanceMontant?: boolean
    poids?: boolean
    colis?: boolean
    status?: boolean
    createdAt?: boolean
    montant?: boolean
    typeFact?: boolean
    niveauSaisie?: boolean
    numeroFacture?: boolean
    journalType?: boolean | JournalTypeDefaultArgs<ExtArgs>
    camion?: boolean | CamionDefaultArgs<ExtArgs>
    marchandise?: boolean | MarchandiseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["factureImport"]>

  export type FactureImportSelectScalar = {
    id?: boolean
    dossier?: boolean
    dateFacture?: boolean
    journalTypeId?: boolean
    manifeste?: boolean
    t1?: boolean
    camionId?: boolean
    marchandiseId?: boolean
    declarationId?: boolean
    declarationDate?: boolean
    liquidationId?: boolean
    liquidationDate?: boolean
    quittanceId?: boolean
    quittanceDate?: boolean
    quittanceMontant?: boolean
    poids?: boolean
    colis?: boolean
    status?: boolean
    createdAt?: boolean
    montant?: boolean
    typeFact?: boolean
    niveauSaisie?: boolean
    numeroFacture?: boolean
  }

  export type FactureImportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dossier" | "dateFacture" | "journalTypeId" | "manifeste" | "t1" | "camionId" | "marchandiseId" | "declarationId" | "declarationDate" | "liquidationId" | "liquidationDate" | "quittanceId" | "quittanceDate" | "quittanceMontant" | "poids" | "colis" | "status" | "createdAt" | "montant" | "typeFact" | "niveauSaisie" | "numeroFacture", ExtArgs["result"]["factureImport"]>
  export type FactureImportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journalType?: boolean | JournalTypeDefaultArgs<ExtArgs>
    camion?: boolean | CamionDefaultArgs<ExtArgs>
    marchandise?: boolean | MarchandiseDefaultArgs<ExtArgs>
    detailFacture?: boolean | FactureImport$detailFactureArgs<ExtArgs>
    _count?: boolean | FactureImportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FactureImportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journalType?: boolean | JournalTypeDefaultArgs<ExtArgs>
    camion?: boolean | CamionDefaultArgs<ExtArgs>
    marchandise?: boolean | MarchandiseDefaultArgs<ExtArgs>
  }
  export type FactureImportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journalType?: boolean | JournalTypeDefaultArgs<ExtArgs>
    camion?: boolean | CamionDefaultArgs<ExtArgs>
    marchandise?: boolean | MarchandiseDefaultArgs<ExtArgs>
  }

  export type $FactureImportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FactureImport"
    objects: {
      journalType: Prisma.$JournalTypePayload<ExtArgs>
      camion: Prisma.$CamionPayload<ExtArgs>
      marchandise: Prisma.$MarchandisePayload<ExtArgs>
      detailFacture: Prisma.$DetailFacturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dossier: string | null
      dateFacture: Date | null
      journalTypeId: string
      manifeste: string | null
      t1: string | null
      camionId: string
      marchandiseId: string
      declarationId: string | null
      declarationDate: Date | null
      liquidationId: string | null
      liquidationDate: Date | null
      quittanceId: string | null
      quittanceDate: Date | null
      quittanceMontant: number
      poids: string | null
      colis: string | null
      status: $Enums.STATUSFACTURE
      createdAt: Date
      montant: number | null
      typeFact: $Enums.TYPEFACTURATION | null
      niveauSaisie: $Enums.NIVEAUSAISIE
      numeroFacture: string | null
    }, ExtArgs["result"]["factureImport"]>
    composites: {}
  }

  type FactureImportGetPayload<S extends boolean | null | undefined | FactureImportDefaultArgs> = $Result.GetResult<Prisma.$FactureImportPayload, S>

  type FactureImportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FactureImportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FactureImportCountAggregateInputType | true
    }

  export interface FactureImportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FactureImport'], meta: { name: 'FactureImport' } }
    /**
     * Find zero or one FactureImport that matches the filter.
     * @param {FactureImportFindUniqueArgs} args - Arguments to find a FactureImport
     * @example
     * // Get one FactureImport
     * const factureImport = await prisma.factureImport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FactureImportFindUniqueArgs>(args: SelectSubset<T, FactureImportFindUniqueArgs<ExtArgs>>): Prisma__FactureImportClient<$Result.GetResult<Prisma.$FactureImportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FactureImport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FactureImportFindUniqueOrThrowArgs} args - Arguments to find a FactureImport
     * @example
     * // Get one FactureImport
     * const factureImport = await prisma.factureImport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FactureImportFindUniqueOrThrowArgs>(args: SelectSubset<T, FactureImportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FactureImportClient<$Result.GetResult<Prisma.$FactureImportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FactureImport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactureImportFindFirstArgs} args - Arguments to find a FactureImport
     * @example
     * // Get one FactureImport
     * const factureImport = await prisma.factureImport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FactureImportFindFirstArgs>(args?: SelectSubset<T, FactureImportFindFirstArgs<ExtArgs>>): Prisma__FactureImportClient<$Result.GetResult<Prisma.$FactureImportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FactureImport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactureImportFindFirstOrThrowArgs} args - Arguments to find a FactureImport
     * @example
     * // Get one FactureImport
     * const factureImport = await prisma.factureImport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FactureImportFindFirstOrThrowArgs>(args?: SelectSubset<T, FactureImportFindFirstOrThrowArgs<ExtArgs>>): Prisma__FactureImportClient<$Result.GetResult<Prisma.$FactureImportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FactureImports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactureImportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FactureImports
     * const factureImports = await prisma.factureImport.findMany()
     * 
     * // Get first 10 FactureImports
     * const factureImports = await prisma.factureImport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const factureImportWithIdOnly = await prisma.factureImport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FactureImportFindManyArgs>(args?: SelectSubset<T, FactureImportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactureImportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FactureImport.
     * @param {FactureImportCreateArgs} args - Arguments to create a FactureImport.
     * @example
     * // Create one FactureImport
     * const FactureImport = await prisma.factureImport.create({
     *   data: {
     *     // ... data to create a FactureImport
     *   }
     * })
     * 
     */
    create<T extends FactureImportCreateArgs>(args: SelectSubset<T, FactureImportCreateArgs<ExtArgs>>): Prisma__FactureImportClient<$Result.GetResult<Prisma.$FactureImportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FactureImports.
     * @param {FactureImportCreateManyArgs} args - Arguments to create many FactureImports.
     * @example
     * // Create many FactureImports
     * const factureImport = await prisma.factureImport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FactureImportCreateManyArgs>(args?: SelectSubset<T, FactureImportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FactureImports and returns the data saved in the database.
     * @param {FactureImportCreateManyAndReturnArgs} args - Arguments to create many FactureImports.
     * @example
     * // Create many FactureImports
     * const factureImport = await prisma.factureImport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FactureImports and only return the `id`
     * const factureImportWithIdOnly = await prisma.factureImport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FactureImportCreateManyAndReturnArgs>(args?: SelectSubset<T, FactureImportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactureImportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FactureImport.
     * @param {FactureImportDeleteArgs} args - Arguments to delete one FactureImport.
     * @example
     * // Delete one FactureImport
     * const FactureImport = await prisma.factureImport.delete({
     *   where: {
     *     // ... filter to delete one FactureImport
     *   }
     * })
     * 
     */
    delete<T extends FactureImportDeleteArgs>(args: SelectSubset<T, FactureImportDeleteArgs<ExtArgs>>): Prisma__FactureImportClient<$Result.GetResult<Prisma.$FactureImportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FactureImport.
     * @param {FactureImportUpdateArgs} args - Arguments to update one FactureImport.
     * @example
     * // Update one FactureImport
     * const factureImport = await prisma.factureImport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FactureImportUpdateArgs>(args: SelectSubset<T, FactureImportUpdateArgs<ExtArgs>>): Prisma__FactureImportClient<$Result.GetResult<Prisma.$FactureImportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FactureImports.
     * @param {FactureImportDeleteManyArgs} args - Arguments to filter FactureImports to delete.
     * @example
     * // Delete a few FactureImports
     * const { count } = await prisma.factureImport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FactureImportDeleteManyArgs>(args?: SelectSubset<T, FactureImportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactureImports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactureImportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FactureImports
     * const factureImport = await prisma.factureImport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FactureImportUpdateManyArgs>(args: SelectSubset<T, FactureImportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactureImports and returns the data updated in the database.
     * @param {FactureImportUpdateManyAndReturnArgs} args - Arguments to update many FactureImports.
     * @example
     * // Update many FactureImports
     * const factureImport = await prisma.factureImport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FactureImports and only return the `id`
     * const factureImportWithIdOnly = await prisma.factureImport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FactureImportUpdateManyAndReturnArgs>(args: SelectSubset<T, FactureImportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactureImportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FactureImport.
     * @param {FactureImportUpsertArgs} args - Arguments to update or create a FactureImport.
     * @example
     * // Update or create a FactureImport
     * const factureImport = await prisma.factureImport.upsert({
     *   create: {
     *     // ... data to create a FactureImport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FactureImport we want to update
     *   }
     * })
     */
    upsert<T extends FactureImportUpsertArgs>(args: SelectSubset<T, FactureImportUpsertArgs<ExtArgs>>): Prisma__FactureImportClient<$Result.GetResult<Prisma.$FactureImportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FactureImports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactureImportCountArgs} args - Arguments to filter FactureImports to count.
     * @example
     * // Count the number of FactureImports
     * const count = await prisma.factureImport.count({
     *   where: {
     *     // ... the filter for the FactureImports we want to count
     *   }
     * })
    **/
    count<T extends FactureImportCountArgs>(
      args?: Subset<T, FactureImportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FactureImportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FactureImport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactureImportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FactureImportAggregateArgs>(args: Subset<T, FactureImportAggregateArgs>): Prisma.PrismaPromise<GetFactureImportAggregateType<T>>

    /**
     * Group by FactureImport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactureImportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FactureImportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FactureImportGroupByArgs['orderBy'] }
        : { orderBy?: FactureImportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FactureImportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFactureImportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FactureImport model
   */
  readonly fields: FactureImportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FactureImport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FactureImportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    journalType<T extends JournalTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JournalTypeDefaultArgs<ExtArgs>>): Prisma__JournalTypeClient<$Result.GetResult<Prisma.$JournalTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    camion<T extends CamionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CamionDefaultArgs<ExtArgs>>): Prisma__CamionClient<$Result.GetResult<Prisma.$CamionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    marchandise<T extends MarchandiseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MarchandiseDefaultArgs<ExtArgs>>): Prisma__MarchandiseClient<$Result.GetResult<Prisma.$MarchandisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    detailFacture<T extends FactureImport$detailFactureArgs<ExtArgs> = {}>(args?: Subset<T, FactureImport$detailFactureArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetailFacturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FactureImport model
   */
  interface FactureImportFieldRefs {
    readonly id: FieldRef<"FactureImport", 'String'>
    readonly dossier: FieldRef<"FactureImport", 'String'>
    readonly dateFacture: FieldRef<"FactureImport", 'DateTime'>
    readonly journalTypeId: FieldRef<"FactureImport", 'String'>
    readonly manifeste: FieldRef<"FactureImport", 'String'>
    readonly t1: FieldRef<"FactureImport", 'String'>
    readonly camionId: FieldRef<"FactureImport", 'String'>
    readonly marchandiseId: FieldRef<"FactureImport", 'String'>
    readonly declarationId: FieldRef<"FactureImport", 'String'>
    readonly declarationDate: FieldRef<"FactureImport", 'DateTime'>
    readonly liquidationId: FieldRef<"FactureImport", 'String'>
    readonly liquidationDate: FieldRef<"FactureImport", 'DateTime'>
    readonly quittanceId: FieldRef<"FactureImport", 'String'>
    readonly quittanceDate: FieldRef<"FactureImport", 'DateTime'>
    readonly quittanceMontant: FieldRef<"FactureImport", 'Float'>
    readonly poids: FieldRef<"FactureImport", 'String'>
    readonly colis: FieldRef<"FactureImport", 'String'>
    readonly status: FieldRef<"FactureImport", 'STATUSFACTURE'>
    readonly createdAt: FieldRef<"FactureImport", 'DateTime'>
    readonly montant: FieldRef<"FactureImport", 'Float'>
    readonly typeFact: FieldRef<"FactureImport", 'TYPEFACTURATION'>
    readonly niveauSaisie: FieldRef<"FactureImport", 'NIVEAUSAISIE'>
    readonly numeroFacture: FieldRef<"FactureImport", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FactureImport findUnique
   */
  export type FactureImportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactureImport
     */
    select?: FactureImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactureImport
     */
    omit?: FactureImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureImportInclude<ExtArgs> | null
    /**
     * Filter, which FactureImport to fetch.
     */
    where: FactureImportWhereUniqueInput
  }

  /**
   * FactureImport findUniqueOrThrow
   */
  export type FactureImportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactureImport
     */
    select?: FactureImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactureImport
     */
    omit?: FactureImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureImportInclude<ExtArgs> | null
    /**
     * Filter, which FactureImport to fetch.
     */
    where: FactureImportWhereUniqueInput
  }

  /**
   * FactureImport findFirst
   */
  export type FactureImportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactureImport
     */
    select?: FactureImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactureImport
     */
    omit?: FactureImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureImportInclude<ExtArgs> | null
    /**
     * Filter, which FactureImport to fetch.
     */
    where?: FactureImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FactureImports to fetch.
     */
    orderBy?: FactureImportOrderByWithRelationInput | FactureImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FactureImports.
     */
    cursor?: FactureImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FactureImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FactureImports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FactureImports.
     */
    distinct?: FactureImportScalarFieldEnum | FactureImportScalarFieldEnum[]
  }

  /**
   * FactureImport findFirstOrThrow
   */
  export type FactureImportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactureImport
     */
    select?: FactureImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactureImport
     */
    omit?: FactureImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureImportInclude<ExtArgs> | null
    /**
     * Filter, which FactureImport to fetch.
     */
    where?: FactureImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FactureImports to fetch.
     */
    orderBy?: FactureImportOrderByWithRelationInput | FactureImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FactureImports.
     */
    cursor?: FactureImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FactureImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FactureImports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FactureImports.
     */
    distinct?: FactureImportScalarFieldEnum | FactureImportScalarFieldEnum[]
  }

  /**
   * FactureImport findMany
   */
  export type FactureImportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactureImport
     */
    select?: FactureImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactureImport
     */
    omit?: FactureImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureImportInclude<ExtArgs> | null
    /**
     * Filter, which FactureImports to fetch.
     */
    where?: FactureImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FactureImports to fetch.
     */
    orderBy?: FactureImportOrderByWithRelationInput | FactureImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FactureImports.
     */
    cursor?: FactureImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FactureImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FactureImports.
     */
    skip?: number
    distinct?: FactureImportScalarFieldEnum | FactureImportScalarFieldEnum[]
  }

  /**
   * FactureImport create
   */
  export type FactureImportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactureImport
     */
    select?: FactureImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactureImport
     */
    omit?: FactureImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureImportInclude<ExtArgs> | null
    /**
     * The data needed to create a FactureImport.
     */
    data: XOR<FactureImportCreateInput, FactureImportUncheckedCreateInput>
  }

  /**
   * FactureImport createMany
   */
  export type FactureImportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FactureImports.
     */
    data: FactureImportCreateManyInput | FactureImportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FactureImport createManyAndReturn
   */
  export type FactureImportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactureImport
     */
    select?: FactureImportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FactureImport
     */
    omit?: FactureImportOmit<ExtArgs> | null
    /**
     * The data used to create many FactureImports.
     */
    data: FactureImportCreateManyInput | FactureImportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureImportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FactureImport update
   */
  export type FactureImportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactureImport
     */
    select?: FactureImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactureImport
     */
    omit?: FactureImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureImportInclude<ExtArgs> | null
    /**
     * The data needed to update a FactureImport.
     */
    data: XOR<FactureImportUpdateInput, FactureImportUncheckedUpdateInput>
    /**
     * Choose, which FactureImport to update.
     */
    where: FactureImportWhereUniqueInput
  }

  /**
   * FactureImport updateMany
   */
  export type FactureImportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FactureImports.
     */
    data: XOR<FactureImportUpdateManyMutationInput, FactureImportUncheckedUpdateManyInput>
    /**
     * Filter which FactureImports to update
     */
    where?: FactureImportWhereInput
    /**
     * Limit how many FactureImports to update.
     */
    limit?: number
  }

  /**
   * FactureImport updateManyAndReturn
   */
  export type FactureImportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactureImport
     */
    select?: FactureImportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FactureImport
     */
    omit?: FactureImportOmit<ExtArgs> | null
    /**
     * The data used to update FactureImports.
     */
    data: XOR<FactureImportUpdateManyMutationInput, FactureImportUncheckedUpdateManyInput>
    /**
     * Filter which FactureImports to update
     */
    where?: FactureImportWhereInput
    /**
     * Limit how many FactureImports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureImportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FactureImport upsert
   */
  export type FactureImportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactureImport
     */
    select?: FactureImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactureImport
     */
    omit?: FactureImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureImportInclude<ExtArgs> | null
    /**
     * The filter to search for the FactureImport to update in case it exists.
     */
    where: FactureImportWhereUniqueInput
    /**
     * In case the FactureImport found by the `where` argument doesn't exist, create a new FactureImport with this data.
     */
    create: XOR<FactureImportCreateInput, FactureImportUncheckedCreateInput>
    /**
     * In case the FactureImport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FactureImportUpdateInput, FactureImportUncheckedUpdateInput>
  }

  /**
   * FactureImport delete
   */
  export type FactureImportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactureImport
     */
    select?: FactureImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactureImport
     */
    omit?: FactureImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureImportInclude<ExtArgs> | null
    /**
     * Filter which FactureImport to delete.
     */
    where: FactureImportWhereUniqueInput
  }

  /**
   * FactureImport deleteMany
   */
  export type FactureImportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FactureImports to delete
     */
    where?: FactureImportWhereInput
    /**
     * Limit how many FactureImports to delete.
     */
    limit?: number
  }

  /**
   * FactureImport.detailFacture
   */
  export type FactureImport$detailFactureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailFacture
     */
    select?: DetailFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailFacture
     */
    omit?: DetailFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailFactureInclude<ExtArgs> | null
    where?: DetailFactureWhereInput
    orderBy?: DetailFactureOrderByWithRelationInput | DetailFactureOrderByWithRelationInput[]
    cursor?: DetailFactureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetailFactureScalarFieldEnum | DetailFactureScalarFieldEnum[]
  }

  /**
   * FactureImport without action
   */
  export type FactureImportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactureImport
     */
    select?: FactureImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactureImport
     */
    omit?: FactureImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureImportInclude<ExtArgs> | null
  }


  /**
   * Model Journal
   */

  export type AggregateJournal = {
    _count: JournalCountAggregateOutputType | null
    _avg: JournalAvgAggregateOutputType | null
    _sum: JournalSumAggregateOutputType | null
    _min: JournalMinAggregateOutputType | null
    _max: JournalMaxAggregateOutputType | null
  }

  export type JournalAvgAggregateOutputType = {
    numero: number | null
  }

  export type JournalSumAggregateOutputType = {
    numero: number | null
  }

  export type JournalMinAggregateOutputType = {
    id: string | null
    journalTypeId: string | null
    numero: number | null
  }

  export type JournalMaxAggregateOutputType = {
    id: string | null
    journalTypeId: string | null
    numero: number | null
  }

  export type JournalCountAggregateOutputType = {
    id: number
    journalTypeId: number
    numero: number
    _all: number
  }


  export type JournalAvgAggregateInputType = {
    numero?: true
  }

  export type JournalSumAggregateInputType = {
    numero?: true
  }

  export type JournalMinAggregateInputType = {
    id?: true
    journalTypeId?: true
    numero?: true
  }

  export type JournalMaxAggregateInputType = {
    id?: true
    journalTypeId?: true
    numero?: true
  }

  export type JournalCountAggregateInputType = {
    id?: true
    journalTypeId?: true
    numero?: true
    _all?: true
  }

  export type JournalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Journal to aggregate.
     */
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Journals
    **/
    _count?: true | JournalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JournalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JournalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalMaxAggregateInputType
  }

  export type GetJournalAggregateType<T extends JournalAggregateArgs> = {
        [P in keyof T & keyof AggregateJournal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournal[P]>
      : GetScalarType<T[P], AggregateJournal[P]>
  }




  export type JournalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalWhereInput
    orderBy?: JournalOrderByWithAggregationInput | JournalOrderByWithAggregationInput[]
    by: JournalScalarFieldEnum[] | JournalScalarFieldEnum
    having?: JournalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalCountAggregateInputType | true
    _avg?: JournalAvgAggregateInputType
    _sum?: JournalSumAggregateInputType
    _min?: JournalMinAggregateInputType
    _max?: JournalMaxAggregateInputType
  }

  export type JournalGroupByOutputType = {
    id: string
    journalTypeId: string | null
    numero: number
    _count: JournalCountAggregateOutputType | null
    _avg: JournalAvgAggregateOutputType | null
    _sum: JournalSumAggregateOutputType | null
    _min: JournalMinAggregateOutputType | null
    _max: JournalMaxAggregateOutputType | null
  }

  type GetJournalGroupByPayload<T extends JournalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalGroupByOutputType[P]>
            : GetScalarType<T[P], JournalGroupByOutputType[P]>
        }
      >
    >


  export type JournalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalTypeId?: boolean
    numero?: boolean
    journalType?: boolean | Journal$journalTypeArgs<ExtArgs>
  }, ExtArgs["result"]["journal"]>

  export type JournalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalTypeId?: boolean
    numero?: boolean
    journalType?: boolean | Journal$journalTypeArgs<ExtArgs>
  }, ExtArgs["result"]["journal"]>

  export type JournalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalTypeId?: boolean
    numero?: boolean
    journalType?: boolean | Journal$journalTypeArgs<ExtArgs>
  }, ExtArgs["result"]["journal"]>

  export type JournalSelectScalar = {
    id?: boolean
    journalTypeId?: boolean
    numero?: boolean
  }

  export type JournalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "journalTypeId" | "numero", ExtArgs["result"]["journal"]>
  export type JournalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journalType?: boolean | Journal$journalTypeArgs<ExtArgs>
  }
  export type JournalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journalType?: boolean | Journal$journalTypeArgs<ExtArgs>
  }
  export type JournalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journalType?: boolean | Journal$journalTypeArgs<ExtArgs>
  }

  export type $JournalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Journal"
    objects: {
      journalType: Prisma.$JournalTypePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      journalTypeId: string | null
      numero: number
    }, ExtArgs["result"]["journal"]>
    composites: {}
  }

  type JournalGetPayload<S extends boolean | null | undefined | JournalDefaultArgs> = $Result.GetResult<Prisma.$JournalPayload, S>

  type JournalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalCountAggregateInputType | true
    }

  export interface JournalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Journal'], meta: { name: 'Journal' } }
    /**
     * Find zero or one Journal that matches the filter.
     * @param {JournalFindUniqueArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalFindUniqueArgs>(args: SelectSubset<T, JournalFindUniqueArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Journal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalFindUniqueOrThrowArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Journal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFindFirstArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalFindFirstArgs>(args?: SelectSubset<T, JournalFindFirstArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Journal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFindFirstOrThrowArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Journals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Journals
     * const journals = await prisma.journal.findMany()
     * 
     * // Get first 10 Journals
     * const journals = await prisma.journal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalWithIdOnly = await prisma.journal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalFindManyArgs>(args?: SelectSubset<T, JournalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Journal.
     * @param {JournalCreateArgs} args - Arguments to create a Journal.
     * @example
     * // Create one Journal
     * const Journal = await prisma.journal.create({
     *   data: {
     *     // ... data to create a Journal
     *   }
     * })
     * 
     */
    create<T extends JournalCreateArgs>(args: SelectSubset<T, JournalCreateArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Journals.
     * @param {JournalCreateManyArgs} args - Arguments to create many Journals.
     * @example
     * // Create many Journals
     * const journal = await prisma.journal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalCreateManyArgs>(args?: SelectSubset<T, JournalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Journals and returns the data saved in the database.
     * @param {JournalCreateManyAndReturnArgs} args - Arguments to create many Journals.
     * @example
     * // Create many Journals
     * const journal = await prisma.journal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Journals and only return the `id`
     * const journalWithIdOnly = await prisma.journal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Journal.
     * @param {JournalDeleteArgs} args - Arguments to delete one Journal.
     * @example
     * // Delete one Journal
     * const Journal = await prisma.journal.delete({
     *   where: {
     *     // ... filter to delete one Journal
     *   }
     * })
     * 
     */
    delete<T extends JournalDeleteArgs>(args: SelectSubset<T, JournalDeleteArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Journal.
     * @param {JournalUpdateArgs} args - Arguments to update one Journal.
     * @example
     * // Update one Journal
     * const journal = await prisma.journal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalUpdateArgs>(args: SelectSubset<T, JournalUpdateArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Journals.
     * @param {JournalDeleteManyArgs} args - Arguments to filter Journals to delete.
     * @example
     * // Delete a few Journals
     * const { count } = await prisma.journal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalDeleteManyArgs>(args?: SelectSubset<T, JournalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Journals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Journals
     * const journal = await prisma.journal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalUpdateManyArgs>(args: SelectSubset<T, JournalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Journals and returns the data updated in the database.
     * @param {JournalUpdateManyAndReturnArgs} args - Arguments to update many Journals.
     * @example
     * // Update many Journals
     * const journal = await prisma.journal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Journals and only return the `id`
     * const journalWithIdOnly = await prisma.journal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Journal.
     * @param {JournalUpsertArgs} args - Arguments to update or create a Journal.
     * @example
     * // Update or create a Journal
     * const journal = await prisma.journal.upsert({
     *   create: {
     *     // ... data to create a Journal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Journal we want to update
     *   }
     * })
     */
    upsert<T extends JournalUpsertArgs>(args: SelectSubset<T, JournalUpsertArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Journals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalCountArgs} args - Arguments to filter Journals to count.
     * @example
     * // Count the number of Journals
     * const count = await prisma.journal.count({
     *   where: {
     *     // ... the filter for the Journals we want to count
     *   }
     * })
    **/
    count<T extends JournalCountArgs>(
      args?: Subset<T, JournalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Journal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalAggregateArgs>(args: Subset<T, JournalAggregateArgs>): Prisma.PrismaPromise<GetJournalAggregateType<T>>

    /**
     * Group by Journal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalGroupByArgs['orderBy'] }
        : { orderBy?: JournalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Journal model
   */
  readonly fields: JournalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Journal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    journalType<T extends Journal$journalTypeArgs<ExtArgs> = {}>(args?: Subset<T, Journal$journalTypeArgs<ExtArgs>>): Prisma__JournalTypeClient<$Result.GetResult<Prisma.$JournalTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Journal model
   */
  interface JournalFieldRefs {
    readonly id: FieldRef<"Journal", 'String'>
    readonly journalTypeId: FieldRef<"Journal", 'String'>
    readonly numero: FieldRef<"Journal", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Journal findUnique
   */
  export type JournalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journal to fetch.
     */
    where: JournalWhereUniqueInput
  }

  /**
   * Journal findUniqueOrThrow
   */
  export type JournalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journal to fetch.
     */
    where: JournalWhereUniqueInput
  }

  /**
   * Journal findFirst
   */
  export type JournalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journal to fetch.
     */
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Journals.
     */
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Journals.
     */
    distinct?: JournalScalarFieldEnum | JournalScalarFieldEnum[]
  }

  /**
   * Journal findFirstOrThrow
   */
  export type JournalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journal to fetch.
     */
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Journals.
     */
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Journals.
     */
    distinct?: JournalScalarFieldEnum | JournalScalarFieldEnum[]
  }

  /**
   * Journal findMany
   */
  export type JournalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journals to fetch.
     */
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Journals.
     */
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    distinct?: JournalScalarFieldEnum | JournalScalarFieldEnum[]
  }

  /**
   * Journal create
   */
  export type JournalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * The data needed to create a Journal.
     */
    data?: XOR<JournalCreateInput, JournalUncheckedCreateInput>
  }

  /**
   * Journal createMany
   */
  export type JournalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Journals.
     */
    data: JournalCreateManyInput | JournalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Journal createManyAndReturn
   */
  export type JournalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * The data used to create many Journals.
     */
    data: JournalCreateManyInput | JournalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Journal update
   */
  export type JournalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * The data needed to update a Journal.
     */
    data: XOR<JournalUpdateInput, JournalUncheckedUpdateInput>
    /**
     * Choose, which Journal to update.
     */
    where: JournalWhereUniqueInput
  }

  /**
   * Journal updateMany
   */
  export type JournalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Journals.
     */
    data: XOR<JournalUpdateManyMutationInput, JournalUncheckedUpdateManyInput>
    /**
     * Filter which Journals to update
     */
    where?: JournalWhereInput
    /**
     * Limit how many Journals to update.
     */
    limit?: number
  }

  /**
   * Journal updateManyAndReturn
   */
  export type JournalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * The data used to update Journals.
     */
    data: XOR<JournalUpdateManyMutationInput, JournalUncheckedUpdateManyInput>
    /**
     * Filter which Journals to update
     */
    where?: JournalWhereInput
    /**
     * Limit how many Journals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Journal upsert
   */
  export type JournalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * The filter to search for the Journal to update in case it exists.
     */
    where: JournalWhereUniqueInput
    /**
     * In case the Journal found by the `where` argument doesn't exist, create a new Journal with this data.
     */
    create: XOR<JournalCreateInput, JournalUncheckedCreateInput>
    /**
     * In case the Journal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalUpdateInput, JournalUncheckedUpdateInput>
  }

  /**
   * Journal delete
   */
  export type JournalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter which Journal to delete.
     */
    where: JournalWhereUniqueInput
  }

  /**
   * Journal deleteMany
   */
  export type JournalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Journals to delete
     */
    where?: JournalWhereInput
    /**
     * Limit how many Journals to delete.
     */
    limit?: number
  }

  /**
   * Journal.journalType
   */
  export type Journal$journalTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalType
     */
    select?: JournalTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalType
     */
    omit?: JournalTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTypeInclude<ExtArgs> | null
    where?: JournalTypeWhereInput
  }

  /**
   * Journal without action
   */
  export type JournalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
  }


  /**
   * Model JournalType
   */

  export type AggregateJournalType = {
    _count: JournalTypeCountAggregateOutputType | null
    _avg: JournalTypeAvgAggregateOutputType | null
    _sum: JournalTypeSumAggregateOutputType | null
    _min: JournalTypeMinAggregateOutputType | null
    _max: JournalTypeMaxAggregateOutputType | null
  }

  export type JournalTypeAvgAggregateOutputType = {
    solde: number | null
  }

  export type JournalTypeSumAggregateOutputType = {
    solde: number | null
  }

  export type JournalTypeMinAggregateOutputType = {
    id: string | null
    libelle: string | null
    formatJournal: string | null
    ClientId: string | null
    derniereImpression: string | null
    solde: number | null
  }

  export type JournalTypeMaxAggregateOutputType = {
    id: string | null
    libelle: string | null
    formatJournal: string | null
    ClientId: string | null
    derniereImpression: string | null
    solde: number | null
  }

  export type JournalTypeCountAggregateOutputType = {
    id: number
    libelle: number
    formatJournal: number
    ClientId: number
    derniereImpression: number
    solde: number
    _all: number
  }


  export type JournalTypeAvgAggregateInputType = {
    solde?: true
  }

  export type JournalTypeSumAggregateInputType = {
    solde?: true
  }

  export type JournalTypeMinAggregateInputType = {
    id?: true
    libelle?: true
    formatJournal?: true
    ClientId?: true
    derniereImpression?: true
    solde?: true
  }

  export type JournalTypeMaxAggregateInputType = {
    id?: true
    libelle?: true
    formatJournal?: true
    ClientId?: true
    derniereImpression?: true
    solde?: true
  }

  export type JournalTypeCountAggregateInputType = {
    id?: true
    libelle?: true
    formatJournal?: true
    ClientId?: true
    derniereImpression?: true
    solde?: true
    _all?: true
  }

  export type JournalTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalType to aggregate.
     */
    where?: JournalTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalTypes to fetch.
     */
    orderBy?: JournalTypeOrderByWithRelationInput | JournalTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalTypes
    **/
    _count?: true | JournalTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JournalTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JournalTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalTypeMaxAggregateInputType
  }

  export type GetJournalTypeAggregateType<T extends JournalTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalType[P]>
      : GetScalarType<T[P], AggregateJournalType[P]>
  }




  export type JournalTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalTypeWhereInput
    orderBy?: JournalTypeOrderByWithAggregationInput | JournalTypeOrderByWithAggregationInput[]
    by: JournalTypeScalarFieldEnum[] | JournalTypeScalarFieldEnum
    having?: JournalTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalTypeCountAggregateInputType | true
    _avg?: JournalTypeAvgAggregateInputType
    _sum?: JournalTypeSumAggregateInputType
    _min?: JournalTypeMinAggregateInputType
    _max?: JournalTypeMaxAggregateInputType
  }

  export type JournalTypeGroupByOutputType = {
    id: string
    libelle: string
    formatJournal: string
    ClientId: string
    derniereImpression: string | null
    solde: number | null
    _count: JournalTypeCountAggregateOutputType | null
    _avg: JournalTypeAvgAggregateOutputType | null
    _sum: JournalTypeSumAggregateOutputType | null
    _min: JournalTypeMinAggregateOutputType | null
    _max: JournalTypeMaxAggregateOutputType | null
  }

  type GetJournalTypeGroupByPayload<T extends JournalTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalTypeGroupByOutputType[P]>
            : GetScalarType<T[P], JournalTypeGroupByOutputType[P]>
        }
      >
    >


  export type JournalTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    libelle?: boolean
    formatJournal?: boolean
    ClientId?: boolean
    derniereImpression?: boolean
    solde?: boolean
    journals?: boolean | JournalType$journalsArgs<ExtArgs>
    Client?: boolean | ClientDefaultArgs<ExtArgs>
    FactureImport?: boolean | JournalType$FactureImportArgs<ExtArgs>
    _count?: boolean | JournalTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalType"]>

  export type JournalTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    libelle?: boolean
    formatJournal?: boolean
    ClientId?: boolean
    derniereImpression?: boolean
    solde?: boolean
    Client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalType"]>

  export type JournalTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    libelle?: boolean
    formatJournal?: boolean
    ClientId?: boolean
    derniereImpression?: boolean
    solde?: boolean
    Client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalType"]>

  export type JournalTypeSelectScalar = {
    id?: boolean
    libelle?: boolean
    formatJournal?: boolean
    ClientId?: boolean
    derniereImpression?: boolean
    solde?: boolean
  }

  export type JournalTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "libelle" | "formatJournal" | "ClientId" | "derniereImpression" | "solde", ExtArgs["result"]["journalType"]>
  export type JournalTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journals?: boolean | JournalType$journalsArgs<ExtArgs>
    Client?: boolean | ClientDefaultArgs<ExtArgs>
    FactureImport?: boolean | JournalType$FactureImportArgs<ExtArgs>
    _count?: boolean | JournalTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JournalTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type JournalTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $JournalTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalType"
    objects: {
      journals: Prisma.$JournalPayload<ExtArgs>[]
      Client: Prisma.$ClientPayload<ExtArgs>
      FactureImport: Prisma.$FactureImportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      libelle: string
      formatJournal: string
      ClientId: string
      derniereImpression: string | null
      solde: number | null
    }, ExtArgs["result"]["journalType"]>
    composites: {}
  }

  type JournalTypeGetPayload<S extends boolean | null | undefined | JournalTypeDefaultArgs> = $Result.GetResult<Prisma.$JournalTypePayload, S>

  type JournalTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalTypeCountAggregateInputType | true
    }

  export interface JournalTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalType'], meta: { name: 'JournalType' } }
    /**
     * Find zero or one JournalType that matches the filter.
     * @param {JournalTypeFindUniqueArgs} args - Arguments to find a JournalType
     * @example
     * // Get one JournalType
     * const journalType = await prisma.journalType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalTypeFindUniqueArgs>(args: SelectSubset<T, JournalTypeFindUniqueArgs<ExtArgs>>): Prisma__JournalTypeClient<$Result.GetResult<Prisma.$JournalTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JournalType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalTypeFindUniqueOrThrowArgs} args - Arguments to find a JournalType
     * @example
     * // Get one JournalType
     * const journalType = await prisma.journalType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalTypeClient<$Result.GetResult<Prisma.$JournalTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalTypeFindFirstArgs} args - Arguments to find a JournalType
     * @example
     * // Get one JournalType
     * const journalType = await prisma.journalType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalTypeFindFirstArgs>(args?: SelectSubset<T, JournalTypeFindFirstArgs<ExtArgs>>): Prisma__JournalTypeClient<$Result.GetResult<Prisma.$JournalTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalTypeFindFirstOrThrowArgs} args - Arguments to find a JournalType
     * @example
     * // Get one JournalType
     * const journalType = await prisma.journalType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalTypeClient<$Result.GetResult<Prisma.$JournalTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JournalTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalTypes
     * const journalTypes = await prisma.journalType.findMany()
     * 
     * // Get first 10 JournalTypes
     * const journalTypes = await prisma.journalType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalTypeWithIdOnly = await prisma.journalType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalTypeFindManyArgs>(args?: SelectSubset<T, JournalTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JournalType.
     * @param {JournalTypeCreateArgs} args - Arguments to create a JournalType.
     * @example
     * // Create one JournalType
     * const JournalType = await prisma.journalType.create({
     *   data: {
     *     // ... data to create a JournalType
     *   }
     * })
     * 
     */
    create<T extends JournalTypeCreateArgs>(args: SelectSubset<T, JournalTypeCreateArgs<ExtArgs>>): Prisma__JournalTypeClient<$Result.GetResult<Prisma.$JournalTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JournalTypes.
     * @param {JournalTypeCreateManyArgs} args - Arguments to create many JournalTypes.
     * @example
     * // Create many JournalTypes
     * const journalType = await prisma.journalType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalTypeCreateManyArgs>(args?: SelectSubset<T, JournalTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalTypes and returns the data saved in the database.
     * @param {JournalTypeCreateManyAndReturnArgs} args - Arguments to create many JournalTypes.
     * @example
     * // Create many JournalTypes
     * const journalType = await prisma.journalType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalTypes and only return the `id`
     * const journalTypeWithIdOnly = await prisma.journalType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JournalType.
     * @param {JournalTypeDeleteArgs} args - Arguments to delete one JournalType.
     * @example
     * // Delete one JournalType
     * const JournalType = await prisma.journalType.delete({
     *   where: {
     *     // ... filter to delete one JournalType
     *   }
     * })
     * 
     */
    delete<T extends JournalTypeDeleteArgs>(args: SelectSubset<T, JournalTypeDeleteArgs<ExtArgs>>): Prisma__JournalTypeClient<$Result.GetResult<Prisma.$JournalTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JournalType.
     * @param {JournalTypeUpdateArgs} args - Arguments to update one JournalType.
     * @example
     * // Update one JournalType
     * const journalType = await prisma.journalType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalTypeUpdateArgs>(args: SelectSubset<T, JournalTypeUpdateArgs<ExtArgs>>): Prisma__JournalTypeClient<$Result.GetResult<Prisma.$JournalTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JournalTypes.
     * @param {JournalTypeDeleteManyArgs} args - Arguments to filter JournalTypes to delete.
     * @example
     * // Delete a few JournalTypes
     * const { count } = await prisma.journalType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalTypeDeleteManyArgs>(args?: SelectSubset<T, JournalTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalTypes
     * const journalType = await prisma.journalType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalTypeUpdateManyArgs>(args: SelectSubset<T, JournalTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalTypes and returns the data updated in the database.
     * @param {JournalTypeUpdateManyAndReturnArgs} args - Arguments to update many JournalTypes.
     * @example
     * // Update many JournalTypes
     * const journalType = await prisma.journalType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JournalTypes and only return the `id`
     * const journalTypeWithIdOnly = await prisma.journalType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JournalType.
     * @param {JournalTypeUpsertArgs} args - Arguments to update or create a JournalType.
     * @example
     * // Update or create a JournalType
     * const journalType = await prisma.journalType.upsert({
     *   create: {
     *     // ... data to create a JournalType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalType we want to update
     *   }
     * })
     */
    upsert<T extends JournalTypeUpsertArgs>(args: SelectSubset<T, JournalTypeUpsertArgs<ExtArgs>>): Prisma__JournalTypeClient<$Result.GetResult<Prisma.$JournalTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JournalTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalTypeCountArgs} args - Arguments to filter JournalTypes to count.
     * @example
     * // Count the number of JournalTypes
     * const count = await prisma.journalType.count({
     *   where: {
     *     // ... the filter for the JournalTypes we want to count
     *   }
     * })
    **/
    count<T extends JournalTypeCountArgs>(
      args?: Subset<T, JournalTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalTypeAggregateArgs>(args: Subset<T, JournalTypeAggregateArgs>): Prisma.PrismaPromise<GetJournalTypeAggregateType<T>>

    /**
     * Group by JournalType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalTypeGroupByArgs['orderBy'] }
        : { orderBy?: JournalTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalType model
   */
  readonly fields: JournalTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    journals<T extends JournalType$journalsArgs<ExtArgs> = {}>(args?: Subset<T, JournalType$journalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    FactureImport<T extends JournalType$FactureImportArgs<ExtArgs> = {}>(args?: Subset<T, JournalType$FactureImportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactureImportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalType model
   */
  interface JournalTypeFieldRefs {
    readonly id: FieldRef<"JournalType", 'String'>
    readonly libelle: FieldRef<"JournalType", 'String'>
    readonly formatJournal: FieldRef<"JournalType", 'String'>
    readonly ClientId: FieldRef<"JournalType", 'String'>
    readonly derniereImpression: FieldRef<"JournalType", 'String'>
    readonly solde: FieldRef<"JournalType", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * JournalType findUnique
   */
  export type JournalTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalType
     */
    select?: JournalTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalType
     */
    omit?: JournalTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTypeInclude<ExtArgs> | null
    /**
     * Filter, which JournalType to fetch.
     */
    where: JournalTypeWhereUniqueInput
  }

  /**
   * JournalType findUniqueOrThrow
   */
  export type JournalTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalType
     */
    select?: JournalTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalType
     */
    omit?: JournalTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTypeInclude<ExtArgs> | null
    /**
     * Filter, which JournalType to fetch.
     */
    where: JournalTypeWhereUniqueInput
  }

  /**
   * JournalType findFirst
   */
  export type JournalTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalType
     */
    select?: JournalTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalType
     */
    omit?: JournalTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTypeInclude<ExtArgs> | null
    /**
     * Filter, which JournalType to fetch.
     */
    where?: JournalTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalTypes to fetch.
     */
    orderBy?: JournalTypeOrderByWithRelationInput | JournalTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalTypes.
     */
    cursor?: JournalTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalTypes.
     */
    distinct?: JournalTypeScalarFieldEnum | JournalTypeScalarFieldEnum[]
  }

  /**
   * JournalType findFirstOrThrow
   */
  export type JournalTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalType
     */
    select?: JournalTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalType
     */
    omit?: JournalTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTypeInclude<ExtArgs> | null
    /**
     * Filter, which JournalType to fetch.
     */
    where?: JournalTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalTypes to fetch.
     */
    orderBy?: JournalTypeOrderByWithRelationInput | JournalTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalTypes.
     */
    cursor?: JournalTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalTypes.
     */
    distinct?: JournalTypeScalarFieldEnum | JournalTypeScalarFieldEnum[]
  }

  /**
   * JournalType findMany
   */
  export type JournalTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalType
     */
    select?: JournalTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalType
     */
    omit?: JournalTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTypeInclude<ExtArgs> | null
    /**
     * Filter, which JournalTypes to fetch.
     */
    where?: JournalTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalTypes to fetch.
     */
    orderBy?: JournalTypeOrderByWithRelationInput | JournalTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalTypes.
     */
    cursor?: JournalTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalTypes.
     */
    skip?: number
    distinct?: JournalTypeScalarFieldEnum | JournalTypeScalarFieldEnum[]
  }

  /**
   * JournalType create
   */
  export type JournalTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalType
     */
    select?: JournalTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalType
     */
    omit?: JournalTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalType.
     */
    data: XOR<JournalTypeCreateInput, JournalTypeUncheckedCreateInput>
  }

  /**
   * JournalType createMany
   */
  export type JournalTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalTypes.
     */
    data: JournalTypeCreateManyInput | JournalTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalType createManyAndReturn
   */
  export type JournalTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalType
     */
    select?: JournalTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalType
     */
    omit?: JournalTypeOmit<ExtArgs> | null
    /**
     * The data used to create many JournalTypes.
     */
    data: JournalTypeCreateManyInput | JournalTypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalType update
   */
  export type JournalTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalType
     */
    select?: JournalTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalType
     */
    omit?: JournalTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalType.
     */
    data: XOR<JournalTypeUpdateInput, JournalTypeUncheckedUpdateInput>
    /**
     * Choose, which JournalType to update.
     */
    where: JournalTypeWhereUniqueInput
  }

  /**
   * JournalType updateMany
   */
  export type JournalTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalTypes.
     */
    data: XOR<JournalTypeUpdateManyMutationInput, JournalTypeUncheckedUpdateManyInput>
    /**
     * Filter which JournalTypes to update
     */
    where?: JournalTypeWhereInput
    /**
     * Limit how many JournalTypes to update.
     */
    limit?: number
  }

  /**
   * JournalType updateManyAndReturn
   */
  export type JournalTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalType
     */
    select?: JournalTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalType
     */
    omit?: JournalTypeOmit<ExtArgs> | null
    /**
     * The data used to update JournalTypes.
     */
    data: XOR<JournalTypeUpdateManyMutationInput, JournalTypeUncheckedUpdateManyInput>
    /**
     * Filter which JournalTypes to update
     */
    where?: JournalTypeWhereInput
    /**
     * Limit how many JournalTypes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTypeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalType upsert
   */
  export type JournalTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalType
     */
    select?: JournalTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalType
     */
    omit?: JournalTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalType to update in case it exists.
     */
    where: JournalTypeWhereUniqueInput
    /**
     * In case the JournalType found by the `where` argument doesn't exist, create a new JournalType with this data.
     */
    create: XOR<JournalTypeCreateInput, JournalTypeUncheckedCreateInput>
    /**
     * In case the JournalType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalTypeUpdateInput, JournalTypeUncheckedUpdateInput>
  }

  /**
   * JournalType delete
   */
  export type JournalTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalType
     */
    select?: JournalTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalType
     */
    omit?: JournalTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTypeInclude<ExtArgs> | null
    /**
     * Filter which JournalType to delete.
     */
    where: JournalTypeWhereUniqueInput
  }

  /**
   * JournalType deleteMany
   */
  export type JournalTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalTypes to delete
     */
    where?: JournalTypeWhereInput
    /**
     * Limit how many JournalTypes to delete.
     */
    limit?: number
  }

  /**
   * JournalType.journals
   */
  export type JournalType$journalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    where?: JournalWhereInput
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    cursor?: JournalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalScalarFieldEnum | JournalScalarFieldEnum[]
  }

  /**
   * JournalType.FactureImport
   */
  export type JournalType$FactureImportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactureImport
     */
    select?: FactureImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactureImport
     */
    omit?: FactureImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureImportInclude<ExtArgs> | null
    where?: FactureImportWhereInput
    orderBy?: FactureImportOrderByWithRelationInput | FactureImportOrderByWithRelationInput[]
    cursor?: FactureImportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FactureImportScalarFieldEnum | FactureImportScalarFieldEnum[]
  }

  /**
   * JournalType without action
   */
  export type JournalTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalType
     */
    select?: JournalTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalType
     */
    omit?: JournalTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalTypeInclude<ExtArgs> | null
  }


  /**
   * Model Marchandise
   */

  export type AggregateMarchandise = {
    _count: MarchandiseCountAggregateOutputType | null
    _min: MarchandiseMinAggregateOutputType | null
    _max: MarchandiseMaxAggregateOutputType | null
  }

  export type MarchandiseMinAggregateOutputType = {
    id: string | null
    libelle: string | null
  }

  export type MarchandiseMaxAggregateOutputType = {
    id: string | null
    libelle: string | null
  }

  export type MarchandiseCountAggregateOutputType = {
    id: number
    libelle: number
    _all: number
  }


  export type MarchandiseMinAggregateInputType = {
    id?: true
    libelle?: true
  }

  export type MarchandiseMaxAggregateInputType = {
    id?: true
    libelle?: true
  }

  export type MarchandiseCountAggregateInputType = {
    id?: true
    libelle?: true
    _all?: true
  }

  export type MarchandiseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Marchandise to aggregate.
     */
    where?: MarchandiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marchandises to fetch.
     */
    orderBy?: MarchandiseOrderByWithRelationInput | MarchandiseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarchandiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marchandises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marchandises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Marchandises
    **/
    _count?: true | MarchandiseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarchandiseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarchandiseMaxAggregateInputType
  }

  export type GetMarchandiseAggregateType<T extends MarchandiseAggregateArgs> = {
        [P in keyof T & keyof AggregateMarchandise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarchandise[P]>
      : GetScalarType<T[P], AggregateMarchandise[P]>
  }




  export type MarchandiseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarchandiseWhereInput
    orderBy?: MarchandiseOrderByWithAggregationInput | MarchandiseOrderByWithAggregationInput[]
    by: MarchandiseScalarFieldEnum[] | MarchandiseScalarFieldEnum
    having?: MarchandiseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarchandiseCountAggregateInputType | true
    _min?: MarchandiseMinAggregateInputType
    _max?: MarchandiseMaxAggregateInputType
  }

  export type MarchandiseGroupByOutputType = {
    id: string
    libelle: string
    _count: MarchandiseCountAggregateOutputType | null
    _min: MarchandiseMinAggregateOutputType | null
    _max: MarchandiseMaxAggregateOutputType | null
  }

  type GetMarchandiseGroupByPayload<T extends MarchandiseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarchandiseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarchandiseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarchandiseGroupByOutputType[P]>
            : GetScalarType<T[P], MarchandiseGroupByOutputType[P]>
        }
      >
    >


  export type MarchandiseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    libelle?: boolean
    factures?: boolean | Marchandise$facturesArgs<ExtArgs>
    _count?: boolean | MarchandiseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marchandise"]>

  export type MarchandiseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    libelle?: boolean
  }, ExtArgs["result"]["marchandise"]>

  export type MarchandiseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    libelle?: boolean
  }, ExtArgs["result"]["marchandise"]>

  export type MarchandiseSelectScalar = {
    id?: boolean
    libelle?: boolean
  }

  export type MarchandiseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "libelle", ExtArgs["result"]["marchandise"]>
  export type MarchandiseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    factures?: boolean | Marchandise$facturesArgs<ExtArgs>
    _count?: boolean | MarchandiseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MarchandiseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MarchandiseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MarchandisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Marchandise"
    objects: {
      factures: Prisma.$FactureImportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      libelle: string
    }, ExtArgs["result"]["marchandise"]>
    composites: {}
  }

  type MarchandiseGetPayload<S extends boolean | null | undefined | MarchandiseDefaultArgs> = $Result.GetResult<Prisma.$MarchandisePayload, S>

  type MarchandiseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarchandiseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarchandiseCountAggregateInputType | true
    }

  export interface MarchandiseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Marchandise'], meta: { name: 'Marchandise' } }
    /**
     * Find zero or one Marchandise that matches the filter.
     * @param {MarchandiseFindUniqueArgs} args - Arguments to find a Marchandise
     * @example
     * // Get one Marchandise
     * const marchandise = await prisma.marchandise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarchandiseFindUniqueArgs>(args: SelectSubset<T, MarchandiseFindUniqueArgs<ExtArgs>>): Prisma__MarchandiseClient<$Result.GetResult<Prisma.$MarchandisePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Marchandise that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarchandiseFindUniqueOrThrowArgs} args - Arguments to find a Marchandise
     * @example
     * // Get one Marchandise
     * const marchandise = await prisma.marchandise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarchandiseFindUniqueOrThrowArgs>(args: SelectSubset<T, MarchandiseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarchandiseClient<$Result.GetResult<Prisma.$MarchandisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Marchandise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarchandiseFindFirstArgs} args - Arguments to find a Marchandise
     * @example
     * // Get one Marchandise
     * const marchandise = await prisma.marchandise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarchandiseFindFirstArgs>(args?: SelectSubset<T, MarchandiseFindFirstArgs<ExtArgs>>): Prisma__MarchandiseClient<$Result.GetResult<Prisma.$MarchandisePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Marchandise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarchandiseFindFirstOrThrowArgs} args - Arguments to find a Marchandise
     * @example
     * // Get one Marchandise
     * const marchandise = await prisma.marchandise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarchandiseFindFirstOrThrowArgs>(args?: SelectSubset<T, MarchandiseFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarchandiseClient<$Result.GetResult<Prisma.$MarchandisePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Marchandises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarchandiseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Marchandises
     * const marchandises = await prisma.marchandise.findMany()
     * 
     * // Get first 10 Marchandises
     * const marchandises = await prisma.marchandise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marchandiseWithIdOnly = await prisma.marchandise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarchandiseFindManyArgs>(args?: SelectSubset<T, MarchandiseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarchandisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Marchandise.
     * @param {MarchandiseCreateArgs} args - Arguments to create a Marchandise.
     * @example
     * // Create one Marchandise
     * const Marchandise = await prisma.marchandise.create({
     *   data: {
     *     // ... data to create a Marchandise
     *   }
     * })
     * 
     */
    create<T extends MarchandiseCreateArgs>(args: SelectSubset<T, MarchandiseCreateArgs<ExtArgs>>): Prisma__MarchandiseClient<$Result.GetResult<Prisma.$MarchandisePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Marchandises.
     * @param {MarchandiseCreateManyArgs} args - Arguments to create many Marchandises.
     * @example
     * // Create many Marchandises
     * const marchandise = await prisma.marchandise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarchandiseCreateManyArgs>(args?: SelectSubset<T, MarchandiseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Marchandises and returns the data saved in the database.
     * @param {MarchandiseCreateManyAndReturnArgs} args - Arguments to create many Marchandises.
     * @example
     * // Create many Marchandises
     * const marchandise = await prisma.marchandise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Marchandises and only return the `id`
     * const marchandiseWithIdOnly = await prisma.marchandise.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarchandiseCreateManyAndReturnArgs>(args?: SelectSubset<T, MarchandiseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarchandisePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Marchandise.
     * @param {MarchandiseDeleteArgs} args - Arguments to delete one Marchandise.
     * @example
     * // Delete one Marchandise
     * const Marchandise = await prisma.marchandise.delete({
     *   where: {
     *     // ... filter to delete one Marchandise
     *   }
     * })
     * 
     */
    delete<T extends MarchandiseDeleteArgs>(args: SelectSubset<T, MarchandiseDeleteArgs<ExtArgs>>): Prisma__MarchandiseClient<$Result.GetResult<Prisma.$MarchandisePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Marchandise.
     * @param {MarchandiseUpdateArgs} args - Arguments to update one Marchandise.
     * @example
     * // Update one Marchandise
     * const marchandise = await prisma.marchandise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarchandiseUpdateArgs>(args: SelectSubset<T, MarchandiseUpdateArgs<ExtArgs>>): Prisma__MarchandiseClient<$Result.GetResult<Prisma.$MarchandisePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Marchandises.
     * @param {MarchandiseDeleteManyArgs} args - Arguments to filter Marchandises to delete.
     * @example
     * // Delete a few Marchandises
     * const { count } = await prisma.marchandise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarchandiseDeleteManyArgs>(args?: SelectSubset<T, MarchandiseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Marchandises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarchandiseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Marchandises
     * const marchandise = await prisma.marchandise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarchandiseUpdateManyArgs>(args: SelectSubset<T, MarchandiseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Marchandises and returns the data updated in the database.
     * @param {MarchandiseUpdateManyAndReturnArgs} args - Arguments to update many Marchandises.
     * @example
     * // Update many Marchandises
     * const marchandise = await prisma.marchandise.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Marchandises and only return the `id`
     * const marchandiseWithIdOnly = await prisma.marchandise.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MarchandiseUpdateManyAndReturnArgs>(args: SelectSubset<T, MarchandiseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarchandisePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Marchandise.
     * @param {MarchandiseUpsertArgs} args - Arguments to update or create a Marchandise.
     * @example
     * // Update or create a Marchandise
     * const marchandise = await prisma.marchandise.upsert({
     *   create: {
     *     // ... data to create a Marchandise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Marchandise we want to update
     *   }
     * })
     */
    upsert<T extends MarchandiseUpsertArgs>(args: SelectSubset<T, MarchandiseUpsertArgs<ExtArgs>>): Prisma__MarchandiseClient<$Result.GetResult<Prisma.$MarchandisePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Marchandises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarchandiseCountArgs} args - Arguments to filter Marchandises to count.
     * @example
     * // Count the number of Marchandises
     * const count = await prisma.marchandise.count({
     *   where: {
     *     // ... the filter for the Marchandises we want to count
     *   }
     * })
    **/
    count<T extends MarchandiseCountArgs>(
      args?: Subset<T, MarchandiseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarchandiseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Marchandise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarchandiseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarchandiseAggregateArgs>(args: Subset<T, MarchandiseAggregateArgs>): Prisma.PrismaPromise<GetMarchandiseAggregateType<T>>

    /**
     * Group by Marchandise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarchandiseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarchandiseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarchandiseGroupByArgs['orderBy'] }
        : { orderBy?: MarchandiseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarchandiseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarchandiseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Marchandise model
   */
  readonly fields: MarchandiseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Marchandise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarchandiseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    factures<T extends Marchandise$facturesArgs<ExtArgs> = {}>(args?: Subset<T, Marchandise$facturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FactureImportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Marchandise model
   */
  interface MarchandiseFieldRefs {
    readonly id: FieldRef<"Marchandise", 'String'>
    readonly libelle: FieldRef<"Marchandise", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Marchandise findUnique
   */
  export type MarchandiseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marchandise
     */
    select?: MarchandiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marchandise
     */
    omit?: MarchandiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandiseInclude<ExtArgs> | null
    /**
     * Filter, which Marchandise to fetch.
     */
    where: MarchandiseWhereUniqueInput
  }

  /**
   * Marchandise findUniqueOrThrow
   */
  export type MarchandiseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marchandise
     */
    select?: MarchandiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marchandise
     */
    omit?: MarchandiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandiseInclude<ExtArgs> | null
    /**
     * Filter, which Marchandise to fetch.
     */
    where: MarchandiseWhereUniqueInput
  }

  /**
   * Marchandise findFirst
   */
  export type MarchandiseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marchandise
     */
    select?: MarchandiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marchandise
     */
    omit?: MarchandiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandiseInclude<ExtArgs> | null
    /**
     * Filter, which Marchandise to fetch.
     */
    where?: MarchandiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marchandises to fetch.
     */
    orderBy?: MarchandiseOrderByWithRelationInput | MarchandiseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Marchandises.
     */
    cursor?: MarchandiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marchandises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marchandises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Marchandises.
     */
    distinct?: MarchandiseScalarFieldEnum | MarchandiseScalarFieldEnum[]
  }

  /**
   * Marchandise findFirstOrThrow
   */
  export type MarchandiseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marchandise
     */
    select?: MarchandiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marchandise
     */
    omit?: MarchandiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandiseInclude<ExtArgs> | null
    /**
     * Filter, which Marchandise to fetch.
     */
    where?: MarchandiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marchandises to fetch.
     */
    orderBy?: MarchandiseOrderByWithRelationInput | MarchandiseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Marchandises.
     */
    cursor?: MarchandiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marchandises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marchandises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Marchandises.
     */
    distinct?: MarchandiseScalarFieldEnum | MarchandiseScalarFieldEnum[]
  }

  /**
   * Marchandise findMany
   */
  export type MarchandiseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marchandise
     */
    select?: MarchandiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marchandise
     */
    omit?: MarchandiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandiseInclude<ExtArgs> | null
    /**
     * Filter, which Marchandises to fetch.
     */
    where?: MarchandiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marchandises to fetch.
     */
    orderBy?: MarchandiseOrderByWithRelationInput | MarchandiseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Marchandises.
     */
    cursor?: MarchandiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marchandises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marchandises.
     */
    skip?: number
    distinct?: MarchandiseScalarFieldEnum | MarchandiseScalarFieldEnum[]
  }

  /**
   * Marchandise create
   */
  export type MarchandiseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marchandise
     */
    select?: MarchandiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marchandise
     */
    omit?: MarchandiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandiseInclude<ExtArgs> | null
    /**
     * The data needed to create a Marchandise.
     */
    data: XOR<MarchandiseCreateInput, MarchandiseUncheckedCreateInput>
  }

  /**
   * Marchandise createMany
   */
  export type MarchandiseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Marchandises.
     */
    data: MarchandiseCreateManyInput | MarchandiseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Marchandise createManyAndReturn
   */
  export type MarchandiseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marchandise
     */
    select?: MarchandiseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Marchandise
     */
    omit?: MarchandiseOmit<ExtArgs> | null
    /**
     * The data used to create many Marchandises.
     */
    data: MarchandiseCreateManyInput | MarchandiseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Marchandise update
   */
  export type MarchandiseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marchandise
     */
    select?: MarchandiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marchandise
     */
    omit?: MarchandiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandiseInclude<ExtArgs> | null
    /**
     * The data needed to update a Marchandise.
     */
    data: XOR<MarchandiseUpdateInput, MarchandiseUncheckedUpdateInput>
    /**
     * Choose, which Marchandise to update.
     */
    where: MarchandiseWhereUniqueInput
  }

  /**
   * Marchandise updateMany
   */
  export type MarchandiseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Marchandises.
     */
    data: XOR<MarchandiseUpdateManyMutationInput, MarchandiseUncheckedUpdateManyInput>
    /**
     * Filter which Marchandises to update
     */
    where?: MarchandiseWhereInput
    /**
     * Limit how many Marchandises to update.
     */
    limit?: number
  }

  /**
   * Marchandise updateManyAndReturn
   */
  export type MarchandiseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marchandise
     */
    select?: MarchandiseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Marchandise
     */
    omit?: MarchandiseOmit<ExtArgs> | null
    /**
     * The data used to update Marchandises.
     */
    data: XOR<MarchandiseUpdateManyMutationInput, MarchandiseUncheckedUpdateManyInput>
    /**
     * Filter which Marchandises to update
     */
    where?: MarchandiseWhereInput
    /**
     * Limit how many Marchandises to update.
     */
    limit?: number
  }

  /**
   * Marchandise upsert
   */
  export type MarchandiseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marchandise
     */
    select?: MarchandiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marchandise
     */
    omit?: MarchandiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandiseInclude<ExtArgs> | null
    /**
     * The filter to search for the Marchandise to update in case it exists.
     */
    where: MarchandiseWhereUniqueInput
    /**
     * In case the Marchandise found by the `where` argument doesn't exist, create a new Marchandise with this data.
     */
    create: XOR<MarchandiseCreateInput, MarchandiseUncheckedCreateInput>
    /**
     * In case the Marchandise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarchandiseUpdateInput, MarchandiseUncheckedUpdateInput>
  }

  /**
   * Marchandise delete
   */
  export type MarchandiseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marchandise
     */
    select?: MarchandiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marchandise
     */
    omit?: MarchandiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandiseInclude<ExtArgs> | null
    /**
     * Filter which Marchandise to delete.
     */
    where: MarchandiseWhereUniqueInput
  }

  /**
   * Marchandise deleteMany
   */
  export type MarchandiseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Marchandises to delete
     */
    where?: MarchandiseWhereInput
    /**
     * Limit how many Marchandises to delete.
     */
    limit?: number
  }

  /**
   * Marchandise.factures
   */
  export type Marchandise$facturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactureImport
     */
    select?: FactureImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactureImport
     */
    omit?: FactureImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureImportInclude<ExtArgs> | null
    where?: FactureImportWhereInput
    orderBy?: FactureImportOrderByWithRelationInput | FactureImportOrderByWithRelationInput[]
    cursor?: FactureImportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FactureImportScalarFieldEnum | FactureImportScalarFieldEnum[]
  }

  /**
   * Marchandise without action
   */
  export type MarchandiseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marchandise
     */
    select?: MarchandiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marchandise
     */
    omit?: MarchandiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarchandiseInclude<ExtArgs> | null
  }


  /**
   * Model Paiement
   */

  export type AggregatePaiement = {
    _count: PaiementCountAggregateOutputType | null
    _avg: PaiementAvgAggregateOutputType | null
    _sum: PaiementSumAggregateOutputType | null
    _min: PaiementMinAggregateOutputType | null
    _max: PaiementMaxAggregateOutputType | null
  }

  export type PaiementAvgAggregateOutputType = {
    montant: number | null
  }

  export type PaiementSumAggregateOutputType = {
    montant: number | null
  }

  export type PaiementMinAggregateOutputType = {
    id: string | null
    datePaiement: Date | null
    motif: string | null
    montant: number | null
    idClient: string | null
    archived: boolean | null
    createdAt: Date | null
    status: $Enums.StatusRow | null
    numeroInvoice: string | null
  }

  export type PaiementMaxAggregateOutputType = {
    id: string | null
    datePaiement: Date | null
    motif: string | null
    montant: number | null
    idClient: string | null
    archived: boolean | null
    createdAt: Date | null
    status: $Enums.StatusRow | null
    numeroInvoice: string | null
  }

  export type PaiementCountAggregateOutputType = {
    id: number
    datePaiement: number
    motif: number
    montant: number
    idClient: number
    archived: number
    createdAt: number
    status: number
    numeroInvoice: number
    _all: number
  }


  export type PaiementAvgAggregateInputType = {
    montant?: true
  }

  export type PaiementSumAggregateInputType = {
    montant?: true
  }

  export type PaiementMinAggregateInputType = {
    id?: true
    datePaiement?: true
    motif?: true
    montant?: true
    idClient?: true
    archived?: true
    createdAt?: true
    status?: true
    numeroInvoice?: true
  }

  export type PaiementMaxAggregateInputType = {
    id?: true
    datePaiement?: true
    motif?: true
    montant?: true
    idClient?: true
    archived?: true
    createdAt?: true
    status?: true
    numeroInvoice?: true
  }

  export type PaiementCountAggregateInputType = {
    id?: true
    datePaiement?: true
    motif?: true
    montant?: true
    idClient?: true
    archived?: true
    createdAt?: true
    status?: true
    numeroInvoice?: true
    _all?: true
  }

  export type PaiementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Paiement to aggregate.
     */
    where?: PaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paiements to fetch.
     */
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paiements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Paiements
    **/
    _count?: true | PaiementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaiementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaiementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaiementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaiementMaxAggregateInputType
  }

  export type GetPaiementAggregateType<T extends PaiementAggregateArgs> = {
        [P in keyof T & keyof AggregatePaiement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaiement[P]>
      : GetScalarType<T[P], AggregatePaiement[P]>
  }




  export type PaiementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaiementWhereInput
    orderBy?: PaiementOrderByWithAggregationInput | PaiementOrderByWithAggregationInput[]
    by: PaiementScalarFieldEnum[] | PaiementScalarFieldEnum
    having?: PaiementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaiementCountAggregateInputType | true
    _avg?: PaiementAvgAggregateInputType
    _sum?: PaiementSumAggregateInputType
    _min?: PaiementMinAggregateInputType
    _max?: PaiementMaxAggregateInputType
  }

  export type PaiementGroupByOutputType = {
    id: string
    datePaiement: Date
    motif: string | null
    montant: number
    idClient: string
    archived: boolean
    createdAt: Date
    status: $Enums.StatusRow
    numeroInvoice: string | null
    _count: PaiementCountAggregateOutputType | null
    _avg: PaiementAvgAggregateOutputType | null
    _sum: PaiementSumAggregateOutputType | null
    _min: PaiementMinAggregateOutputType | null
    _max: PaiementMaxAggregateOutputType | null
  }

  type GetPaiementGroupByPayload<T extends PaiementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaiementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaiementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaiementGroupByOutputType[P]>
            : GetScalarType<T[P], PaiementGroupByOutputType[P]>
        }
      >
    >


  export type PaiementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datePaiement?: boolean
    motif?: boolean
    montant?: boolean
    idClient?: boolean
    archived?: boolean
    createdAt?: boolean
    status?: boolean
    numeroInvoice?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paiement"]>

  export type PaiementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datePaiement?: boolean
    motif?: boolean
    montant?: boolean
    idClient?: boolean
    archived?: boolean
    createdAt?: boolean
    status?: boolean
    numeroInvoice?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paiement"]>

  export type PaiementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datePaiement?: boolean
    motif?: boolean
    montant?: boolean
    idClient?: boolean
    archived?: boolean
    createdAt?: boolean
    status?: boolean
    numeroInvoice?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paiement"]>

  export type PaiementSelectScalar = {
    id?: boolean
    datePaiement?: boolean
    motif?: boolean
    montant?: boolean
    idClient?: boolean
    archived?: boolean
    createdAt?: boolean
    status?: boolean
    numeroInvoice?: boolean
  }

  export type PaiementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "datePaiement" | "motif" | "montant" | "idClient" | "archived" | "createdAt" | "status" | "numeroInvoice", ExtArgs["result"]["paiement"]>
  export type PaiementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type PaiementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type PaiementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $PaiementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Paiement"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      datePaiement: Date
      motif: string | null
      montant: number
      idClient: string
      archived: boolean
      createdAt: Date
      status: $Enums.StatusRow
      numeroInvoice: string | null
    }, ExtArgs["result"]["paiement"]>
    composites: {}
  }

  type PaiementGetPayload<S extends boolean | null | undefined | PaiementDefaultArgs> = $Result.GetResult<Prisma.$PaiementPayload, S>

  type PaiementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaiementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaiementCountAggregateInputType | true
    }

  export interface PaiementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Paiement'], meta: { name: 'Paiement' } }
    /**
     * Find zero or one Paiement that matches the filter.
     * @param {PaiementFindUniqueArgs} args - Arguments to find a Paiement
     * @example
     * // Get one Paiement
     * const paiement = await prisma.paiement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaiementFindUniqueArgs>(args: SelectSubset<T, PaiementFindUniqueArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Paiement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaiementFindUniqueOrThrowArgs} args - Arguments to find a Paiement
     * @example
     * // Get one Paiement
     * const paiement = await prisma.paiement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaiementFindUniqueOrThrowArgs>(args: SelectSubset<T, PaiementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Paiement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementFindFirstArgs} args - Arguments to find a Paiement
     * @example
     * // Get one Paiement
     * const paiement = await prisma.paiement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaiementFindFirstArgs>(args?: SelectSubset<T, PaiementFindFirstArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Paiement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementFindFirstOrThrowArgs} args - Arguments to find a Paiement
     * @example
     * // Get one Paiement
     * const paiement = await prisma.paiement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaiementFindFirstOrThrowArgs>(args?: SelectSubset<T, PaiementFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Paiements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Paiements
     * const paiements = await prisma.paiement.findMany()
     * 
     * // Get first 10 Paiements
     * const paiements = await prisma.paiement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paiementWithIdOnly = await prisma.paiement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaiementFindManyArgs>(args?: SelectSubset<T, PaiementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Paiement.
     * @param {PaiementCreateArgs} args - Arguments to create a Paiement.
     * @example
     * // Create one Paiement
     * const Paiement = await prisma.paiement.create({
     *   data: {
     *     // ... data to create a Paiement
     *   }
     * })
     * 
     */
    create<T extends PaiementCreateArgs>(args: SelectSubset<T, PaiementCreateArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Paiements.
     * @param {PaiementCreateManyArgs} args - Arguments to create many Paiements.
     * @example
     * // Create many Paiements
     * const paiement = await prisma.paiement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaiementCreateManyArgs>(args?: SelectSubset<T, PaiementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Paiements and returns the data saved in the database.
     * @param {PaiementCreateManyAndReturnArgs} args - Arguments to create many Paiements.
     * @example
     * // Create many Paiements
     * const paiement = await prisma.paiement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Paiements and only return the `id`
     * const paiementWithIdOnly = await prisma.paiement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaiementCreateManyAndReturnArgs>(args?: SelectSubset<T, PaiementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Paiement.
     * @param {PaiementDeleteArgs} args - Arguments to delete one Paiement.
     * @example
     * // Delete one Paiement
     * const Paiement = await prisma.paiement.delete({
     *   where: {
     *     // ... filter to delete one Paiement
     *   }
     * })
     * 
     */
    delete<T extends PaiementDeleteArgs>(args: SelectSubset<T, PaiementDeleteArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Paiement.
     * @param {PaiementUpdateArgs} args - Arguments to update one Paiement.
     * @example
     * // Update one Paiement
     * const paiement = await prisma.paiement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaiementUpdateArgs>(args: SelectSubset<T, PaiementUpdateArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Paiements.
     * @param {PaiementDeleteManyArgs} args - Arguments to filter Paiements to delete.
     * @example
     * // Delete a few Paiements
     * const { count } = await prisma.paiement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaiementDeleteManyArgs>(args?: SelectSubset<T, PaiementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paiements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Paiements
     * const paiement = await prisma.paiement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaiementUpdateManyArgs>(args: SelectSubset<T, PaiementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paiements and returns the data updated in the database.
     * @param {PaiementUpdateManyAndReturnArgs} args - Arguments to update many Paiements.
     * @example
     * // Update many Paiements
     * const paiement = await prisma.paiement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Paiements and only return the `id`
     * const paiementWithIdOnly = await prisma.paiement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaiementUpdateManyAndReturnArgs>(args: SelectSubset<T, PaiementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Paiement.
     * @param {PaiementUpsertArgs} args - Arguments to update or create a Paiement.
     * @example
     * // Update or create a Paiement
     * const paiement = await prisma.paiement.upsert({
     *   create: {
     *     // ... data to create a Paiement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Paiement we want to update
     *   }
     * })
     */
    upsert<T extends PaiementUpsertArgs>(args: SelectSubset<T, PaiementUpsertArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Paiements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementCountArgs} args - Arguments to filter Paiements to count.
     * @example
     * // Count the number of Paiements
     * const count = await prisma.paiement.count({
     *   where: {
     *     // ... the filter for the Paiements we want to count
     *   }
     * })
    **/
    count<T extends PaiementCountArgs>(
      args?: Subset<T, PaiementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaiementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Paiement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaiementAggregateArgs>(args: Subset<T, PaiementAggregateArgs>): Prisma.PrismaPromise<GetPaiementAggregateType<T>>

    /**
     * Group by Paiement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaiementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaiementGroupByArgs['orderBy'] }
        : { orderBy?: PaiementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaiementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaiementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Paiement model
   */
  readonly fields: PaiementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Paiement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaiementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Paiement model
   */
  interface PaiementFieldRefs {
    readonly id: FieldRef<"Paiement", 'String'>
    readonly datePaiement: FieldRef<"Paiement", 'DateTime'>
    readonly motif: FieldRef<"Paiement", 'String'>
    readonly montant: FieldRef<"Paiement", 'Float'>
    readonly idClient: FieldRef<"Paiement", 'String'>
    readonly archived: FieldRef<"Paiement", 'Boolean'>
    readonly createdAt: FieldRef<"Paiement", 'DateTime'>
    readonly status: FieldRef<"Paiement", 'StatusRow'>
    readonly numeroInvoice: FieldRef<"Paiement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Paiement findUnique
   */
  export type PaiementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiement to fetch.
     */
    where: PaiementWhereUniqueInput
  }

  /**
   * Paiement findUniqueOrThrow
   */
  export type PaiementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiement to fetch.
     */
    where: PaiementWhereUniqueInput
  }

  /**
   * Paiement findFirst
   */
  export type PaiementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiement to fetch.
     */
    where?: PaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paiements to fetch.
     */
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Paiements.
     */
    cursor?: PaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paiements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Paiements.
     */
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Paiement findFirstOrThrow
   */
  export type PaiementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiement to fetch.
     */
    where?: PaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paiements to fetch.
     */
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Paiements.
     */
    cursor?: PaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paiements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Paiements.
     */
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Paiement findMany
   */
  export type PaiementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiements to fetch.
     */
    where?: PaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paiements to fetch.
     */
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Paiements.
     */
    cursor?: PaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paiements.
     */
    skip?: number
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Paiement create
   */
  export type PaiementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * The data needed to create a Paiement.
     */
    data: XOR<PaiementCreateInput, PaiementUncheckedCreateInput>
  }

  /**
   * Paiement createMany
   */
  export type PaiementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Paiements.
     */
    data: PaiementCreateManyInput | PaiementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Paiement createManyAndReturn
   */
  export type PaiementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * The data used to create many Paiements.
     */
    data: PaiementCreateManyInput | PaiementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Paiement update
   */
  export type PaiementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * The data needed to update a Paiement.
     */
    data: XOR<PaiementUpdateInput, PaiementUncheckedUpdateInput>
    /**
     * Choose, which Paiement to update.
     */
    where: PaiementWhereUniqueInput
  }

  /**
   * Paiement updateMany
   */
  export type PaiementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Paiements.
     */
    data: XOR<PaiementUpdateManyMutationInput, PaiementUncheckedUpdateManyInput>
    /**
     * Filter which Paiements to update
     */
    where?: PaiementWhereInput
    /**
     * Limit how many Paiements to update.
     */
    limit?: number
  }

  /**
   * Paiement updateManyAndReturn
   */
  export type PaiementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * The data used to update Paiements.
     */
    data: XOR<PaiementUpdateManyMutationInput, PaiementUncheckedUpdateManyInput>
    /**
     * Filter which Paiements to update
     */
    where?: PaiementWhereInput
    /**
     * Limit how many Paiements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Paiement upsert
   */
  export type PaiementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * The filter to search for the Paiement to update in case it exists.
     */
    where: PaiementWhereUniqueInput
    /**
     * In case the Paiement found by the `where` argument doesn't exist, create a new Paiement with this data.
     */
    create: XOR<PaiementCreateInput, PaiementUncheckedCreateInput>
    /**
     * In case the Paiement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaiementUpdateInput, PaiementUncheckedUpdateInput>
  }

  /**
   * Paiement delete
   */
  export type PaiementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter which Paiement to delete.
     */
    where: PaiementWhereUniqueInput
  }

  /**
   * Paiement deleteMany
   */
  export type PaiementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Paiements to delete
     */
    where?: PaiementWhereInput
    /**
     * Limit how many Paiements to delete.
     */
    limit?: number
  }

  /**
   * Paiement without action
   */
  export type PaiementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
  }


  /**
   * Model RubriqueFacture
   */

  export type AggregateRubriqueFacture = {
    _count: RubriqueFactureCountAggregateOutputType | null
    _min: RubriqueFactureMinAggregateOutputType | null
    _max: RubriqueFactureMaxAggregateOutputType | null
  }

  export type RubriqueFactureMinAggregateOutputType = {
    id: string | null
    produit: string | null
    libelle: string | null
    identifiant: string | null
    compte: string | null
    compteAnalytique: string | null
  }

  export type RubriqueFactureMaxAggregateOutputType = {
    id: string | null
    produit: string | null
    libelle: string | null
    identifiant: string | null
    compte: string | null
    compteAnalytique: string | null
  }

  export type RubriqueFactureCountAggregateOutputType = {
    id: number
    produit: number
    libelle: number
    identifiant: number
    compte: number
    compteAnalytique: number
    _all: number
  }


  export type RubriqueFactureMinAggregateInputType = {
    id?: true
    produit?: true
    libelle?: true
    identifiant?: true
    compte?: true
    compteAnalytique?: true
  }

  export type RubriqueFactureMaxAggregateInputType = {
    id?: true
    produit?: true
    libelle?: true
    identifiant?: true
    compte?: true
    compteAnalytique?: true
  }

  export type RubriqueFactureCountAggregateInputType = {
    id?: true
    produit?: true
    libelle?: true
    identifiant?: true
    compte?: true
    compteAnalytique?: true
    _all?: true
  }

  export type RubriqueFactureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RubriqueFacture to aggregate.
     */
    where?: RubriqueFactureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RubriqueFactures to fetch.
     */
    orderBy?: RubriqueFactureOrderByWithRelationInput | RubriqueFactureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RubriqueFactureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RubriqueFactures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RubriqueFactures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RubriqueFactures
    **/
    _count?: true | RubriqueFactureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RubriqueFactureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RubriqueFactureMaxAggregateInputType
  }

  export type GetRubriqueFactureAggregateType<T extends RubriqueFactureAggregateArgs> = {
        [P in keyof T & keyof AggregateRubriqueFacture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRubriqueFacture[P]>
      : GetScalarType<T[P], AggregateRubriqueFacture[P]>
  }




  export type RubriqueFactureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RubriqueFactureWhereInput
    orderBy?: RubriqueFactureOrderByWithAggregationInput | RubriqueFactureOrderByWithAggregationInput[]
    by: RubriqueFactureScalarFieldEnum[] | RubriqueFactureScalarFieldEnum
    having?: RubriqueFactureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RubriqueFactureCountAggregateInputType | true
    _min?: RubriqueFactureMinAggregateInputType
    _max?: RubriqueFactureMaxAggregateInputType
  }

  export type RubriqueFactureGroupByOutputType = {
    id: string
    produit: string | null
    libelle: string | null
    identifiant: string
    compte: string | null
    compteAnalytique: string | null
    _count: RubriqueFactureCountAggregateOutputType | null
    _min: RubriqueFactureMinAggregateOutputType | null
    _max: RubriqueFactureMaxAggregateOutputType | null
  }

  type GetRubriqueFactureGroupByPayload<T extends RubriqueFactureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RubriqueFactureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RubriqueFactureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RubriqueFactureGroupByOutputType[P]>
            : GetScalarType<T[P], RubriqueFactureGroupByOutputType[P]>
        }
      >
    >


  export type RubriqueFactureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    produit?: boolean
    libelle?: boolean
    identifiant?: boolean
    compte?: boolean
    compteAnalytique?: boolean
    detailFacture?: boolean | RubriqueFacture$detailFactureArgs<ExtArgs>
    _count?: boolean | RubriqueFactureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rubriqueFacture"]>

  export type RubriqueFactureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    produit?: boolean
    libelle?: boolean
    identifiant?: boolean
    compte?: boolean
    compteAnalytique?: boolean
  }, ExtArgs["result"]["rubriqueFacture"]>

  export type RubriqueFactureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    produit?: boolean
    libelle?: boolean
    identifiant?: boolean
    compte?: boolean
    compteAnalytique?: boolean
  }, ExtArgs["result"]["rubriqueFacture"]>

  export type RubriqueFactureSelectScalar = {
    id?: boolean
    produit?: boolean
    libelle?: boolean
    identifiant?: boolean
    compte?: boolean
    compteAnalytique?: boolean
  }

  export type RubriqueFactureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "produit" | "libelle" | "identifiant" | "compte" | "compteAnalytique", ExtArgs["result"]["rubriqueFacture"]>
  export type RubriqueFactureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detailFacture?: boolean | RubriqueFacture$detailFactureArgs<ExtArgs>
    _count?: boolean | RubriqueFactureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RubriqueFactureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RubriqueFactureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RubriqueFacturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RubriqueFacture"
    objects: {
      detailFacture: Prisma.$DetailFacturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      produit: string | null
      libelle: string | null
      identifiant: string
      compte: string | null
      compteAnalytique: string | null
    }, ExtArgs["result"]["rubriqueFacture"]>
    composites: {}
  }

  type RubriqueFactureGetPayload<S extends boolean | null | undefined | RubriqueFactureDefaultArgs> = $Result.GetResult<Prisma.$RubriqueFacturePayload, S>

  type RubriqueFactureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RubriqueFactureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RubriqueFactureCountAggregateInputType | true
    }

  export interface RubriqueFactureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RubriqueFacture'], meta: { name: 'RubriqueFacture' } }
    /**
     * Find zero or one RubriqueFacture that matches the filter.
     * @param {RubriqueFactureFindUniqueArgs} args - Arguments to find a RubriqueFacture
     * @example
     * // Get one RubriqueFacture
     * const rubriqueFacture = await prisma.rubriqueFacture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RubriqueFactureFindUniqueArgs>(args: SelectSubset<T, RubriqueFactureFindUniqueArgs<ExtArgs>>): Prisma__RubriqueFactureClient<$Result.GetResult<Prisma.$RubriqueFacturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RubriqueFacture that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RubriqueFactureFindUniqueOrThrowArgs} args - Arguments to find a RubriqueFacture
     * @example
     * // Get one RubriqueFacture
     * const rubriqueFacture = await prisma.rubriqueFacture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RubriqueFactureFindUniqueOrThrowArgs>(args: SelectSubset<T, RubriqueFactureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RubriqueFactureClient<$Result.GetResult<Prisma.$RubriqueFacturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RubriqueFacture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RubriqueFactureFindFirstArgs} args - Arguments to find a RubriqueFacture
     * @example
     * // Get one RubriqueFacture
     * const rubriqueFacture = await prisma.rubriqueFacture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RubriqueFactureFindFirstArgs>(args?: SelectSubset<T, RubriqueFactureFindFirstArgs<ExtArgs>>): Prisma__RubriqueFactureClient<$Result.GetResult<Prisma.$RubriqueFacturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RubriqueFacture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RubriqueFactureFindFirstOrThrowArgs} args - Arguments to find a RubriqueFacture
     * @example
     * // Get one RubriqueFacture
     * const rubriqueFacture = await prisma.rubriqueFacture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RubriqueFactureFindFirstOrThrowArgs>(args?: SelectSubset<T, RubriqueFactureFindFirstOrThrowArgs<ExtArgs>>): Prisma__RubriqueFactureClient<$Result.GetResult<Prisma.$RubriqueFacturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RubriqueFactures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RubriqueFactureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RubriqueFactures
     * const rubriqueFactures = await prisma.rubriqueFacture.findMany()
     * 
     * // Get first 10 RubriqueFactures
     * const rubriqueFactures = await prisma.rubriqueFacture.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rubriqueFactureWithIdOnly = await prisma.rubriqueFacture.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RubriqueFactureFindManyArgs>(args?: SelectSubset<T, RubriqueFactureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RubriqueFacturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RubriqueFacture.
     * @param {RubriqueFactureCreateArgs} args - Arguments to create a RubriqueFacture.
     * @example
     * // Create one RubriqueFacture
     * const RubriqueFacture = await prisma.rubriqueFacture.create({
     *   data: {
     *     // ... data to create a RubriqueFacture
     *   }
     * })
     * 
     */
    create<T extends RubriqueFactureCreateArgs>(args: SelectSubset<T, RubriqueFactureCreateArgs<ExtArgs>>): Prisma__RubriqueFactureClient<$Result.GetResult<Prisma.$RubriqueFacturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RubriqueFactures.
     * @param {RubriqueFactureCreateManyArgs} args - Arguments to create many RubriqueFactures.
     * @example
     * // Create many RubriqueFactures
     * const rubriqueFacture = await prisma.rubriqueFacture.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RubriqueFactureCreateManyArgs>(args?: SelectSubset<T, RubriqueFactureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RubriqueFactures and returns the data saved in the database.
     * @param {RubriqueFactureCreateManyAndReturnArgs} args - Arguments to create many RubriqueFactures.
     * @example
     * // Create many RubriqueFactures
     * const rubriqueFacture = await prisma.rubriqueFacture.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RubriqueFactures and only return the `id`
     * const rubriqueFactureWithIdOnly = await prisma.rubriqueFacture.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RubriqueFactureCreateManyAndReturnArgs>(args?: SelectSubset<T, RubriqueFactureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RubriqueFacturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RubriqueFacture.
     * @param {RubriqueFactureDeleteArgs} args - Arguments to delete one RubriqueFacture.
     * @example
     * // Delete one RubriqueFacture
     * const RubriqueFacture = await prisma.rubriqueFacture.delete({
     *   where: {
     *     // ... filter to delete one RubriqueFacture
     *   }
     * })
     * 
     */
    delete<T extends RubriqueFactureDeleteArgs>(args: SelectSubset<T, RubriqueFactureDeleteArgs<ExtArgs>>): Prisma__RubriqueFactureClient<$Result.GetResult<Prisma.$RubriqueFacturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RubriqueFacture.
     * @param {RubriqueFactureUpdateArgs} args - Arguments to update one RubriqueFacture.
     * @example
     * // Update one RubriqueFacture
     * const rubriqueFacture = await prisma.rubriqueFacture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RubriqueFactureUpdateArgs>(args: SelectSubset<T, RubriqueFactureUpdateArgs<ExtArgs>>): Prisma__RubriqueFactureClient<$Result.GetResult<Prisma.$RubriqueFacturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RubriqueFactures.
     * @param {RubriqueFactureDeleteManyArgs} args - Arguments to filter RubriqueFactures to delete.
     * @example
     * // Delete a few RubriqueFactures
     * const { count } = await prisma.rubriqueFacture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RubriqueFactureDeleteManyArgs>(args?: SelectSubset<T, RubriqueFactureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RubriqueFactures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RubriqueFactureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RubriqueFactures
     * const rubriqueFacture = await prisma.rubriqueFacture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RubriqueFactureUpdateManyArgs>(args: SelectSubset<T, RubriqueFactureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RubriqueFactures and returns the data updated in the database.
     * @param {RubriqueFactureUpdateManyAndReturnArgs} args - Arguments to update many RubriqueFactures.
     * @example
     * // Update many RubriqueFactures
     * const rubriqueFacture = await prisma.rubriqueFacture.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RubriqueFactures and only return the `id`
     * const rubriqueFactureWithIdOnly = await prisma.rubriqueFacture.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RubriqueFactureUpdateManyAndReturnArgs>(args: SelectSubset<T, RubriqueFactureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RubriqueFacturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RubriqueFacture.
     * @param {RubriqueFactureUpsertArgs} args - Arguments to update or create a RubriqueFacture.
     * @example
     * // Update or create a RubriqueFacture
     * const rubriqueFacture = await prisma.rubriqueFacture.upsert({
     *   create: {
     *     // ... data to create a RubriqueFacture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RubriqueFacture we want to update
     *   }
     * })
     */
    upsert<T extends RubriqueFactureUpsertArgs>(args: SelectSubset<T, RubriqueFactureUpsertArgs<ExtArgs>>): Prisma__RubriqueFactureClient<$Result.GetResult<Prisma.$RubriqueFacturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RubriqueFactures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RubriqueFactureCountArgs} args - Arguments to filter RubriqueFactures to count.
     * @example
     * // Count the number of RubriqueFactures
     * const count = await prisma.rubriqueFacture.count({
     *   where: {
     *     // ... the filter for the RubriqueFactures we want to count
     *   }
     * })
    **/
    count<T extends RubriqueFactureCountArgs>(
      args?: Subset<T, RubriqueFactureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RubriqueFactureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RubriqueFacture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RubriqueFactureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RubriqueFactureAggregateArgs>(args: Subset<T, RubriqueFactureAggregateArgs>): Prisma.PrismaPromise<GetRubriqueFactureAggregateType<T>>

    /**
     * Group by RubriqueFacture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RubriqueFactureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RubriqueFactureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RubriqueFactureGroupByArgs['orderBy'] }
        : { orderBy?: RubriqueFactureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RubriqueFactureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRubriqueFactureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RubriqueFacture model
   */
  readonly fields: RubriqueFactureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RubriqueFacture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RubriqueFactureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    detailFacture<T extends RubriqueFacture$detailFactureArgs<ExtArgs> = {}>(args?: Subset<T, RubriqueFacture$detailFactureArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetailFacturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RubriqueFacture model
   */
  interface RubriqueFactureFieldRefs {
    readonly id: FieldRef<"RubriqueFacture", 'String'>
    readonly produit: FieldRef<"RubriqueFacture", 'String'>
    readonly libelle: FieldRef<"RubriqueFacture", 'String'>
    readonly identifiant: FieldRef<"RubriqueFacture", 'String'>
    readonly compte: FieldRef<"RubriqueFacture", 'String'>
    readonly compteAnalytique: FieldRef<"RubriqueFacture", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RubriqueFacture findUnique
   */
  export type RubriqueFactureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RubriqueFacture
     */
    select?: RubriqueFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RubriqueFacture
     */
    omit?: RubriqueFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubriqueFactureInclude<ExtArgs> | null
    /**
     * Filter, which RubriqueFacture to fetch.
     */
    where: RubriqueFactureWhereUniqueInput
  }

  /**
   * RubriqueFacture findUniqueOrThrow
   */
  export type RubriqueFactureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RubriqueFacture
     */
    select?: RubriqueFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RubriqueFacture
     */
    omit?: RubriqueFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubriqueFactureInclude<ExtArgs> | null
    /**
     * Filter, which RubriqueFacture to fetch.
     */
    where: RubriqueFactureWhereUniqueInput
  }

  /**
   * RubriqueFacture findFirst
   */
  export type RubriqueFactureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RubriqueFacture
     */
    select?: RubriqueFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RubriqueFacture
     */
    omit?: RubriqueFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubriqueFactureInclude<ExtArgs> | null
    /**
     * Filter, which RubriqueFacture to fetch.
     */
    where?: RubriqueFactureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RubriqueFactures to fetch.
     */
    orderBy?: RubriqueFactureOrderByWithRelationInput | RubriqueFactureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RubriqueFactures.
     */
    cursor?: RubriqueFactureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RubriqueFactures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RubriqueFactures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RubriqueFactures.
     */
    distinct?: RubriqueFactureScalarFieldEnum | RubriqueFactureScalarFieldEnum[]
  }

  /**
   * RubriqueFacture findFirstOrThrow
   */
  export type RubriqueFactureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RubriqueFacture
     */
    select?: RubriqueFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RubriqueFacture
     */
    omit?: RubriqueFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubriqueFactureInclude<ExtArgs> | null
    /**
     * Filter, which RubriqueFacture to fetch.
     */
    where?: RubriqueFactureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RubriqueFactures to fetch.
     */
    orderBy?: RubriqueFactureOrderByWithRelationInput | RubriqueFactureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RubriqueFactures.
     */
    cursor?: RubriqueFactureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RubriqueFactures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RubriqueFactures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RubriqueFactures.
     */
    distinct?: RubriqueFactureScalarFieldEnum | RubriqueFactureScalarFieldEnum[]
  }

  /**
   * RubriqueFacture findMany
   */
  export type RubriqueFactureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RubriqueFacture
     */
    select?: RubriqueFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RubriqueFacture
     */
    omit?: RubriqueFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubriqueFactureInclude<ExtArgs> | null
    /**
     * Filter, which RubriqueFactures to fetch.
     */
    where?: RubriqueFactureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RubriqueFactures to fetch.
     */
    orderBy?: RubriqueFactureOrderByWithRelationInput | RubriqueFactureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RubriqueFactures.
     */
    cursor?: RubriqueFactureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RubriqueFactures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RubriqueFactures.
     */
    skip?: number
    distinct?: RubriqueFactureScalarFieldEnum | RubriqueFactureScalarFieldEnum[]
  }

  /**
   * RubriqueFacture create
   */
  export type RubriqueFactureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RubriqueFacture
     */
    select?: RubriqueFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RubriqueFacture
     */
    omit?: RubriqueFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubriqueFactureInclude<ExtArgs> | null
    /**
     * The data needed to create a RubriqueFacture.
     */
    data: XOR<RubriqueFactureCreateInput, RubriqueFactureUncheckedCreateInput>
  }

  /**
   * RubriqueFacture createMany
   */
  export type RubriqueFactureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RubriqueFactures.
     */
    data: RubriqueFactureCreateManyInput | RubriqueFactureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RubriqueFacture createManyAndReturn
   */
  export type RubriqueFactureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RubriqueFacture
     */
    select?: RubriqueFactureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RubriqueFacture
     */
    omit?: RubriqueFactureOmit<ExtArgs> | null
    /**
     * The data used to create many RubriqueFactures.
     */
    data: RubriqueFactureCreateManyInput | RubriqueFactureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RubriqueFacture update
   */
  export type RubriqueFactureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RubriqueFacture
     */
    select?: RubriqueFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RubriqueFacture
     */
    omit?: RubriqueFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubriqueFactureInclude<ExtArgs> | null
    /**
     * The data needed to update a RubriqueFacture.
     */
    data: XOR<RubriqueFactureUpdateInput, RubriqueFactureUncheckedUpdateInput>
    /**
     * Choose, which RubriqueFacture to update.
     */
    where: RubriqueFactureWhereUniqueInput
  }

  /**
   * RubriqueFacture updateMany
   */
  export type RubriqueFactureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RubriqueFactures.
     */
    data: XOR<RubriqueFactureUpdateManyMutationInput, RubriqueFactureUncheckedUpdateManyInput>
    /**
     * Filter which RubriqueFactures to update
     */
    where?: RubriqueFactureWhereInput
    /**
     * Limit how many RubriqueFactures to update.
     */
    limit?: number
  }

  /**
   * RubriqueFacture updateManyAndReturn
   */
  export type RubriqueFactureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RubriqueFacture
     */
    select?: RubriqueFactureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RubriqueFacture
     */
    omit?: RubriqueFactureOmit<ExtArgs> | null
    /**
     * The data used to update RubriqueFactures.
     */
    data: XOR<RubriqueFactureUpdateManyMutationInput, RubriqueFactureUncheckedUpdateManyInput>
    /**
     * Filter which RubriqueFactures to update
     */
    where?: RubriqueFactureWhereInput
    /**
     * Limit how many RubriqueFactures to update.
     */
    limit?: number
  }

  /**
   * RubriqueFacture upsert
   */
  export type RubriqueFactureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RubriqueFacture
     */
    select?: RubriqueFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RubriqueFacture
     */
    omit?: RubriqueFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubriqueFactureInclude<ExtArgs> | null
    /**
     * The filter to search for the RubriqueFacture to update in case it exists.
     */
    where: RubriqueFactureWhereUniqueInput
    /**
     * In case the RubriqueFacture found by the `where` argument doesn't exist, create a new RubriqueFacture with this data.
     */
    create: XOR<RubriqueFactureCreateInput, RubriqueFactureUncheckedCreateInput>
    /**
     * In case the RubriqueFacture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RubriqueFactureUpdateInput, RubriqueFactureUncheckedUpdateInput>
  }

  /**
   * RubriqueFacture delete
   */
  export type RubriqueFactureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RubriqueFacture
     */
    select?: RubriqueFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RubriqueFacture
     */
    omit?: RubriqueFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubriqueFactureInclude<ExtArgs> | null
    /**
     * Filter which RubriqueFacture to delete.
     */
    where: RubriqueFactureWhereUniqueInput
  }

  /**
   * RubriqueFacture deleteMany
   */
  export type RubriqueFactureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RubriqueFactures to delete
     */
    where?: RubriqueFactureWhereInput
    /**
     * Limit how many RubriqueFactures to delete.
     */
    limit?: number
  }

  /**
   * RubriqueFacture.detailFacture
   */
  export type RubriqueFacture$detailFactureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailFacture
     */
    select?: DetailFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailFacture
     */
    omit?: DetailFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailFactureInclude<ExtArgs> | null
    where?: DetailFactureWhereInput
    orderBy?: DetailFactureOrderByWithRelationInput | DetailFactureOrderByWithRelationInput[]
    cursor?: DetailFactureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetailFactureScalarFieldEnum | DetailFactureScalarFieldEnum[]
  }

  /**
   * RubriqueFacture without action
   */
  export type RubriqueFactureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RubriqueFacture
     */
    select?: RubriqueFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RubriqueFacture
     */
    omit?: RubriqueFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RubriqueFactureInclude<ExtArgs> | null
  }


  /**
   * Model Utilisateur
   */

  export type AggregateUtilisateur = {
    _count: UtilisateurCountAggregateOutputType | null
    _min: UtilisateurMinAggregateOutputType | null
    _max: UtilisateurMaxAggregateOutputType | null
  }

  export type UtilisateurMinAggregateOutputType = {
    id: string | null
    name: string | null
    login: string | null
    role: string | null
    password: string | null
    status: $Enums.StatusRow | null
  }

  export type UtilisateurMaxAggregateOutputType = {
    id: string | null
    name: string | null
    login: string | null
    role: string | null
    password: string | null
    status: $Enums.StatusRow | null
  }

  export type UtilisateurCountAggregateOutputType = {
    id: number
    name: number
    login: number
    role: number
    password: number
    status: number
    _all: number
  }


  export type UtilisateurMinAggregateInputType = {
    id?: true
    name?: true
    login?: true
    role?: true
    password?: true
    status?: true
  }

  export type UtilisateurMaxAggregateInputType = {
    id?: true
    name?: true
    login?: true
    role?: true
    password?: true
    status?: true
  }

  export type UtilisateurCountAggregateInputType = {
    id?: true
    name?: true
    login?: true
    role?: true
    password?: true
    status?: true
    _all?: true
  }

  export type UtilisateurAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Utilisateur to aggregate.
     */
    where?: UtilisateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Utilisateurs to fetch.
     */
    orderBy?: UtilisateurOrderByWithRelationInput | UtilisateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UtilisateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Utilisateurs
    **/
    _count?: true | UtilisateurCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UtilisateurMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UtilisateurMaxAggregateInputType
  }

  export type GetUtilisateurAggregateType<T extends UtilisateurAggregateArgs> = {
        [P in keyof T & keyof AggregateUtilisateur]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUtilisateur[P]>
      : GetScalarType<T[P], AggregateUtilisateur[P]>
  }




  export type UtilisateurGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UtilisateurWhereInput
    orderBy?: UtilisateurOrderByWithAggregationInput | UtilisateurOrderByWithAggregationInput[]
    by: UtilisateurScalarFieldEnum[] | UtilisateurScalarFieldEnum
    having?: UtilisateurScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UtilisateurCountAggregateInputType | true
    _min?: UtilisateurMinAggregateInputType
    _max?: UtilisateurMaxAggregateInputType
  }

  export type UtilisateurGroupByOutputType = {
    id: string
    name: string | null
    login: string
    role: string
    password: string | null
    status: $Enums.StatusRow
    _count: UtilisateurCountAggregateOutputType | null
    _min: UtilisateurMinAggregateOutputType | null
    _max: UtilisateurMaxAggregateOutputType | null
  }

  type GetUtilisateurGroupByPayload<T extends UtilisateurGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UtilisateurGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UtilisateurGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UtilisateurGroupByOutputType[P]>
            : GetScalarType<T[P], UtilisateurGroupByOutputType[P]>
        }
      >
    >


  export type UtilisateurSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    login?: boolean
    role?: boolean
    password?: boolean
    status?: boolean
  }, ExtArgs["result"]["utilisateur"]>

  export type UtilisateurSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    login?: boolean
    role?: boolean
    password?: boolean
    status?: boolean
  }, ExtArgs["result"]["utilisateur"]>

  export type UtilisateurSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    login?: boolean
    role?: boolean
    password?: boolean
    status?: boolean
  }, ExtArgs["result"]["utilisateur"]>

  export type UtilisateurSelectScalar = {
    id?: boolean
    name?: boolean
    login?: boolean
    role?: boolean
    password?: boolean
    status?: boolean
  }

  export type UtilisateurOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "login" | "role" | "password" | "status", ExtArgs["result"]["utilisateur"]>

  export type $UtilisateurPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Utilisateur"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      login: string
      role: string
      password: string | null
      status: $Enums.StatusRow
    }, ExtArgs["result"]["utilisateur"]>
    composites: {}
  }

  type UtilisateurGetPayload<S extends boolean | null | undefined | UtilisateurDefaultArgs> = $Result.GetResult<Prisma.$UtilisateurPayload, S>

  type UtilisateurCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UtilisateurFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UtilisateurCountAggregateInputType | true
    }

  export interface UtilisateurDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Utilisateur'], meta: { name: 'Utilisateur' } }
    /**
     * Find zero or one Utilisateur that matches the filter.
     * @param {UtilisateurFindUniqueArgs} args - Arguments to find a Utilisateur
     * @example
     * // Get one Utilisateur
     * const utilisateur = await prisma.utilisateur.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UtilisateurFindUniqueArgs>(args: SelectSubset<T, UtilisateurFindUniqueArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Utilisateur that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UtilisateurFindUniqueOrThrowArgs} args - Arguments to find a Utilisateur
     * @example
     * // Get one Utilisateur
     * const utilisateur = await prisma.utilisateur.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UtilisateurFindUniqueOrThrowArgs>(args: SelectSubset<T, UtilisateurFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Utilisateur that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurFindFirstArgs} args - Arguments to find a Utilisateur
     * @example
     * // Get one Utilisateur
     * const utilisateur = await prisma.utilisateur.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UtilisateurFindFirstArgs>(args?: SelectSubset<T, UtilisateurFindFirstArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Utilisateur that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurFindFirstOrThrowArgs} args - Arguments to find a Utilisateur
     * @example
     * // Get one Utilisateur
     * const utilisateur = await prisma.utilisateur.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UtilisateurFindFirstOrThrowArgs>(args?: SelectSubset<T, UtilisateurFindFirstOrThrowArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Utilisateurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Utilisateurs
     * const utilisateurs = await prisma.utilisateur.findMany()
     * 
     * // Get first 10 Utilisateurs
     * const utilisateurs = await prisma.utilisateur.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const utilisateurWithIdOnly = await prisma.utilisateur.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UtilisateurFindManyArgs>(args?: SelectSubset<T, UtilisateurFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Utilisateur.
     * @param {UtilisateurCreateArgs} args - Arguments to create a Utilisateur.
     * @example
     * // Create one Utilisateur
     * const Utilisateur = await prisma.utilisateur.create({
     *   data: {
     *     // ... data to create a Utilisateur
     *   }
     * })
     * 
     */
    create<T extends UtilisateurCreateArgs>(args: SelectSubset<T, UtilisateurCreateArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Utilisateurs.
     * @param {UtilisateurCreateManyArgs} args - Arguments to create many Utilisateurs.
     * @example
     * // Create many Utilisateurs
     * const utilisateur = await prisma.utilisateur.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UtilisateurCreateManyArgs>(args?: SelectSubset<T, UtilisateurCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Utilisateurs and returns the data saved in the database.
     * @param {UtilisateurCreateManyAndReturnArgs} args - Arguments to create many Utilisateurs.
     * @example
     * // Create many Utilisateurs
     * const utilisateur = await prisma.utilisateur.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Utilisateurs and only return the `id`
     * const utilisateurWithIdOnly = await prisma.utilisateur.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UtilisateurCreateManyAndReturnArgs>(args?: SelectSubset<T, UtilisateurCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Utilisateur.
     * @param {UtilisateurDeleteArgs} args - Arguments to delete one Utilisateur.
     * @example
     * // Delete one Utilisateur
     * const Utilisateur = await prisma.utilisateur.delete({
     *   where: {
     *     // ... filter to delete one Utilisateur
     *   }
     * })
     * 
     */
    delete<T extends UtilisateurDeleteArgs>(args: SelectSubset<T, UtilisateurDeleteArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Utilisateur.
     * @param {UtilisateurUpdateArgs} args - Arguments to update one Utilisateur.
     * @example
     * // Update one Utilisateur
     * const utilisateur = await prisma.utilisateur.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UtilisateurUpdateArgs>(args: SelectSubset<T, UtilisateurUpdateArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Utilisateurs.
     * @param {UtilisateurDeleteManyArgs} args - Arguments to filter Utilisateurs to delete.
     * @example
     * // Delete a few Utilisateurs
     * const { count } = await prisma.utilisateur.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UtilisateurDeleteManyArgs>(args?: SelectSubset<T, UtilisateurDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Utilisateurs
     * const utilisateur = await prisma.utilisateur.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UtilisateurUpdateManyArgs>(args: SelectSubset<T, UtilisateurUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Utilisateurs and returns the data updated in the database.
     * @param {UtilisateurUpdateManyAndReturnArgs} args - Arguments to update many Utilisateurs.
     * @example
     * // Update many Utilisateurs
     * const utilisateur = await prisma.utilisateur.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Utilisateurs and only return the `id`
     * const utilisateurWithIdOnly = await prisma.utilisateur.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UtilisateurUpdateManyAndReturnArgs>(args: SelectSubset<T, UtilisateurUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Utilisateur.
     * @param {UtilisateurUpsertArgs} args - Arguments to update or create a Utilisateur.
     * @example
     * // Update or create a Utilisateur
     * const utilisateur = await prisma.utilisateur.upsert({
     *   create: {
     *     // ... data to create a Utilisateur
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Utilisateur we want to update
     *   }
     * })
     */
    upsert<T extends UtilisateurUpsertArgs>(args: SelectSubset<T, UtilisateurUpsertArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurCountArgs} args - Arguments to filter Utilisateurs to count.
     * @example
     * // Count the number of Utilisateurs
     * const count = await prisma.utilisateur.count({
     *   where: {
     *     // ... the filter for the Utilisateurs we want to count
     *   }
     * })
    **/
    count<T extends UtilisateurCountArgs>(
      args?: Subset<T, UtilisateurCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UtilisateurCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Utilisateur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UtilisateurAggregateArgs>(args: Subset<T, UtilisateurAggregateArgs>): Prisma.PrismaPromise<GetUtilisateurAggregateType<T>>

    /**
     * Group by Utilisateur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UtilisateurGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UtilisateurGroupByArgs['orderBy'] }
        : { orderBy?: UtilisateurGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UtilisateurGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUtilisateurGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Utilisateur model
   */
  readonly fields: UtilisateurFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Utilisateur.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UtilisateurClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Utilisateur model
   */
  interface UtilisateurFieldRefs {
    readonly id: FieldRef<"Utilisateur", 'String'>
    readonly name: FieldRef<"Utilisateur", 'String'>
    readonly login: FieldRef<"Utilisateur", 'String'>
    readonly role: FieldRef<"Utilisateur", 'String'>
    readonly password: FieldRef<"Utilisateur", 'String'>
    readonly status: FieldRef<"Utilisateur", 'StatusRow'>
  }
    

  // Custom InputTypes
  /**
   * Utilisateur findUnique
   */
  export type UtilisateurFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Filter, which Utilisateur to fetch.
     */
    where: UtilisateurWhereUniqueInput
  }

  /**
   * Utilisateur findUniqueOrThrow
   */
  export type UtilisateurFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Filter, which Utilisateur to fetch.
     */
    where: UtilisateurWhereUniqueInput
  }

  /**
   * Utilisateur findFirst
   */
  export type UtilisateurFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Filter, which Utilisateur to fetch.
     */
    where?: UtilisateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Utilisateurs to fetch.
     */
    orderBy?: UtilisateurOrderByWithRelationInput | UtilisateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Utilisateurs.
     */
    cursor?: UtilisateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Utilisateurs.
     */
    distinct?: UtilisateurScalarFieldEnum | UtilisateurScalarFieldEnum[]
  }

  /**
   * Utilisateur findFirstOrThrow
   */
  export type UtilisateurFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Filter, which Utilisateur to fetch.
     */
    where?: UtilisateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Utilisateurs to fetch.
     */
    orderBy?: UtilisateurOrderByWithRelationInput | UtilisateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Utilisateurs.
     */
    cursor?: UtilisateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Utilisateurs.
     */
    distinct?: UtilisateurScalarFieldEnum | UtilisateurScalarFieldEnum[]
  }

  /**
   * Utilisateur findMany
   */
  export type UtilisateurFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Filter, which Utilisateurs to fetch.
     */
    where?: UtilisateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Utilisateurs to fetch.
     */
    orderBy?: UtilisateurOrderByWithRelationInput | UtilisateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Utilisateurs.
     */
    cursor?: UtilisateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Utilisateurs.
     */
    skip?: number
    distinct?: UtilisateurScalarFieldEnum | UtilisateurScalarFieldEnum[]
  }

  /**
   * Utilisateur create
   */
  export type UtilisateurCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * The data needed to create a Utilisateur.
     */
    data: XOR<UtilisateurCreateInput, UtilisateurUncheckedCreateInput>
  }

  /**
   * Utilisateur createMany
   */
  export type UtilisateurCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Utilisateurs.
     */
    data: UtilisateurCreateManyInput | UtilisateurCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Utilisateur createManyAndReturn
   */
  export type UtilisateurCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * The data used to create many Utilisateurs.
     */
    data: UtilisateurCreateManyInput | UtilisateurCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Utilisateur update
   */
  export type UtilisateurUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * The data needed to update a Utilisateur.
     */
    data: XOR<UtilisateurUpdateInput, UtilisateurUncheckedUpdateInput>
    /**
     * Choose, which Utilisateur to update.
     */
    where: UtilisateurWhereUniqueInput
  }

  /**
   * Utilisateur updateMany
   */
  export type UtilisateurUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Utilisateurs.
     */
    data: XOR<UtilisateurUpdateManyMutationInput, UtilisateurUncheckedUpdateManyInput>
    /**
     * Filter which Utilisateurs to update
     */
    where?: UtilisateurWhereInput
    /**
     * Limit how many Utilisateurs to update.
     */
    limit?: number
  }

  /**
   * Utilisateur updateManyAndReturn
   */
  export type UtilisateurUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * The data used to update Utilisateurs.
     */
    data: XOR<UtilisateurUpdateManyMutationInput, UtilisateurUncheckedUpdateManyInput>
    /**
     * Filter which Utilisateurs to update
     */
    where?: UtilisateurWhereInput
    /**
     * Limit how many Utilisateurs to update.
     */
    limit?: number
  }

  /**
   * Utilisateur upsert
   */
  export type UtilisateurUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * The filter to search for the Utilisateur to update in case it exists.
     */
    where: UtilisateurWhereUniqueInput
    /**
     * In case the Utilisateur found by the `where` argument doesn't exist, create a new Utilisateur with this data.
     */
    create: XOR<UtilisateurCreateInput, UtilisateurUncheckedCreateInput>
    /**
     * In case the Utilisateur was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UtilisateurUpdateInput, UtilisateurUncheckedUpdateInput>
  }

  /**
   * Utilisateur delete
   */
  export type UtilisateurDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Filter which Utilisateur to delete.
     */
    where: UtilisateurWhereUniqueInput
  }

  /**
   * Utilisateur deleteMany
   */
  export type UtilisateurDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Utilisateurs to delete
     */
    where?: UtilisateurWhereInput
    /**
     * Limit how many Utilisateurs to delete.
     */
    limit?: number
  }

  /**
   * Utilisateur without action
   */
  export type UtilisateurDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CamionScalarFieldEnum: {
    id: 'id',
    libelle: 'libelle'
  };

  export type CamionScalarFieldEnum = (typeof CamionScalarFieldEnum)[keyof typeof CamionScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    nom_client: 'nom_client',
    code: 'code',
    num_nif: 'num_nif',
    adresse: 'adresse',
    telephone: 'telephone',
    email: 'email',
    rccm: 'rccm',
    idNat: 'idNat',
    isFacturedForImport: 'isFacturedForImport',
    isFacturedForExport: 'isFacturedForExport',
    isFacturedForTva: 'isFacturedForTva',
    lastPrintedDeclation: 'lastPrintedDeclation',
    enabled: 'enabled'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const DetailFactureScalarFieldEnum: {
    id: 'id',
    factureId: 'factureId',
    rubriqueFactureId: 'rubriqueFactureId',
    qte: 'qte',
    prix: 'prix'
  };

  export type DetailFactureScalarFieldEnum = (typeof DetailFactureScalarFieldEnum)[keyof typeof DetailFactureScalarFieldEnum]


  export const FactureImportScalarFieldEnum: {
    id: 'id',
    dossier: 'dossier',
    dateFacture: 'dateFacture',
    journalTypeId: 'journalTypeId',
    manifeste: 'manifeste',
    t1: 't1',
    camionId: 'camionId',
    marchandiseId: 'marchandiseId',
    declarationId: 'declarationId',
    declarationDate: 'declarationDate',
    liquidationId: 'liquidationId',
    liquidationDate: 'liquidationDate',
    quittanceId: 'quittanceId',
    quittanceDate: 'quittanceDate',
    quittanceMontant: 'quittanceMontant',
    poids: 'poids',
    colis: 'colis',
    status: 'status',
    createdAt: 'createdAt',
    montant: 'montant',
    typeFact: 'typeFact',
    niveauSaisie: 'niveauSaisie',
    numeroFacture: 'numeroFacture'
  };

  export type FactureImportScalarFieldEnum = (typeof FactureImportScalarFieldEnum)[keyof typeof FactureImportScalarFieldEnum]


  export const JournalScalarFieldEnum: {
    id: 'id',
    journalTypeId: 'journalTypeId',
    numero: 'numero'
  };

  export type JournalScalarFieldEnum = (typeof JournalScalarFieldEnum)[keyof typeof JournalScalarFieldEnum]


  export const JournalTypeScalarFieldEnum: {
    id: 'id',
    libelle: 'libelle',
    formatJournal: 'formatJournal',
    ClientId: 'ClientId',
    derniereImpression: 'derniereImpression',
    solde: 'solde'
  };

  export type JournalTypeScalarFieldEnum = (typeof JournalTypeScalarFieldEnum)[keyof typeof JournalTypeScalarFieldEnum]


  export const MarchandiseScalarFieldEnum: {
    id: 'id',
    libelle: 'libelle'
  };

  export type MarchandiseScalarFieldEnum = (typeof MarchandiseScalarFieldEnum)[keyof typeof MarchandiseScalarFieldEnum]


  export const PaiementScalarFieldEnum: {
    id: 'id',
    datePaiement: 'datePaiement',
    motif: 'motif',
    montant: 'montant',
    idClient: 'idClient',
    archived: 'archived',
    createdAt: 'createdAt',
    status: 'status',
    numeroInvoice: 'numeroInvoice'
  };

  export type PaiementScalarFieldEnum = (typeof PaiementScalarFieldEnum)[keyof typeof PaiementScalarFieldEnum]


  export const RubriqueFactureScalarFieldEnum: {
    id: 'id',
    produit: 'produit',
    libelle: 'libelle',
    identifiant: 'identifiant',
    compte: 'compte',
    compteAnalytique: 'compteAnalytique'
  };

  export type RubriqueFactureScalarFieldEnum = (typeof RubriqueFactureScalarFieldEnum)[keyof typeof RubriqueFactureScalarFieldEnum]


  export const UtilisateurScalarFieldEnum: {
    id: 'id',
    name: 'name',
    login: 'login',
    role: 'role',
    password: 'password',
    status: 'status'
  };

  export type UtilisateurScalarFieldEnum = (typeof UtilisateurScalarFieldEnum)[keyof typeof UtilisateurScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'STATUSFACTURE'
   */
  export type EnumSTATUSFACTUREFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'STATUSFACTURE'>
    


  /**
   * Reference to a field of type 'STATUSFACTURE[]'
   */
  export type ListEnumSTATUSFACTUREFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'STATUSFACTURE[]'>
    


  /**
   * Reference to a field of type 'TYPEFACTURATION'
   */
  export type EnumTYPEFACTURATIONFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TYPEFACTURATION'>
    


  /**
   * Reference to a field of type 'TYPEFACTURATION[]'
   */
  export type ListEnumTYPEFACTURATIONFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TYPEFACTURATION[]'>
    


  /**
   * Reference to a field of type 'NIVEAUSAISIE'
   */
  export type EnumNIVEAUSAISIEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NIVEAUSAISIE'>
    


  /**
   * Reference to a field of type 'NIVEAUSAISIE[]'
   */
  export type ListEnumNIVEAUSAISIEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NIVEAUSAISIE[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'StatusRow'
   */
  export type EnumStatusRowFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusRow'>
    


  /**
   * Reference to a field of type 'StatusRow[]'
   */
  export type ListEnumStatusRowFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusRow[]'>
    
  /**
   * Deep Input Types
   */


  export type CamionWhereInput = {
    AND?: CamionWhereInput | CamionWhereInput[]
    OR?: CamionWhereInput[]
    NOT?: CamionWhereInput | CamionWhereInput[]
    id?: StringFilter<"Camion"> | string
    libelle?: StringFilter<"Camion"> | string
    factures?: FactureImportListRelationFilter
  }

  export type CamionOrderByWithRelationInput = {
    id?: SortOrder
    libelle?: SortOrder
    factures?: FactureImportOrderByRelationAggregateInput
  }

  export type CamionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CamionWhereInput | CamionWhereInput[]
    OR?: CamionWhereInput[]
    NOT?: CamionWhereInput | CamionWhereInput[]
    libelle?: StringFilter<"Camion"> | string
    factures?: FactureImportListRelationFilter
  }, "id">

  export type CamionOrderByWithAggregationInput = {
    id?: SortOrder
    libelle?: SortOrder
    _count?: CamionCountOrderByAggregateInput
    _max?: CamionMaxOrderByAggregateInput
    _min?: CamionMinOrderByAggregateInput
  }

  export type CamionScalarWhereWithAggregatesInput = {
    AND?: CamionScalarWhereWithAggregatesInput | CamionScalarWhereWithAggregatesInput[]
    OR?: CamionScalarWhereWithAggregatesInput[]
    NOT?: CamionScalarWhereWithAggregatesInput | CamionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Camion"> | string
    libelle?: StringWithAggregatesFilter<"Camion"> | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    nom_client?: StringNullableFilter<"Client"> | string | null
    code?: StringNullableFilter<"Client"> | string | null
    num_nif?: StringNullableFilter<"Client"> | string | null
    adresse?: StringNullableFilter<"Client"> | string | null
    telephone?: StringNullableFilter<"Client"> | string | null
    email?: StringNullableFilter<"Client"> | string | null
    rccm?: StringNullableFilter<"Client"> | string | null
    idNat?: StringNullableFilter<"Client"> | string | null
    isFacturedForImport?: StringNullableFilter<"Client"> | string | null
    isFacturedForExport?: StringNullableFilter<"Client"> | string | null
    isFacturedForTva?: StringNullableFilter<"Client"> | string | null
    lastPrintedDeclation?: DateTimeNullableFilter<"Client"> | Date | string | null
    enabled?: StringNullableFilter<"Client"> | string | null
    paiement?: PaiementListRelationFilter
    journalType?: JournalTypeListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    nom_client?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    num_nif?: SortOrderInput | SortOrder
    adresse?: SortOrderInput | SortOrder
    telephone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    rccm?: SortOrderInput | SortOrder
    idNat?: SortOrderInput | SortOrder
    isFacturedForImport?: SortOrderInput | SortOrder
    isFacturedForExport?: SortOrderInput | SortOrder
    isFacturedForTva?: SortOrderInput | SortOrder
    lastPrintedDeclation?: SortOrderInput | SortOrder
    enabled?: SortOrderInput | SortOrder
    paiement?: PaiementOrderByRelationAggregateInput
    journalType?: JournalTypeOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    nom_client?: StringNullableFilter<"Client"> | string | null
    code?: StringNullableFilter<"Client"> | string | null
    num_nif?: StringNullableFilter<"Client"> | string | null
    adresse?: StringNullableFilter<"Client"> | string | null
    telephone?: StringNullableFilter<"Client"> | string | null
    email?: StringNullableFilter<"Client"> | string | null
    rccm?: StringNullableFilter<"Client"> | string | null
    idNat?: StringNullableFilter<"Client"> | string | null
    isFacturedForImport?: StringNullableFilter<"Client"> | string | null
    isFacturedForExport?: StringNullableFilter<"Client"> | string | null
    isFacturedForTva?: StringNullableFilter<"Client"> | string | null
    lastPrintedDeclation?: DateTimeNullableFilter<"Client"> | Date | string | null
    enabled?: StringNullableFilter<"Client"> | string | null
    paiement?: PaiementListRelationFilter
    journalType?: JournalTypeListRelationFilter
  }, "id">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    nom_client?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    num_nif?: SortOrderInput | SortOrder
    adresse?: SortOrderInput | SortOrder
    telephone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    rccm?: SortOrderInput | SortOrder
    idNat?: SortOrderInput | SortOrder
    isFacturedForImport?: SortOrderInput | SortOrder
    isFacturedForExport?: SortOrderInput | SortOrder
    isFacturedForTva?: SortOrderInput | SortOrder
    lastPrintedDeclation?: SortOrderInput | SortOrder
    enabled?: SortOrderInput | SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    nom_client?: StringNullableWithAggregatesFilter<"Client"> | string | null
    code?: StringNullableWithAggregatesFilter<"Client"> | string | null
    num_nif?: StringNullableWithAggregatesFilter<"Client"> | string | null
    adresse?: StringNullableWithAggregatesFilter<"Client"> | string | null
    telephone?: StringNullableWithAggregatesFilter<"Client"> | string | null
    email?: StringNullableWithAggregatesFilter<"Client"> | string | null
    rccm?: StringNullableWithAggregatesFilter<"Client"> | string | null
    idNat?: StringNullableWithAggregatesFilter<"Client"> | string | null
    isFacturedForImport?: StringNullableWithAggregatesFilter<"Client"> | string | null
    isFacturedForExport?: StringNullableWithAggregatesFilter<"Client"> | string | null
    isFacturedForTva?: StringNullableWithAggregatesFilter<"Client"> | string | null
    lastPrintedDeclation?: DateTimeNullableWithAggregatesFilter<"Client"> | Date | string | null
    enabled?: StringNullableWithAggregatesFilter<"Client"> | string | null
  }

  export type DetailFactureWhereInput = {
    AND?: DetailFactureWhereInput | DetailFactureWhereInput[]
    OR?: DetailFactureWhereInput[]
    NOT?: DetailFactureWhereInput | DetailFactureWhereInput[]
    id?: StringFilter<"DetailFacture"> | string
    factureId?: StringFilter<"DetailFacture"> | string
    rubriqueFactureId?: StringFilter<"DetailFacture"> | string
    qte?: IntFilter<"DetailFacture"> | number
    prix?: FloatFilter<"DetailFacture"> | number
    facture?: XOR<FactureImportScalarRelationFilter, FactureImportWhereInput>
    rubriqueFacture?: XOR<RubriqueFactureScalarRelationFilter, RubriqueFactureWhereInput>
  }

  export type DetailFactureOrderByWithRelationInput = {
    id?: SortOrder
    factureId?: SortOrder
    rubriqueFactureId?: SortOrder
    qte?: SortOrder
    prix?: SortOrder
    facture?: FactureImportOrderByWithRelationInput
    rubriqueFacture?: RubriqueFactureOrderByWithRelationInput
  }

  export type DetailFactureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DetailFactureWhereInput | DetailFactureWhereInput[]
    OR?: DetailFactureWhereInput[]
    NOT?: DetailFactureWhereInput | DetailFactureWhereInput[]
    factureId?: StringFilter<"DetailFacture"> | string
    rubriqueFactureId?: StringFilter<"DetailFacture"> | string
    qte?: IntFilter<"DetailFacture"> | number
    prix?: FloatFilter<"DetailFacture"> | number
    facture?: XOR<FactureImportScalarRelationFilter, FactureImportWhereInput>
    rubriqueFacture?: XOR<RubriqueFactureScalarRelationFilter, RubriqueFactureWhereInput>
  }, "id">

  export type DetailFactureOrderByWithAggregationInput = {
    id?: SortOrder
    factureId?: SortOrder
    rubriqueFactureId?: SortOrder
    qte?: SortOrder
    prix?: SortOrder
    _count?: DetailFactureCountOrderByAggregateInput
    _avg?: DetailFactureAvgOrderByAggregateInput
    _max?: DetailFactureMaxOrderByAggregateInput
    _min?: DetailFactureMinOrderByAggregateInput
    _sum?: DetailFactureSumOrderByAggregateInput
  }

  export type DetailFactureScalarWhereWithAggregatesInput = {
    AND?: DetailFactureScalarWhereWithAggregatesInput | DetailFactureScalarWhereWithAggregatesInput[]
    OR?: DetailFactureScalarWhereWithAggregatesInput[]
    NOT?: DetailFactureScalarWhereWithAggregatesInput | DetailFactureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DetailFacture"> | string
    factureId?: StringWithAggregatesFilter<"DetailFacture"> | string
    rubriqueFactureId?: StringWithAggregatesFilter<"DetailFacture"> | string
    qte?: IntWithAggregatesFilter<"DetailFacture"> | number
    prix?: FloatWithAggregatesFilter<"DetailFacture"> | number
  }

  export type FactureImportWhereInput = {
    AND?: FactureImportWhereInput | FactureImportWhereInput[]
    OR?: FactureImportWhereInput[]
    NOT?: FactureImportWhereInput | FactureImportWhereInput[]
    id?: StringFilter<"FactureImport"> | string
    dossier?: StringNullableFilter<"FactureImport"> | string | null
    dateFacture?: DateTimeNullableFilter<"FactureImport"> | Date | string | null
    journalTypeId?: StringFilter<"FactureImport"> | string
    manifeste?: StringNullableFilter<"FactureImport"> | string | null
    t1?: StringNullableFilter<"FactureImport"> | string | null
    camionId?: StringFilter<"FactureImport"> | string
    marchandiseId?: StringFilter<"FactureImport"> | string
    declarationId?: StringNullableFilter<"FactureImport"> | string | null
    declarationDate?: DateTimeNullableFilter<"FactureImport"> | Date | string | null
    liquidationId?: StringNullableFilter<"FactureImport"> | string | null
    liquidationDate?: DateTimeNullableFilter<"FactureImport"> | Date | string | null
    quittanceId?: StringNullableFilter<"FactureImport"> | string | null
    quittanceDate?: DateTimeNullableFilter<"FactureImport"> | Date | string | null
    quittanceMontant?: FloatFilter<"FactureImport"> | number
    poids?: StringNullableFilter<"FactureImport"> | string | null
    colis?: StringNullableFilter<"FactureImport"> | string | null
    status?: EnumSTATUSFACTUREFilter<"FactureImport"> | $Enums.STATUSFACTURE
    createdAt?: DateTimeFilter<"FactureImport"> | Date | string
    montant?: FloatNullableFilter<"FactureImport"> | number | null
    typeFact?: EnumTYPEFACTURATIONNullableFilter<"FactureImport"> | $Enums.TYPEFACTURATION | null
    niveauSaisie?: EnumNIVEAUSAISIEFilter<"FactureImport"> | $Enums.NIVEAUSAISIE
    numeroFacture?: StringNullableFilter<"FactureImport"> | string | null
    journalType?: XOR<JournalTypeScalarRelationFilter, JournalTypeWhereInput>
    camion?: XOR<CamionScalarRelationFilter, CamionWhereInput>
    marchandise?: XOR<MarchandiseScalarRelationFilter, MarchandiseWhereInput>
    detailFacture?: DetailFactureListRelationFilter
  }

  export type FactureImportOrderByWithRelationInput = {
    id?: SortOrder
    dossier?: SortOrderInput | SortOrder
    dateFacture?: SortOrderInput | SortOrder
    journalTypeId?: SortOrder
    manifeste?: SortOrderInput | SortOrder
    t1?: SortOrderInput | SortOrder
    camionId?: SortOrder
    marchandiseId?: SortOrder
    declarationId?: SortOrderInput | SortOrder
    declarationDate?: SortOrderInput | SortOrder
    liquidationId?: SortOrderInput | SortOrder
    liquidationDate?: SortOrderInput | SortOrder
    quittanceId?: SortOrderInput | SortOrder
    quittanceDate?: SortOrderInput | SortOrder
    quittanceMontant?: SortOrder
    poids?: SortOrderInput | SortOrder
    colis?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    montant?: SortOrderInput | SortOrder
    typeFact?: SortOrderInput | SortOrder
    niveauSaisie?: SortOrder
    numeroFacture?: SortOrderInput | SortOrder
    journalType?: JournalTypeOrderByWithRelationInput
    camion?: CamionOrderByWithRelationInput
    marchandise?: MarchandiseOrderByWithRelationInput
    detailFacture?: DetailFactureOrderByRelationAggregateInput
  }

  export type FactureImportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FactureImportWhereInput | FactureImportWhereInput[]
    OR?: FactureImportWhereInput[]
    NOT?: FactureImportWhereInput | FactureImportWhereInput[]
    dossier?: StringNullableFilter<"FactureImport"> | string | null
    dateFacture?: DateTimeNullableFilter<"FactureImport"> | Date | string | null
    journalTypeId?: StringFilter<"FactureImport"> | string
    manifeste?: StringNullableFilter<"FactureImport"> | string | null
    t1?: StringNullableFilter<"FactureImport"> | string | null
    camionId?: StringFilter<"FactureImport"> | string
    marchandiseId?: StringFilter<"FactureImport"> | string
    declarationId?: StringNullableFilter<"FactureImport"> | string | null
    declarationDate?: DateTimeNullableFilter<"FactureImport"> | Date | string | null
    liquidationId?: StringNullableFilter<"FactureImport"> | string | null
    liquidationDate?: DateTimeNullableFilter<"FactureImport"> | Date | string | null
    quittanceId?: StringNullableFilter<"FactureImport"> | string | null
    quittanceDate?: DateTimeNullableFilter<"FactureImport"> | Date | string | null
    quittanceMontant?: FloatFilter<"FactureImport"> | number
    poids?: StringNullableFilter<"FactureImport"> | string | null
    colis?: StringNullableFilter<"FactureImport"> | string | null
    status?: EnumSTATUSFACTUREFilter<"FactureImport"> | $Enums.STATUSFACTURE
    createdAt?: DateTimeFilter<"FactureImport"> | Date | string
    montant?: FloatNullableFilter<"FactureImport"> | number | null
    typeFact?: EnumTYPEFACTURATIONNullableFilter<"FactureImport"> | $Enums.TYPEFACTURATION | null
    niveauSaisie?: EnumNIVEAUSAISIEFilter<"FactureImport"> | $Enums.NIVEAUSAISIE
    numeroFacture?: StringNullableFilter<"FactureImport"> | string | null
    journalType?: XOR<JournalTypeScalarRelationFilter, JournalTypeWhereInput>
    camion?: XOR<CamionScalarRelationFilter, CamionWhereInput>
    marchandise?: XOR<MarchandiseScalarRelationFilter, MarchandiseWhereInput>
    detailFacture?: DetailFactureListRelationFilter
  }, "id">

  export type FactureImportOrderByWithAggregationInput = {
    id?: SortOrder
    dossier?: SortOrderInput | SortOrder
    dateFacture?: SortOrderInput | SortOrder
    journalTypeId?: SortOrder
    manifeste?: SortOrderInput | SortOrder
    t1?: SortOrderInput | SortOrder
    camionId?: SortOrder
    marchandiseId?: SortOrder
    declarationId?: SortOrderInput | SortOrder
    declarationDate?: SortOrderInput | SortOrder
    liquidationId?: SortOrderInput | SortOrder
    liquidationDate?: SortOrderInput | SortOrder
    quittanceId?: SortOrderInput | SortOrder
    quittanceDate?: SortOrderInput | SortOrder
    quittanceMontant?: SortOrder
    poids?: SortOrderInput | SortOrder
    colis?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    montant?: SortOrderInput | SortOrder
    typeFact?: SortOrderInput | SortOrder
    niveauSaisie?: SortOrder
    numeroFacture?: SortOrderInput | SortOrder
    _count?: FactureImportCountOrderByAggregateInput
    _avg?: FactureImportAvgOrderByAggregateInput
    _max?: FactureImportMaxOrderByAggregateInput
    _min?: FactureImportMinOrderByAggregateInput
    _sum?: FactureImportSumOrderByAggregateInput
  }

  export type FactureImportScalarWhereWithAggregatesInput = {
    AND?: FactureImportScalarWhereWithAggregatesInput | FactureImportScalarWhereWithAggregatesInput[]
    OR?: FactureImportScalarWhereWithAggregatesInput[]
    NOT?: FactureImportScalarWhereWithAggregatesInput | FactureImportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FactureImport"> | string
    dossier?: StringNullableWithAggregatesFilter<"FactureImport"> | string | null
    dateFacture?: DateTimeNullableWithAggregatesFilter<"FactureImport"> | Date | string | null
    journalTypeId?: StringWithAggregatesFilter<"FactureImport"> | string
    manifeste?: StringNullableWithAggregatesFilter<"FactureImport"> | string | null
    t1?: StringNullableWithAggregatesFilter<"FactureImport"> | string | null
    camionId?: StringWithAggregatesFilter<"FactureImport"> | string
    marchandiseId?: StringWithAggregatesFilter<"FactureImport"> | string
    declarationId?: StringNullableWithAggregatesFilter<"FactureImport"> | string | null
    declarationDate?: DateTimeNullableWithAggregatesFilter<"FactureImport"> | Date | string | null
    liquidationId?: StringNullableWithAggregatesFilter<"FactureImport"> | string | null
    liquidationDate?: DateTimeNullableWithAggregatesFilter<"FactureImport"> | Date | string | null
    quittanceId?: StringNullableWithAggregatesFilter<"FactureImport"> | string | null
    quittanceDate?: DateTimeNullableWithAggregatesFilter<"FactureImport"> | Date | string | null
    quittanceMontant?: FloatWithAggregatesFilter<"FactureImport"> | number
    poids?: StringNullableWithAggregatesFilter<"FactureImport"> | string | null
    colis?: StringNullableWithAggregatesFilter<"FactureImport"> | string | null
    status?: EnumSTATUSFACTUREWithAggregatesFilter<"FactureImport"> | $Enums.STATUSFACTURE
    createdAt?: DateTimeWithAggregatesFilter<"FactureImport"> | Date | string
    montant?: FloatNullableWithAggregatesFilter<"FactureImport"> | number | null
    typeFact?: EnumTYPEFACTURATIONNullableWithAggregatesFilter<"FactureImport"> | $Enums.TYPEFACTURATION | null
    niveauSaisie?: EnumNIVEAUSAISIEWithAggregatesFilter<"FactureImport"> | $Enums.NIVEAUSAISIE
    numeroFacture?: StringNullableWithAggregatesFilter<"FactureImport"> | string | null
  }

  export type JournalWhereInput = {
    AND?: JournalWhereInput | JournalWhereInput[]
    OR?: JournalWhereInput[]
    NOT?: JournalWhereInput | JournalWhereInput[]
    id?: StringFilter<"Journal"> | string
    journalTypeId?: StringNullableFilter<"Journal"> | string | null
    numero?: IntFilter<"Journal"> | number
    journalType?: XOR<JournalTypeNullableScalarRelationFilter, JournalTypeWhereInput> | null
  }

  export type JournalOrderByWithRelationInput = {
    id?: SortOrder
    journalTypeId?: SortOrderInput | SortOrder
    numero?: SortOrder
    journalType?: JournalTypeOrderByWithRelationInput
  }

  export type JournalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalWhereInput | JournalWhereInput[]
    OR?: JournalWhereInput[]
    NOT?: JournalWhereInput | JournalWhereInput[]
    journalTypeId?: StringNullableFilter<"Journal"> | string | null
    numero?: IntFilter<"Journal"> | number
    journalType?: XOR<JournalTypeNullableScalarRelationFilter, JournalTypeWhereInput> | null
  }, "id">

  export type JournalOrderByWithAggregationInput = {
    id?: SortOrder
    journalTypeId?: SortOrderInput | SortOrder
    numero?: SortOrder
    _count?: JournalCountOrderByAggregateInput
    _avg?: JournalAvgOrderByAggregateInput
    _max?: JournalMaxOrderByAggregateInput
    _min?: JournalMinOrderByAggregateInput
    _sum?: JournalSumOrderByAggregateInput
  }

  export type JournalScalarWhereWithAggregatesInput = {
    AND?: JournalScalarWhereWithAggregatesInput | JournalScalarWhereWithAggregatesInput[]
    OR?: JournalScalarWhereWithAggregatesInput[]
    NOT?: JournalScalarWhereWithAggregatesInput | JournalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Journal"> | string
    journalTypeId?: StringNullableWithAggregatesFilter<"Journal"> | string | null
    numero?: IntWithAggregatesFilter<"Journal"> | number
  }

  export type JournalTypeWhereInput = {
    AND?: JournalTypeWhereInput | JournalTypeWhereInput[]
    OR?: JournalTypeWhereInput[]
    NOT?: JournalTypeWhereInput | JournalTypeWhereInput[]
    id?: StringFilter<"JournalType"> | string
    libelle?: StringFilter<"JournalType"> | string
    formatJournal?: StringFilter<"JournalType"> | string
    ClientId?: StringFilter<"JournalType"> | string
    derniereImpression?: StringNullableFilter<"JournalType"> | string | null
    solde?: FloatNullableFilter<"JournalType"> | number | null
    journals?: JournalListRelationFilter
    Client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    FactureImport?: FactureImportListRelationFilter
  }

  export type JournalTypeOrderByWithRelationInput = {
    id?: SortOrder
    libelle?: SortOrder
    formatJournal?: SortOrder
    ClientId?: SortOrder
    derniereImpression?: SortOrderInput | SortOrder
    solde?: SortOrderInput | SortOrder
    journals?: JournalOrderByRelationAggregateInput
    Client?: ClientOrderByWithRelationInput
    FactureImport?: FactureImportOrderByRelationAggregateInput
  }

  export type JournalTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalTypeWhereInput | JournalTypeWhereInput[]
    OR?: JournalTypeWhereInput[]
    NOT?: JournalTypeWhereInput | JournalTypeWhereInput[]
    libelle?: StringFilter<"JournalType"> | string
    formatJournal?: StringFilter<"JournalType"> | string
    ClientId?: StringFilter<"JournalType"> | string
    derniereImpression?: StringNullableFilter<"JournalType"> | string | null
    solde?: FloatNullableFilter<"JournalType"> | number | null
    journals?: JournalListRelationFilter
    Client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    FactureImport?: FactureImportListRelationFilter
  }, "id">

  export type JournalTypeOrderByWithAggregationInput = {
    id?: SortOrder
    libelle?: SortOrder
    formatJournal?: SortOrder
    ClientId?: SortOrder
    derniereImpression?: SortOrderInput | SortOrder
    solde?: SortOrderInput | SortOrder
    _count?: JournalTypeCountOrderByAggregateInput
    _avg?: JournalTypeAvgOrderByAggregateInput
    _max?: JournalTypeMaxOrderByAggregateInput
    _min?: JournalTypeMinOrderByAggregateInput
    _sum?: JournalTypeSumOrderByAggregateInput
  }

  export type JournalTypeScalarWhereWithAggregatesInput = {
    AND?: JournalTypeScalarWhereWithAggregatesInput | JournalTypeScalarWhereWithAggregatesInput[]
    OR?: JournalTypeScalarWhereWithAggregatesInput[]
    NOT?: JournalTypeScalarWhereWithAggregatesInput | JournalTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JournalType"> | string
    libelle?: StringWithAggregatesFilter<"JournalType"> | string
    formatJournal?: StringWithAggregatesFilter<"JournalType"> | string
    ClientId?: StringWithAggregatesFilter<"JournalType"> | string
    derniereImpression?: StringNullableWithAggregatesFilter<"JournalType"> | string | null
    solde?: FloatNullableWithAggregatesFilter<"JournalType"> | number | null
  }

  export type MarchandiseWhereInput = {
    AND?: MarchandiseWhereInput | MarchandiseWhereInput[]
    OR?: MarchandiseWhereInput[]
    NOT?: MarchandiseWhereInput | MarchandiseWhereInput[]
    id?: StringFilter<"Marchandise"> | string
    libelle?: StringFilter<"Marchandise"> | string
    factures?: FactureImportListRelationFilter
  }

  export type MarchandiseOrderByWithRelationInput = {
    id?: SortOrder
    libelle?: SortOrder
    factures?: FactureImportOrderByRelationAggregateInput
  }

  export type MarchandiseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarchandiseWhereInput | MarchandiseWhereInput[]
    OR?: MarchandiseWhereInput[]
    NOT?: MarchandiseWhereInput | MarchandiseWhereInput[]
    libelle?: StringFilter<"Marchandise"> | string
    factures?: FactureImportListRelationFilter
  }, "id">

  export type MarchandiseOrderByWithAggregationInput = {
    id?: SortOrder
    libelle?: SortOrder
    _count?: MarchandiseCountOrderByAggregateInput
    _max?: MarchandiseMaxOrderByAggregateInput
    _min?: MarchandiseMinOrderByAggregateInput
  }

  export type MarchandiseScalarWhereWithAggregatesInput = {
    AND?: MarchandiseScalarWhereWithAggregatesInput | MarchandiseScalarWhereWithAggregatesInput[]
    OR?: MarchandiseScalarWhereWithAggregatesInput[]
    NOT?: MarchandiseScalarWhereWithAggregatesInput | MarchandiseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Marchandise"> | string
    libelle?: StringWithAggregatesFilter<"Marchandise"> | string
  }

  export type PaiementWhereInput = {
    AND?: PaiementWhereInput | PaiementWhereInput[]
    OR?: PaiementWhereInput[]
    NOT?: PaiementWhereInput | PaiementWhereInput[]
    id?: StringFilter<"Paiement"> | string
    datePaiement?: DateTimeFilter<"Paiement"> | Date | string
    motif?: StringNullableFilter<"Paiement"> | string | null
    montant?: FloatFilter<"Paiement"> | number
    idClient?: StringFilter<"Paiement"> | string
    archived?: BoolFilter<"Paiement"> | boolean
    createdAt?: DateTimeFilter<"Paiement"> | Date | string
    status?: EnumStatusRowFilter<"Paiement"> | $Enums.StatusRow
    numeroInvoice?: StringNullableFilter<"Paiement"> | string | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type PaiementOrderByWithRelationInput = {
    id?: SortOrder
    datePaiement?: SortOrder
    motif?: SortOrderInput | SortOrder
    montant?: SortOrder
    idClient?: SortOrder
    archived?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    numeroInvoice?: SortOrderInput | SortOrder
    client?: ClientOrderByWithRelationInput
  }

  export type PaiementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaiementWhereInput | PaiementWhereInput[]
    OR?: PaiementWhereInput[]
    NOT?: PaiementWhereInput | PaiementWhereInput[]
    datePaiement?: DateTimeFilter<"Paiement"> | Date | string
    motif?: StringNullableFilter<"Paiement"> | string | null
    montant?: FloatFilter<"Paiement"> | number
    idClient?: StringFilter<"Paiement"> | string
    archived?: BoolFilter<"Paiement"> | boolean
    createdAt?: DateTimeFilter<"Paiement"> | Date | string
    status?: EnumStatusRowFilter<"Paiement"> | $Enums.StatusRow
    numeroInvoice?: StringNullableFilter<"Paiement"> | string | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id">

  export type PaiementOrderByWithAggregationInput = {
    id?: SortOrder
    datePaiement?: SortOrder
    motif?: SortOrderInput | SortOrder
    montant?: SortOrder
    idClient?: SortOrder
    archived?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    numeroInvoice?: SortOrderInput | SortOrder
    _count?: PaiementCountOrderByAggregateInput
    _avg?: PaiementAvgOrderByAggregateInput
    _max?: PaiementMaxOrderByAggregateInput
    _min?: PaiementMinOrderByAggregateInput
    _sum?: PaiementSumOrderByAggregateInput
  }

  export type PaiementScalarWhereWithAggregatesInput = {
    AND?: PaiementScalarWhereWithAggregatesInput | PaiementScalarWhereWithAggregatesInput[]
    OR?: PaiementScalarWhereWithAggregatesInput[]
    NOT?: PaiementScalarWhereWithAggregatesInput | PaiementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Paiement"> | string
    datePaiement?: DateTimeWithAggregatesFilter<"Paiement"> | Date | string
    motif?: StringNullableWithAggregatesFilter<"Paiement"> | string | null
    montant?: FloatWithAggregatesFilter<"Paiement"> | number
    idClient?: StringWithAggregatesFilter<"Paiement"> | string
    archived?: BoolWithAggregatesFilter<"Paiement"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Paiement"> | Date | string
    status?: EnumStatusRowWithAggregatesFilter<"Paiement"> | $Enums.StatusRow
    numeroInvoice?: StringNullableWithAggregatesFilter<"Paiement"> | string | null
  }

  export type RubriqueFactureWhereInput = {
    AND?: RubriqueFactureWhereInput | RubriqueFactureWhereInput[]
    OR?: RubriqueFactureWhereInput[]
    NOT?: RubriqueFactureWhereInput | RubriqueFactureWhereInput[]
    id?: StringFilter<"RubriqueFacture"> | string
    produit?: StringNullableFilter<"RubriqueFacture"> | string | null
    libelle?: StringNullableFilter<"RubriqueFacture"> | string | null
    identifiant?: StringFilter<"RubriqueFacture"> | string
    compte?: StringNullableFilter<"RubriqueFacture"> | string | null
    compteAnalytique?: StringNullableFilter<"RubriqueFacture"> | string | null
    detailFacture?: DetailFactureListRelationFilter
  }

  export type RubriqueFactureOrderByWithRelationInput = {
    id?: SortOrder
    produit?: SortOrderInput | SortOrder
    libelle?: SortOrderInput | SortOrder
    identifiant?: SortOrder
    compte?: SortOrderInput | SortOrder
    compteAnalytique?: SortOrderInput | SortOrder
    detailFacture?: DetailFactureOrderByRelationAggregateInput
  }

  export type RubriqueFactureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RubriqueFactureWhereInput | RubriqueFactureWhereInput[]
    OR?: RubriqueFactureWhereInput[]
    NOT?: RubriqueFactureWhereInput | RubriqueFactureWhereInput[]
    produit?: StringNullableFilter<"RubriqueFacture"> | string | null
    libelle?: StringNullableFilter<"RubriqueFacture"> | string | null
    identifiant?: StringFilter<"RubriqueFacture"> | string
    compte?: StringNullableFilter<"RubriqueFacture"> | string | null
    compteAnalytique?: StringNullableFilter<"RubriqueFacture"> | string | null
    detailFacture?: DetailFactureListRelationFilter
  }, "id">

  export type RubriqueFactureOrderByWithAggregationInput = {
    id?: SortOrder
    produit?: SortOrderInput | SortOrder
    libelle?: SortOrderInput | SortOrder
    identifiant?: SortOrder
    compte?: SortOrderInput | SortOrder
    compteAnalytique?: SortOrderInput | SortOrder
    _count?: RubriqueFactureCountOrderByAggregateInput
    _max?: RubriqueFactureMaxOrderByAggregateInput
    _min?: RubriqueFactureMinOrderByAggregateInput
  }

  export type RubriqueFactureScalarWhereWithAggregatesInput = {
    AND?: RubriqueFactureScalarWhereWithAggregatesInput | RubriqueFactureScalarWhereWithAggregatesInput[]
    OR?: RubriqueFactureScalarWhereWithAggregatesInput[]
    NOT?: RubriqueFactureScalarWhereWithAggregatesInput | RubriqueFactureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RubriqueFacture"> | string
    produit?: StringNullableWithAggregatesFilter<"RubriqueFacture"> | string | null
    libelle?: StringNullableWithAggregatesFilter<"RubriqueFacture"> | string | null
    identifiant?: StringWithAggregatesFilter<"RubriqueFacture"> | string
    compte?: StringNullableWithAggregatesFilter<"RubriqueFacture"> | string | null
    compteAnalytique?: StringNullableWithAggregatesFilter<"RubriqueFacture"> | string | null
  }

  export type UtilisateurWhereInput = {
    AND?: UtilisateurWhereInput | UtilisateurWhereInput[]
    OR?: UtilisateurWhereInput[]
    NOT?: UtilisateurWhereInput | UtilisateurWhereInput[]
    id?: StringFilter<"Utilisateur"> | string
    name?: StringNullableFilter<"Utilisateur"> | string | null
    login?: StringFilter<"Utilisateur"> | string
    role?: StringFilter<"Utilisateur"> | string
    password?: StringNullableFilter<"Utilisateur"> | string | null
    status?: EnumStatusRowFilter<"Utilisateur"> | $Enums.StatusRow
  }

  export type UtilisateurOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    login?: SortOrder
    role?: SortOrder
    password?: SortOrderInput | SortOrder
    status?: SortOrder
  }

  export type UtilisateurWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UtilisateurWhereInput | UtilisateurWhereInput[]
    OR?: UtilisateurWhereInput[]
    NOT?: UtilisateurWhereInput | UtilisateurWhereInput[]
    name?: StringNullableFilter<"Utilisateur"> | string | null
    login?: StringFilter<"Utilisateur"> | string
    role?: StringFilter<"Utilisateur"> | string
    password?: StringNullableFilter<"Utilisateur"> | string | null
    status?: EnumStatusRowFilter<"Utilisateur"> | $Enums.StatusRow
  }, "id">

  export type UtilisateurOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    login?: SortOrder
    role?: SortOrder
    password?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: UtilisateurCountOrderByAggregateInput
    _max?: UtilisateurMaxOrderByAggregateInput
    _min?: UtilisateurMinOrderByAggregateInput
  }

  export type UtilisateurScalarWhereWithAggregatesInput = {
    AND?: UtilisateurScalarWhereWithAggregatesInput | UtilisateurScalarWhereWithAggregatesInput[]
    OR?: UtilisateurScalarWhereWithAggregatesInput[]
    NOT?: UtilisateurScalarWhereWithAggregatesInput | UtilisateurScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Utilisateur"> | string
    name?: StringNullableWithAggregatesFilter<"Utilisateur"> | string | null
    login?: StringWithAggregatesFilter<"Utilisateur"> | string
    role?: StringWithAggregatesFilter<"Utilisateur"> | string
    password?: StringNullableWithAggregatesFilter<"Utilisateur"> | string | null
    status?: EnumStatusRowWithAggregatesFilter<"Utilisateur"> | $Enums.StatusRow
  }

  export type CamionCreateInput = {
    id?: string
    libelle: string
    factures?: FactureImportCreateNestedManyWithoutCamionInput
  }

  export type CamionUncheckedCreateInput = {
    id?: string
    libelle: string
    factures?: FactureImportUncheckedCreateNestedManyWithoutCamionInput
  }

  export type CamionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    factures?: FactureImportUpdateManyWithoutCamionNestedInput
  }

  export type CamionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    factures?: FactureImportUncheckedUpdateManyWithoutCamionNestedInput
  }

  export type CamionCreateManyInput = {
    id?: string
    libelle: string
  }

  export type CamionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
  }

  export type CamionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
  }

  export type ClientCreateInput = {
    id?: string
    nom_client?: string | null
    code?: string | null
    num_nif?: string | null
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    rccm?: string | null
    idNat?: string | null
    isFacturedForImport?: string | null
    isFacturedForExport?: string | null
    isFacturedForTva?: string | null
    lastPrintedDeclation?: Date | string | null
    enabled?: string | null
    paiement?: PaiementCreateNestedManyWithoutClientInput
    journalType?: JournalTypeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    nom_client?: string | null
    code?: string | null
    num_nif?: string | null
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    rccm?: string | null
    idNat?: string | null
    isFacturedForImport?: string | null
    isFacturedForExport?: string | null
    isFacturedForTva?: string | null
    lastPrintedDeclation?: Date | string | null
    enabled?: string | null
    paiement?: PaiementUncheckedCreateNestedManyWithoutClientInput
    journalType?: JournalTypeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom_client?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    num_nif?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rccm?: NullableStringFieldUpdateOperationsInput | string | null
    idNat?: NullableStringFieldUpdateOperationsInput | string | null
    isFacturedForImport?: NullableStringFieldUpdateOperationsInput | string | null
    isFacturedForExport?: NullableStringFieldUpdateOperationsInput | string | null
    isFacturedForTva?: NullableStringFieldUpdateOperationsInput | string | null
    lastPrintedDeclation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabled?: NullableStringFieldUpdateOperationsInput | string | null
    paiement?: PaiementUpdateManyWithoutClientNestedInput
    journalType?: JournalTypeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom_client?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    num_nif?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rccm?: NullableStringFieldUpdateOperationsInput | string | null
    idNat?: NullableStringFieldUpdateOperationsInput | string | null
    isFacturedForImport?: NullableStringFieldUpdateOperationsInput | string | null
    isFacturedForExport?: NullableStringFieldUpdateOperationsInput | string | null
    isFacturedForTva?: NullableStringFieldUpdateOperationsInput | string | null
    lastPrintedDeclation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabled?: NullableStringFieldUpdateOperationsInput | string | null
    paiement?: PaiementUncheckedUpdateManyWithoutClientNestedInput
    journalType?: JournalTypeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    nom_client?: string | null
    code?: string | null
    num_nif?: string | null
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    rccm?: string | null
    idNat?: string | null
    isFacturedForImport?: string | null
    isFacturedForExport?: string | null
    isFacturedForTva?: string | null
    lastPrintedDeclation?: Date | string | null
    enabled?: string | null
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom_client?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    num_nif?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rccm?: NullableStringFieldUpdateOperationsInput | string | null
    idNat?: NullableStringFieldUpdateOperationsInput | string | null
    isFacturedForImport?: NullableStringFieldUpdateOperationsInput | string | null
    isFacturedForExport?: NullableStringFieldUpdateOperationsInput | string | null
    isFacturedForTva?: NullableStringFieldUpdateOperationsInput | string | null
    lastPrintedDeclation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabled?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom_client?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    num_nif?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rccm?: NullableStringFieldUpdateOperationsInput | string | null
    idNat?: NullableStringFieldUpdateOperationsInput | string | null
    isFacturedForImport?: NullableStringFieldUpdateOperationsInput | string | null
    isFacturedForExport?: NullableStringFieldUpdateOperationsInput | string | null
    isFacturedForTva?: NullableStringFieldUpdateOperationsInput | string | null
    lastPrintedDeclation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabled?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DetailFactureCreateInput = {
    id?: string
    qte?: number
    prix?: number
    facture: FactureImportCreateNestedOneWithoutDetailFactureInput
    rubriqueFacture: RubriqueFactureCreateNestedOneWithoutDetailFactureInput
  }

  export type DetailFactureUncheckedCreateInput = {
    id?: string
    factureId: string
    rubriqueFactureId: string
    qte?: number
    prix?: number
  }

  export type DetailFactureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qte?: IntFieldUpdateOperationsInput | number
    prix?: FloatFieldUpdateOperationsInput | number
    facture?: FactureImportUpdateOneRequiredWithoutDetailFactureNestedInput
    rubriqueFacture?: RubriqueFactureUpdateOneRequiredWithoutDetailFactureNestedInput
  }

  export type DetailFactureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    factureId?: StringFieldUpdateOperationsInput | string
    rubriqueFactureId?: StringFieldUpdateOperationsInput | string
    qte?: IntFieldUpdateOperationsInput | number
    prix?: FloatFieldUpdateOperationsInput | number
  }

  export type DetailFactureCreateManyInput = {
    id?: string
    factureId: string
    rubriqueFactureId: string
    qte?: number
    prix?: number
  }

  export type DetailFactureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qte?: IntFieldUpdateOperationsInput | number
    prix?: FloatFieldUpdateOperationsInput | number
  }

  export type DetailFactureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    factureId?: StringFieldUpdateOperationsInput | string
    rubriqueFactureId?: StringFieldUpdateOperationsInput | string
    qte?: IntFieldUpdateOperationsInput | number
    prix?: FloatFieldUpdateOperationsInput | number
  }

  export type FactureImportCreateInput = {
    id?: string
    dossier?: string | null
    dateFacture?: Date | string | null
    manifeste?: string | null
    t1?: string | null
    declarationId?: string | null
    declarationDate?: Date | string | null
    liquidationId?: string | null
    liquidationDate?: Date | string | null
    quittanceId?: string | null
    quittanceDate?: Date | string | null
    quittanceMontant?: number
    poids?: string | null
    colis?: string | null
    status?: $Enums.STATUSFACTURE
    createdAt?: Date | string
    montant?: number | null
    typeFact?: $Enums.TYPEFACTURATION | null
    niveauSaisie?: $Enums.NIVEAUSAISIE
    numeroFacture?: string | null
    journalType: JournalTypeCreateNestedOneWithoutFactureImportInput
    camion: CamionCreateNestedOneWithoutFacturesInput
    marchandise: MarchandiseCreateNestedOneWithoutFacturesInput
    detailFacture?: DetailFactureCreateNestedManyWithoutFactureInput
  }

  export type FactureImportUncheckedCreateInput = {
    id?: string
    dossier?: string | null
    dateFacture?: Date | string | null
    journalTypeId: string
    manifeste?: string | null
    t1?: string | null
    camionId: string
    marchandiseId: string
    declarationId?: string | null
    declarationDate?: Date | string | null
    liquidationId?: string | null
    liquidationDate?: Date | string | null
    quittanceId?: string | null
    quittanceDate?: Date | string | null
    quittanceMontant?: number
    poids?: string | null
    colis?: string | null
    status?: $Enums.STATUSFACTURE
    createdAt?: Date | string
    montant?: number | null
    typeFact?: $Enums.TYPEFACTURATION | null
    niveauSaisie?: $Enums.NIVEAUSAISIE
    numeroFacture?: string | null
    detailFacture?: DetailFactureUncheckedCreateNestedManyWithoutFactureInput
  }

  export type FactureImportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dossier?: NullableStringFieldUpdateOperationsInput | string | null
    dateFacture?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manifeste?: NullableStringFieldUpdateOperationsInput | string | null
    t1?: NullableStringFieldUpdateOperationsInput | string | null
    declarationId?: NullableStringFieldUpdateOperationsInput | string | null
    declarationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liquidationId?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceId?: NullableStringFieldUpdateOperationsInput | string | null
    quittanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceMontant?: FloatFieldUpdateOperationsInput | number
    poids?: NullableStringFieldUpdateOperationsInput | string | null
    colis?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSTATUSFACTUREFieldUpdateOperationsInput | $Enums.STATUSFACTURE
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    typeFact?: NullableEnumTYPEFACTURATIONFieldUpdateOperationsInput | $Enums.TYPEFACTURATION | null
    niveauSaisie?: EnumNIVEAUSAISIEFieldUpdateOperationsInput | $Enums.NIVEAUSAISIE
    numeroFacture?: NullableStringFieldUpdateOperationsInput | string | null
    journalType?: JournalTypeUpdateOneRequiredWithoutFactureImportNestedInput
    camion?: CamionUpdateOneRequiredWithoutFacturesNestedInput
    marchandise?: MarchandiseUpdateOneRequiredWithoutFacturesNestedInput
    detailFacture?: DetailFactureUpdateManyWithoutFactureNestedInput
  }

  export type FactureImportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dossier?: NullableStringFieldUpdateOperationsInput | string | null
    dateFacture?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journalTypeId?: StringFieldUpdateOperationsInput | string
    manifeste?: NullableStringFieldUpdateOperationsInput | string | null
    t1?: NullableStringFieldUpdateOperationsInput | string | null
    camionId?: StringFieldUpdateOperationsInput | string
    marchandiseId?: StringFieldUpdateOperationsInput | string
    declarationId?: NullableStringFieldUpdateOperationsInput | string | null
    declarationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liquidationId?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceId?: NullableStringFieldUpdateOperationsInput | string | null
    quittanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceMontant?: FloatFieldUpdateOperationsInput | number
    poids?: NullableStringFieldUpdateOperationsInput | string | null
    colis?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSTATUSFACTUREFieldUpdateOperationsInput | $Enums.STATUSFACTURE
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    typeFact?: NullableEnumTYPEFACTURATIONFieldUpdateOperationsInput | $Enums.TYPEFACTURATION | null
    niveauSaisie?: EnumNIVEAUSAISIEFieldUpdateOperationsInput | $Enums.NIVEAUSAISIE
    numeroFacture?: NullableStringFieldUpdateOperationsInput | string | null
    detailFacture?: DetailFactureUncheckedUpdateManyWithoutFactureNestedInput
  }

  export type FactureImportCreateManyInput = {
    id?: string
    dossier?: string | null
    dateFacture?: Date | string | null
    journalTypeId: string
    manifeste?: string | null
    t1?: string | null
    camionId: string
    marchandiseId: string
    declarationId?: string | null
    declarationDate?: Date | string | null
    liquidationId?: string | null
    liquidationDate?: Date | string | null
    quittanceId?: string | null
    quittanceDate?: Date | string | null
    quittanceMontant?: number
    poids?: string | null
    colis?: string | null
    status?: $Enums.STATUSFACTURE
    createdAt?: Date | string
    montant?: number | null
    typeFact?: $Enums.TYPEFACTURATION | null
    niveauSaisie?: $Enums.NIVEAUSAISIE
    numeroFacture?: string | null
  }

  export type FactureImportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dossier?: NullableStringFieldUpdateOperationsInput | string | null
    dateFacture?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manifeste?: NullableStringFieldUpdateOperationsInput | string | null
    t1?: NullableStringFieldUpdateOperationsInput | string | null
    declarationId?: NullableStringFieldUpdateOperationsInput | string | null
    declarationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liquidationId?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceId?: NullableStringFieldUpdateOperationsInput | string | null
    quittanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceMontant?: FloatFieldUpdateOperationsInput | number
    poids?: NullableStringFieldUpdateOperationsInput | string | null
    colis?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSTATUSFACTUREFieldUpdateOperationsInput | $Enums.STATUSFACTURE
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    typeFact?: NullableEnumTYPEFACTURATIONFieldUpdateOperationsInput | $Enums.TYPEFACTURATION | null
    niveauSaisie?: EnumNIVEAUSAISIEFieldUpdateOperationsInput | $Enums.NIVEAUSAISIE
    numeroFacture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FactureImportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dossier?: NullableStringFieldUpdateOperationsInput | string | null
    dateFacture?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journalTypeId?: StringFieldUpdateOperationsInput | string
    manifeste?: NullableStringFieldUpdateOperationsInput | string | null
    t1?: NullableStringFieldUpdateOperationsInput | string | null
    camionId?: StringFieldUpdateOperationsInput | string
    marchandiseId?: StringFieldUpdateOperationsInput | string
    declarationId?: NullableStringFieldUpdateOperationsInput | string | null
    declarationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liquidationId?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceId?: NullableStringFieldUpdateOperationsInput | string | null
    quittanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceMontant?: FloatFieldUpdateOperationsInput | number
    poids?: NullableStringFieldUpdateOperationsInput | string | null
    colis?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSTATUSFACTUREFieldUpdateOperationsInput | $Enums.STATUSFACTURE
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    typeFact?: NullableEnumTYPEFACTURATIONFieldUpdateOperationsInput | $Enums.TYPEFACTURATION | null
    niveauSaisie?: EnumNIVEAUSAISIEFieldUpdateOperationsInput | $Enums.NIVEAUSAISIE
    numeroFacture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalCreateInput = {
    id?: string
    numero?: number
    journalType?: JournalTypeCreateNestedOneWithoutJournalsInput
  }

  export type JournalUncheckedCreateInput = {
    id?: string
    journalTypeId?: string | null
    numero?: number
  }

  export type JournalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    journalType?: JournalTypeUpdateOneWithoutJournalsNestedInput
  }

  export type JournalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: IntFieldUpdateOperationsInput | number
  }

  export type JournalCreateManyInput = {
    id?: string
    journalTypeId?: string | null
    numero?: number
  }

  export type JournalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
  }

  export type JournalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: IntFieldUpdateOperationsInput | number
  }

  export type JournalTypeCreateInput = {
    id?: string
    libelle: string
    formatJournal: string
    derniereImpression?: string | null
    solde?: number | null
    journals?: JournalCreateNestedManyWithoutJournalTypeInput
    Client: ClientCreateNestedOneWithoutJournalTypeInput
    FactureImport?: FactureImportCreateNestedManyWithoutJournalTypeInput
  }

  export type JournalTypeUncheckedCreateInput = {
    id?: string
    libelle: string
    formatJournal: string
    ClientId: string
    derniereImpression?: string | null
    solde?: number | null
    journals?: JournalUncheckedCreateNestedManyWithoutJournalTypeInput
    FactureImport?: FactureImportUncheckedCreateNestedManyWithoutJournalTypeInput
  }

  export type JournalTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    formatJournal?: StringFieldUpdateOperationsInput | string
    derniereImpression?: NullableStringFieldUpdateOperationsInput | string | null
    solde?: NullableFloatFieldUpdateOperationsInput | number | null
    journals?: JournalUpdateManyWithoutJournalTypeNestedInput
    Client?: ClientUpdateOneRequiredWithoutJournalTypeNestedInput
    FactureImport?: FactureImportUpdateManyWithoutJournalTypeNestedInput
  }

  export type JournalTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    formatJournal?: StringFieldUpdateOperationsInput | string
    ClientId?: StringFieldUpdateOperationsInput | string
    derniereImpression?: NullableStringFieldUpdateOperationsInput | string | null
    solde?: NullableFloatFieldUpdateOperationsInput | number | null
    journals?: JournalUncheckedUpdateManyWithoutJournalTypeNestedInput
    FactureImport?: FactureImportUncheckedUpdateManyWithoutJournalTypeNestedInput
  }

  export type JournalTypeCreateManyInput = {
    id?: string
    libelle: string
    formatJournal: string
    ClientId: string
    derniereImpression?: string | null
    solde?: number | null
  }

  export type JournalTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    formatJournal?: StringFieldUpdateOperationsInput | string
    derniereImpression?: NullableStringFieldUpdateOperationsInput | string | null
    solde?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type JournalTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    formatJournal?: StringFieldUpdateOperationsInput | string
    ClientId?: StringFieldUpdateOperationsInput | string
    derniereImpression?: NullableStringFieldUpdateOperationsInput | string | null
    solde?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type MarchandiseCreateInput = {
    id?: string
    libelle: string
    factures?: FactureImportCreateNestedManyWithoutMarchandiseInput
  }

  export type MarchandiseUncheckedCreateInput = {
    id?: string
    libelle: string
    factures?: FactureImportUncheckedCreateNestedManyWithoutMarchandiseInput
  }

  export type MarchandiseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    factures?: FactureImportUpdateManyWithoutMarchandiseNestedInput
  }

  export type MarchandiseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    factures?: FactureImportUncheckedUpdateManyWithoutMarchandiseNestedInput
  }

  export type MarchandiseCreateManyInput = {
    id?: string
    libelle: string
  }

  export type MarchandiseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
  }

  export type MarchandiseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
  }

  export type PaiementCreateInput = {
    id?: string
    datePaiement: Date | string
    motif?: string | null
    montant: number
    archived?: boolean
    createdAt?: Date | string
    status?: $Enums.StatusRow
    numeroInvoice?: string | null
    client: ClientCreateNestedOneWithoutPaiementInput
  }

  export type PaiementUncheckedCreateInput = {
    id?: string
    datePaiement: Date | string
    motif?: string | null
    montant: number
    idClient: string
    archived?: boolean
    createdAt?: Date | string
    status?: $Enums.StatusRow
    numeroInvoice?: string | null
  }

  export type PaiementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    montant?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusRowFieldUpdateOperationsInput | $Enums.StatusRow
    numeroInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutPaiementNestedInput
  }

  export type PaiementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    montant?: FloatFieldUpdateOperationsInput | number
    idClient?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusRowFieldUpdateOperationsInput | $Enums.StatusRow
    numeroInvoice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaiementCreateManyInput = {
    id?: string
    datePaiement: Date | string
    motif?: string | null
    montant: number
    idClient: string
    archived?: boolean
    createdAt?: Date | string
    status?: $Enums.StatusRow
    numeroInvoice?: string | null
  }

  export type PaiementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    montant?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusRowFieldUpdateOperationsInput | $Enums.StatusRow
    numeroInvoice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaiementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    montant?: FloatFieldUpdateOperationsInput | number
    idClient?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusRowFieldUpdateOperationsInput | $Enums.StatusRow
    numeroInvoice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RubriqueFactureCreateInput = {
    id?: string
    produit?: string | null
    libelle?: string | null
    identifiant: string
    compte?: string | null
    compteAnalytique?: string | null
    detailFacture?: DetailFactureCreateNestedManyWithoutRubriqueFactureInput
  }

  export type RubriqueFactureUncheckedCreateInput = {
    id?: string
    produit?: string | null
    libelle?: string | null
    identifiant: string
    compte?: string | null
    compteAnalytique?: string | null
    detailFacture?: DetailFactureUncheckedCreateNestedManyWithoutRubriqueFactureInput
  }

  export type RubriqueFactureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    produit?: NullableStringFieldUpdateOperationsInput | string | null
    libelle?: NullableStringFieldUpdateOperationsInput | string | null
    identifiant?: StringFieldUpdateOperationsInput | string
    compte?: NullableStringFieldUpdateOperationsInput | string | null
    compteAnalytique?: NullableStringFieldUpdateOperationsInput | string | null
    detailFacture?: DetailFactureUpdateManyWithoutRubriqueFactureNestedInput
  }

  export type RubriqueFactureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    produit?: NullableStringFieldUpdateOperationsInput | string | null
    libelle?: NullableStringFieldUpdateOperationsInput | string | null
    identifiant?: StringFieldUpdateOperationsInput | string
    compte?: NullableStringFieldUpdateOperationsInput | string | null
    compteAnalytique?: NullableStringFieldUpdateOperationsInput | string | null
    detailFacture?: DetailFactureUncheckedUpdateManyWithoutRubriqueFactureNestedInput
  }

  export type RubriqueFactureCreateManyInput = {
    id?: string
    produit?: string | null
    libelle?: string | null
    identifiant: string
    compte?: string | null
    compteAnalytique?: string | null
  }

  export type RubriqueFactureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    produit?: NullableStringFieldUpdateOperationsInput | string | null
    libelle?: NullableStringFieldUpdateOperationsInput | string | null
    identifiant?: StringFieldUpdateOperationsInput | string
    compte?: NullableStringFieldUpdateOperationsInput | string | null
    compteAnalytique?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RubriqueFactureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    produit?: NullableStringFieldUpdateOperationsInput | string | null
    libelle?: NullableStringFieldUpdateOperationsInput | string | null
    identifiant?: StringFieldUpdateOperationsInput | string
    compte?: NullableStringFieldUpdateOperationsInput | string | null
    compteAnalytique?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UtilisateurCreateInput = {
    id?: string
    name?: string | null
    login: string
    role: string
    password?: string | null
    status?: $Enums.StatusRow
  }

  export type UtilisateurUncheckedCreateInput = {
    id?: string
    name?: string | null
    login: string
    role: string
    password?: string | null
    status?: $Enums.StatusRow
  }

  export type UtilisateurUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    login?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusRowFieldUpdateOperationsInput | $Enums.StatusRow
  }

  export type UtilisateurUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    login?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusRowFieldUpdateOperationsInput | $Enums.StatusRow
  }

  export type UtilisateurCreateManyInput = {
    id?: string
    name?: string | null
    login: string
    role: string
    password?: string | null
    status?: $Enums.StatusRow
  }

  export type UtilisateurUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    login?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusRowFieldUpdateOperationsInput | $Enums.StatusRow
  }

  export type UtilisateurUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    login?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusRowFieldUpdateOperationsInput | $Enums.StatusRow
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type FactureImportListRelationFilter = {
    every?: FactureImportWhereInput
    some?: FactureImportWhereInput
    none?: FactureImportWhereInput
  }

  export type FactureImportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CamionCountOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
  }

  export type CamionMaxOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
  }

  export type CamionMinOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type PaiementListRelationFilter = {
    every?: PaiementWhereInput
    some?: PaiementWhereInput
    none?: PaiementWhereInput
  }

  export type JournalTypeListRelationFilter = {
    every?: JournalTypeWhereInput
    some?: JournalTypeWhereInput
    none?: JournalTypeWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PaiementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    nom_client?: SortOrder
    code?: SortOrder
    num_nif?: SortOrder
    adresse?: SortOrder
    telephone?: SortOrder
    email?: SortOrder
    rccm?: SortOrder
    idNat?: SortOrder
    isFacturedForImport?: SortOrder
    isFacturedForExport?: SortOrder
    isFacturedForTva?: SortOrder
    lastPrintedDeclation?: SortOrder
    enabled?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    nom_client?: SortOrder
    code?: SortOrder
    num_nif?: SortOrder
    adresse?: SortOrder
    telephone?: SortOrder
    email?: SortOrder
    rccm?: SortOrder
    idNat?: SortOrder
    isFacturedForImport?: SortOrder
    isFacturedForExport?: SortOrder
    isFacturedForTva?: SortOrder
    lastPrintedDeclation?: SortOrder
    enabled?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    nom_client?: SortOrder
    code?: SortOrder
    num_nif?: SortOrder
    adresse?: SortOrder
    telephone?: SortOrder
    email?: SortOrder
    rccm?: SortOrder
    idNat?: SortOrder
    isFacturedForImport?: SortOrder
    isFacturedForExport?: SortOrder
    isFacturedForTva?: SortOrder
    lastPrintedDeclation?: SortOrder
    enabled?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FactureImportScalarRelationFilter = {
    is?: FactureImportWhereInput
    isNot?: FactureImportWhereInput
  }

  export type RubriqueFactureScalarRelationFilter = {
    is?: RubriqueFactureWhereInput
    isNot?: RubriqueFactureWhereInput
  }

  export type DetailFactureCountOrderByAggregateInput = {
    id?: SortOrder
    factureId?: SortOrder
    rubriqueFactureId?: SortOrder
    qte?: SortOrder
    prix?: SortOrder
  }

  export type DetailFactureAvgOrderByAggregateInput = {
    qte?: SortOrder
    prix?: SortOrder
  }

  export type DetailFactureMaxOrderByAggregateInput = {
    id?: SortOrder
    factureId?: SortOrder
    rubriqueFactureId?: SortOrder
    qte?: SortOrder
    prix?: SortOrder
  }

  export type DetailFactureMinOrderByAggregateInput = {
    id?: SortOrder
    factureId?: SortOrder
    rubriqueFactureId?: SortOrder
    qte?: SortOrder
    prix?: SortOrder
  }

  export type DetailFactureSumOrderByAggregateInput = {
    qte?: SortOrder
    prix?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumSTATUSFACTUREFilter<$PrismaModel = never> = {
    equals?: $Enums.STATUSFACTURE | EnumSTATUSFACTUREFieldRefInput<$PrismaModel>
    in?: $Enums.STATUSFACTURE[] | ListEnumSTATUSFACTUREFieldRefInput<$PrismaModel>
    notIn?: $Enums.STATUSFACTURE[] | ListEnumSTATUSFACTUREFieldRefInput<$PrismaModel>
    not?: NestedEnumSTATUSFACTUREFilter<$PrismaModel> | $Enums.STATUSFACTURE
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumTYPEFACTURATIONNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TYPEFACTURATION | EnumTYPEFACTURATIONFieldRefInput<$PrismaModel> | null
    in?: $Enums.TYPEFACTURATION[] | ListEnumTYPEFACTURATIONFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TYPEFACTURATION[] | ListEnumTYPEFACTURATIONFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTYPEFACTURATIONNullableFilter<$PrismaModel> | $Enums.TYPEFACTURATION | null
  }

  export type EnumNIVEAUSAISIEFilter<$PrismaModel = never> = {
    equals?: $Enums.NIVEAUSAISIE | EnumNIVEAUSAISIEFieldRefInput<$PrismaModel>
    in?: $Enums.NIVEAUSAISIE[] | ListEnumNIVEAUSAISIEFieldRefInput<$PrismaModel>
    notIn?: $Enums.NIVEAUSAISIE[] | ListEnumNIVEAUSAISIEFieldRefInput<$PrismaModel>
    not?: NestedEnumNIVEAUSAISIEFilter<$PrismaModel> | $Enums.NIVEAUSAISIE
  }

  export type JournalTypeScalarRelationFilter = {
    is?: JournalTypeWhereInput
    isNot?: JournalTypeWhereInput
  }

  export type CamionScalarRelationFilter = {
    is?: CamionWhereInput
    isNot?: CamionWhereInput
  }

  export type MarchandiseScalarRelationFilter = {
    is?: MarchandiseWhereInput
    isNot?: MarchandiseWhereInput
  }

  export type DetailFactureListRelationFilter = {
    every?: DetailFactureWhereInput
    some?: DetailFactureWhereInput
    none?: DetailFactureWhereInput
  }

  export type DetailFactureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FactureImportCountOrderByAggregateInput = {
    id?: SortOrder
    dossier?: SortOrder
    dateFacture?: SortOrder
    journalTypeId?: SortOrder
    manifeste?: SortOrder
    t1?: SortOrder
    camionId?: SortOrder
    marchandiseId?: SortOrder
    declarationId?: SortOrder
    declarationDate?: SortOrder
    liquidationId?: SortOrder
    liquidationDate?: SortOrder
    quittanceId?: SortOrder
    quittanceDate?: SortOrder
    quittanceMontant?: SortOrder
    poids?: SortOrder
    colis?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    montant?: SortOrder
    typeFact?: SortOrder
    niveauSaisie?: SortOrder
    numeroFacture?: SortOrder
  }

  export type FactureImportAvgOrderByAggregateInput = {
    quittanceMontant?: SortOrder
    montant?: SortOrder
  }

  export type FactureImportMaxOrderByAggregateInput = {
    id?: SortOrder
    dossier?: SortOrder
    dateFacture?: SortOrder
    journalTypeId?: SortOrder
    manifeste?: SortOrder
    t1?: SortOrder
    camionId?: SortOrder
    marchandiseId?: SortOrder
    declarationId?: SortOrder
    declarationDate?: SortOrder
    liquidationId?: SortOrder
    liquidationDate?: SortOrder
    quittanceId?: SortOrder
    quittanceDate?: SortOrder
    quittanceMontant?: SortOrder
    poids?: SortOrder
    colis?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    montant?: SortOrder
    typeFact?: SortOrder
    niveauSaisie?: SortOrder
    numeroFacture?: SortOrder
  }

  export type FactureImportMinOrderByAggregateInput = {
    id?: SortOrder
    dossier?: SortOrder
    dateFacture?: SortOrder
    journalTypeId?: SortOrder
    manifeste?: SortOrder
    t1?: SortOrder
    camionId?: SortOrder
    marchandiseId?: SortOrder
    declarationId?: SortOrder
    declarationDate?: SortOrder
    liquidationId?: SortOrder
    liquidationDate?: SortOrder
    quittanceId?: SortOrder
    quittanceDate?: SortOrder
    quittanceMontant?: SortOrder
    poids?: SortOrder
    colis?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    montant?: SortOrder
    typeFact?: SortOrder
    niveauSaisie?: SortOrder
    numeroFacture?: SortOrder
  }

  export type FactureImportSumOrderByAggregateInput = {
    quittanceMontant?: SortOrder
    montant?: SortOrder
  }

  export type EnumSTATUSFACTUREWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.STATUSFACTURE | EnumSTATUSFACTUREFieldRefInput<$PrismaModel>
    in?: $Enums.STATUSFACTURE[] | ListEnumSTATUSFACTUREFieldRefInput<$PrismaModel>
    notIn?: $Enums.STATUSFACTURE[] | ListEnumSTATUSFACTUREFieldRefInput<$PrismaModel>
    not?: NestedEnumSTATUSFACTUREWithAggregatesFilter<$PrismaModel> | $Enums.STATUSFACTURE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSTATUSFACTUREFilter<$PrismaModel>
    _max?: NestedEnumSTATUSFACTUREFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumTYPEFACTURATIONNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TYPEFACTURATION | EnumTYPEFACTURATIONFieldRefInput<$PrismaModel> | null
    in?: $Enums.TYPEFACTURATION[] | ListEnumTYPEFACTURATIONFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TYPEFACTURATION[] | ListEnumTYPEFACTURATIONFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTYPEFACTURATIONNullableWithAggregatesFilter<$PrismaModel> | $Enums.TYPEFACTURATION | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTYPEFACTURATIONNullableFilter<$PrismaModel>
    _max?: NestedEnumTYPEFACTURATIONNullableFilter<$PrismaModel>
  }

  export type EnumNIVEAUSAISIEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NIVEAUSAISIE | EnumNIVEAUSAISIEFieldRefInput<$PrismaModel>
    in?: $Enums.NIVEAUSAISIE[] | ListEnumNIVEAUSAISIEFieldRefInput<$PrismaModel>
    notIn?: $Enums.NIVEAUSAISIE[] | ListEnumNIVEAUSAISIEFieldRefInput<$PrismaModel>
    not?: NestedEnumNIVEAUSAISIEWithAggregatesFilter<$PrismaModel> | $Enums.NIVEAUSAISIE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNIVEAUSAISIEFilter<$PrismaModel>
    _max?: NestedEnumNIVEAUSAISIEFilter<$PrismaModel>
  }

  export type JournalTypeNullableScalarRelationFilter = {
    is?: JournalTypeWhereInput | null
    isNot?: JournalTypeWhereInput | null
  }

  export type JournalCountOrderByAggregateInput = {
    id?: SortOrder
    journalTypeId?: SortOrder
    numero?: SortOrder
  }

  export type JournalAvgOrderByAggregateInput = {
    numero?: SortOrder
  }

  export type JournalMaxOrderByAggregateInput = {
    id?: SortOrder
    journalTypeId?: SortOrder
    numero?: SortOrder
  }

  export type JournalMinOrderByAggregateInput = {
    id?: SortOrder
    journalTypeId?: SortOrder
    numero?: SortOrder
  }

  export type JournalSumOrderByAggregateInput = {
    numero?: SortOrder
  }

  export type JournalListRelationFilter = {
    every?: JournalWhereInput
    some?: JournalWhereInput
    none?: JournalWhereInput
  }

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type JournalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalTypeCountOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
    formatJournal?: SortOrder
    ClientId?: SortOrder
    derniereImpression?: SortOrder
    solde?: SortOrder
  }

  export type JournalTypeAvgOrderByAggregateInput = {
    solde?: SortOrder
  }

  export type JournalTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
    formatJournal?: SortOrder
    ClientId?: SortOrder
    derniereImpression?: SortOrder
    solde?: SortOrder
  }

  export type JournalTypeMinOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
    formatJournal?: SortOrder
    ClientId?: SortOrder
    derniereImpression?: SortOrder
    solde?: SortOrder
  }

  export type JournalTypeSumOrderByAggregateInput = {
    solde?: SortOrder
  }

  export type MarchandiseCountOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
  }

  export type MarchandiseMaxOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
  }

  export type MarchandiseMinOrderByAggregateInput = {
    id?: SortOrder
    libelle?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumStatusRowFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusRow | EnumStatusRowFieldRefInput<$PrismaModel>
    in?: $Enums.StatusRow[] | ListEnumStatusRowFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusRow[] | ListEnumStatusRowFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusRowFilter<$PrismaModel> | $Enums.StatusRow
  }

  export type PaiementCountOrderByAggregateInput = {
    id?: SortOrder
    datePaiement?: SortOrder
    motif?: SortOrder
    montant?: SortOrder
    idClient?: SortOrder
    archived?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    numeroInvoice?: SortOrder
  }

  export type PaiementAvgOrderByAggregateInput = {
    montant?: SortOrder
  }

  export type PaiementMaxOrderByAggregateInput = {
    id?: SortOrder
    datePaiement?: SortOrder
    motif?: SortOrder
    montant?: SortOrder
    idClient?: SortOrder
    archived?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    numeroInvoice?: SortOrder
  }

  export type PaiementMinOrderByAggregateInput = {
    id?: SortOrder
    datePaiement?: SortOrder
    motif?: SortOrder
    montant?: SortOrder
    idClient?: SortOrder
    archived?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    numeroInvoice?: SortOrder
  }

  export type PaiementSumOrderByAggregateInput = {
    montant?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumStatusRowWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusRow | EnumStatusRowFieldRefInput<$PrismaModel>
    in?: $Enums.StatusRow[] | ListEnumStatusRowFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusRow[] | ListEnumStatusRowFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusRowWithAggregatesFilter<$PrismaModel> | $Enums.StatusRow
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusRowFilter<$PrismaModel>
    _max?: NestedEnumStatusRowFilter<$PrismaModel>
  }

  export type RubriqueFactureCountOrderByAggregateInput = {
    id?: SortOrder
    produit?: SortOrder
    libelle?: SortOrder
    identifiant?: SortOrder
    compte?: SortOrder
    compteAnalytique?: SortOrder
  }

  export type RubriqueFactureMaxOrderByAggregateInput = {
    id?: SortOrder
    produit?: SortOrder
    libelle?: SortOrder
    identifiant?: SortOrder
    compte?: SortOrder
    compteAnalytique?: SortOrder
  }

  export type RubriqueFactureMinOrderByAggregateInput = {
    id?: SortOrder
    produit?: SortOrder
    libelle?: SortOrder
    identifiant?: SortOrder
    compte?: SortOrder
    compteAnalytique?: SortOrder
  }

  export type UtilisateurCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    login?: SortOrder
    role?: SortOrder
    password?: SortOrder
    status?: SortOrder
  }

  export type UtilisateurMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    login?: SortOrder
    role?: SortOrder
    password?: SortOrder
    status?: SortOrder
  }

  export type UtilisateurMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    login?: SortOrder
    role?: SortOrder
    password?: SortOrder
    status?: SortOrder
  }

  export type FactureImportCreateNestedManyWithoutCamionInput = {
    create?: XOR<FactureImportCreateWithoutCamionInput, FactureImportUncheckedCreateWithoutCamionInput> | FactureImportCreateWithoutCamionInput[] | FactureImportUncheckedCreateWithoutCamionInput[]
    connectOrCreate?: FactureImportCreateOrConnectWithoutCamionInput | FactureImportCreateOrConnectWithoutCamionInput[]
    createMany?: FactureImportCreateManyCamionInputEnvelope
    connect?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
  }

  export type FactureImportUncheckedCreateNestedManyWithoutCamionInput = {
    create?: XOR<FactureImportCreateWithoutCamionInput, FactureImportUncheckedCreateWithoutCamionInput> | FactureImportCreateWithoutCamionInput[] | FactureImportUncheckedCreateWithoutCamionInput[]
    connectOrCreate?: FactureImportCreateOrConnectWithoutCamionInput | FactureImportCreateOrConnectWithoutCamionInput[]
    createMany?: FactureImportCreateManyCamionInputEnvelope
    connect?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type FactureImportUpdateManyWithoutCamionNestedInput = {
    create?: XOR<FactureImportCreateWithoutCamionInput, FactureImportUncheckedCreateWithoutCamionInput> | FactureImportCreateWithoutCamionInput[] | FactureImportUncheckedCreateWithoutCamionInput[]
    connectOrCreate?: FactureImportCreateOrConnectWithoutCamionInput | FactureImportCreateOrConnectWithoutCamionInput[]
    upsert?: FactureImportUpsertWithWhereUniqueWithoutCamionInput | FactureImportUpsertWithWhereUniqueWithoutCamionInput[]
    createMany?: FactureImportCreateManyCamionInputEnvelope
    set?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
    disconnect?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
    delete?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
    connect?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
    update?: FactureImportUpdateWithWhereUniqueWithoutCamionInput | FactureImportUpdateWithWhereUniqueWithoutCamionInput[]
    updateMany?: FactureImportUpdateManyWithWhereWithoutCamionInput | FactureImportUpdateManyWithWhereWithoutCamionInput[]
    deleteMany?: FactureImportScalarWhereInput | FactureImportScalarWhereInput[]
  }

  export type FactureImportUncheckedUpdateManyWithoutCamionNestedInput = {
    create?: XOR<FactureImportCreateWithoutCamionInput, FactureImportUncheckedCreateWithoutCamionInput> | FactureImportCreateWithoutCamionInput[] | FactureImportUncheckedCreateWithoutCamionInput[]
    connectOrCreate?: FactureImportCreateOrConnectWithoutCamionInput | FactureImportCreateOrConnectWithoutCamionInput[]
    upsert?: FactureImportUpsertWithWhereUniqueWithoutCamionInput | FactureImportUpsertWithWhereUniqueWithoutCamionInput[]
    createMany?: FactureImportCreateManyCamionInputEnvelope
    set?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
    disconnect?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
    delete?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
    connect?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
    update?: FactureImportUpdateWithWhereUniqueWithoutCamionInput | FactureImportUpdateWithWhereUniqueWithoutCamionInput[]
    updateMany?: FactureImportUpdateManyWithWhereWithoutCamionInput | FactureImportUpdateManyWithWhereWithoutCamionInput[]
    deleteMany?: FactureImportScalarWhereInput | FactureImportScalarWhereInput[]
  }

  export type PaiementCreateNestedManyWithoutClientInput = {
    create?: XOR<PaiementCreateWithoutClientInput, PaiementUncheckedCreateWithoutClientInput> | PaiementCreateWithoutClientInput[] | PaiementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutClientInput | PaiementCreateOrConnectWithoutClientInput[]
    createMany?: PaiementCreateManyClientInputEnvelope
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
  }

  export type JournalTypeCreateNestedManyWithoutClientInput = {
    create?: XOR<JournalTypeCreateWithoutClientInput, JournalTypeUncheckedCreateWithoutClientInput> | JournalTypeCreateWithoutClientInput[] | JournalTypeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: JournalTypeCreateOrConnectWithoutClientInput | JournalTypeCreateOrConnectWithoutClientInput[]
    createMany?: JournalTypeCreateManyClientInputEnvelope
    connect?: JournalTypeWhereUniqueInput | JournalTypeWhereUniqueInput[]
  }

  export type PaiementUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<PaiementCreateWithoutClientInput, PaiementUncheckedCreateWithoutClientInput> | PaiementCreateWithoutClientInput[] | PaiementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutClientInput | PaiementCreateOrConnectWithoutClientInput[]
    createMany?: PaiementCreateManyClientInputEnvelope
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
  }

  export type JournalTypeUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<JournalTypeCreateWithoutClientInput, JournalTypeUncheckedCreateWithoutClientInput> | JournalTypeCreateWithoutClientInput[] | JournalTypeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: JournalTypeCreateOrConnectWithoutClientInput | JournalTypeCreateOrConnectWithoutClientInput[]
    createMany?: JournalTypeCreateManyClientInputEnvelope
    connect?: JournalTypeWhereUniqueInput | JournalTypeWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type PaiementUpdateManyWithoutClientNestedInput = {
    create?: XOR<PaiementCreateWithoutClientInput, PaiementUncheckedCreateWithoutClientInput> | PaiementCreateWithoutClientInput[] | PaiementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutClientInput | PaiementCreateOrConnectWithoutClientInput[]
    upsert?: PaiementUpsertWithWhereUniqueWithoutClientInput | PaiementUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: PaiementCreateManyClientInputEnvelope
    set?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    disconnect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    delete?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    update?: PaiementUpdateWithWhereUniqueWithoutClientInput | PaiementUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: PaiementUpdateManyWithWhereWithoutClientInput | PaiementUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
  }

  export type JournalTypeUpdateManyWithoutClientNestedInput = {
    create?: XOR<JournalTypeCreateWithoutClientInput, JournalTypeUncheckedCreateWithoutClientInput> | JournalTypeCreateWithoutClientInput[] | JournalTypeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: JournalTypeCreateOrConnectWithoutClientInput | JournalTypeCreateOrConnectWithoutClientInput[]
    upsert?: JournalTypeUpsertWithWhereUniqueWithoutClientInput | JournalTypeUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: JournalTypeCreateManyClientInputEnvelope
    set?: JournalTypeWhereUniqueInput | JournalTypeWhereUniqueInput[]
    disconnect?: JournalTypeWhereUniqueInput | JournalTypeWhereUniqueInput[]
    delete?: JournalTypeWhereUniqueInput | JournalTypeWhereUniqueInput[]
    connect?: JournalTypeWhereUniqueInput | JournalTypeWhereUniqueInput[]
    update?: JournalTypeUpdateWithWhereUniqueWithoutClientInput | JournalTypeUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: JournalTypeUpdateManyWithWhereWithoutClientInput | JournalTypeUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: JournalTypeScalarWhereInput | JournalTypeScalarWhereInput[]
  }

  export type PaiementUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<PaiementCreateWithoutClientInput, PaiementUncheckedCreateWithoutClientInput> | PaiementCreateWithoutClientInput[] | PaiementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutClientInput | PaiementCreateOrConnectWithoutClientInput[]
    upsert?: PaiementUpsertWithWhereUniqueWithoutClientInput | PaiementUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: PaiementCreateManyClientInputEnvelope
    set?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    disconnect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    delete?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    update?: PaiementUpdateWithWhereUniqueWithoutClientInput | PaiementUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: PaiementUpdateManyWithWhereWithoutClientInput | PaiementUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
  }

  export type JournalTypeUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<JournalTypeCreateWithoutClientInput, JournalTypeUncheckedCreateWithoutClientInput> | JournalTypeCreateWithoutClientInput[] | JournalTypeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: JournalTypeCreateOrConnectWithoutClientInput | JournalTypeCreateOrConnectWithoutClientInput[]
    upsert?: JournalTypeUpsertWithWhereUniqueWithoutClientInput | JournalTypeUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: JournalTypeCreateManyClientInputEnvelope
    set?: JournalTypeWhereUniqueInput | JournalTypeWhereUniqueInput[]
    disconnect?: JournalTypeWhereUniqueInput | JournalTypeWhereUniqueInput[]
    delete?: JournalTypeWhereUniqueInput | JournalTypeWhereUniqueInput[]
    connect?: JournalTypeWhereUniqueInput | JournalTypeWhereUniqueInput[]
    update?: JournalTypeUpdateWithWhereUniqueWithoutClientInput | JournalTypeUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: JournalTypeUpdateManyWithWhereWithoutClientInput | JournalTypeUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: JournalTypeScalarWhereInput | JournalTypeScalarWhereInput[]
  }

  export type FactureImportCreateNestedOneWithoutDetailFactureInput = {
    create?: XOR<FactureImportCreateWithoutDetailFactureInput, FactureImportUncheckedCreateWithoutDetailFactureInput>
    connectOrCreate?: FactureImportCreateOrConnectWithoutDetailFactureInput
    connect?: FactureImportWhereUniqueInput
  }

  export type RubriqueFactureCreateNestedOneWithoutDetailFactureInput = {
    create?: XOR<RubriqueFactureCreateWithoutDetailFactureInput, RubriqueFactureUncheckedCreateWithoutDetailFactureInput>
    connectOrCreate?: RubriqueFactureCreateOrConnectWithoutDetailFactureInput
    connect?: RubriqueFactureWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FactureImportUpdateOneRequiredWithoutDetailFactureNestedInput = {
    create?: XOR<FactureImportCreateWithoutDetailFactureInput, FactureImportUncheckedCreateWithoutDetailFactureInput>
    connectOrCreate?: FactureImportCreateOrConnectWithoutDetailFactureInput
    upsert?: FactureImportUpsertWithoutDetailFactureInput
    connect?: FactureImportWhereUniqueInput
    update?: XOR<XOR<FactureImportUpdateToOneWithWhereWithoutDetailFactureInput, FactureImportUpdateWithoutDetailFactureInput>, FactureImportUncheckedUpdateWithoutDetailFactureInput>
  }

  export type RubriqueFactureUpdateOneRequiredWithoutDetailFactureNestedInput = {
    create?: XOR<RubriqueFactureCreateWithoutDetailFactureInput, RubriqueFactureUncheckedCreateWithoutDetailFactureInput>
    connectOrCreate?: RubriqueFactureCreateOrConnectWithoutDetailFactureInput
    upsert?: RubriqueFactureUpsertWithoutDetailFactureInput
    connect?: RubriqueFactureWhereUniqueInput
    update?: XOR<XOR<RubriqueFactureUpdateToOneWithWhereWithoutDetailFactureInput, RubriqueFactureUpdateWithoutDetailFactureInput>, RubriqueFactureUncheckedUpdateWithoutDetailFactureInput>
  }

  export type JournalTypeCreateNestedOneWithoutFactureImportInput = {
    create?: XOR<JournalTypeCreateWithoutFactureImportInput, JournalTypeUncheckedCreateWithoutFactureImportInput>
    connectOrCreate?: JournalTypeCreateOrConnectWithoutFactureImportInput
    connect?: JournalTypeWhereUniqueInput
  }

  export type CamionCreateNestedOneWithoutFacturesInput = {
    create?: XOR<CamionCreateWithoutFacturesInput, CamionUncheckedCreateWithoutFacturesInput>
    connectOrCreate?: CamionCreateOrConnectWithoutFacturesInput
    connect?: CamionWhereUniqueInput
  }

  export type MarchandiseCreateNestedOneWithoutFacturesInput = {
    create?: XOR<MarchandiseCreateWithoutFacturesInput, MarchandiseUncheckedCreateWithoutFacturesInput>
    connectOrCreate?: MarchandiseCreateOrConnectWithoutFacturesInput
    connect?: MarchandiseWhereUniqueInput
  }

  export type DetailFactureCreateNestedManyWithoutFactureInput = {
    create?: XOR<DetailFactureCreateWithoutFactureInput, DetailFactureUncheckedCreateWithoutFactureInput> | DetailFactureCreateWithoutFactureInput[] | DetailFactureUncheckedCreateWithoutFactureInput[]
    connectOrCreate?: DetailFactureCreateOrConnectWithoutFactureInput | DetailFactureCreateOrConnectWithoutFactureInput[]
    createMany?: DetailFactureCreateManyFactureInputEnvelope
    connect?: DetailFactureWhereUniqueInput | DetailFactureWhereUniqueInput[]
  }

  export type DetailFactureUncheckedCreateNestedManyWithoutFactureInput = {
    create?: XOR<DetailFactureCreateWithoutFactureInput, DetailFactureUncheckedCreateWithoutFactureInput> | DetailFactureCreateWithoutFactureInput[] | DetailFactureUncheckedCreateWithoutFactureInput[]
    connectOrCreate?: DetailFactureCreateOrConnectWithoutFactureInput | DetailFactureCreateOrConnectWithoutFactureInput[]
    createMany?: DetailFactureCreateManyFactureInputEnvelope
    connect?: DetailFactureWhereUniqueInput | DetailFactureWhereUniqueInput[]
  }

  export type EnumSTATUSFACTUREFieldUpdateOperationsInput = {
    set?: $Enums.STATUSFACTURE
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumTYPEFACTURATIONFieldUpdateOperationsInput = {
    set?: $Enums.TYPEFACTURATION | null
  }

  export type EnumNIVEAUSAISIEFieldUpdateOperationsInput = {
    set?: $Enums.NIVEAUSAISIE
  }

  export type JournalTypeUpdateOneRequiredWithoutFactureImportNestedInput = {
    create?: XOR<JournalTypeCreateWithoutFactureImportInput, JournalTypeUncheckedCreateWithoutFactureImportInput>
    connectOrCreate?: JournalTypeCreateOrConnectWithoutFactureImportInput
    upsert?: JournalTypeUpsertWithoutFactureImportInput
    connect?: JournalTypeWhereUniqueInput
    update?: XOR<XOR<JournalTypeUpdateToOneWithWhereWithoutFactureImportInput, JournalTypeUpdateWithoutFactureImportInput>, JournalTypeUncheckedUpdateWithoutFactureImportInput>
  }

  export type CamionUpdateOneRequiredWithoutFacturesNestedInput = {
    create?: XOR<CamionCreateWithoutFacturesInput, CamionUncheckedCreateWithoutFacturesInput>
    connectOrCreate?: CamionCreateOrConnectWithoutFacturesInput
    upsert?: CamionUpsertWithoutFacturesInput
    connect?: CamionWhereUniqueInput
    update?: XOR<XOR<CamionUpdateToOneWithWhereWithoutFacturesInput, CamionUpdateWithoutFacturesInput>, CamionUncheckedUpdateWithoutFacturesInput>
  }

  export type MarchandiseUpdateOneRequiredWithoutFacturesNestedInput = {
    create?: XOR<MarchandiseCreateWithoutFacturesInput, MarchandiseUncheckedCreateWithoutFacturesInput>
    connectOrCreate?: MarchandiseCreateOrConnectWithoutFacturesInput
    upsert?: MarchandiseUpsertWithoutFacturesInput
    connect?: MarchandiseWhereUniqueInput
    update?: XOR<XOR<MarchandiseUpdateToOneWithWhereWithoutFacturesInput, MarchandiseUpdateWithoutFacturesInput>, MarchandiseUncheckedUpdateWithoutFacturesInput>
  }

  export type DetailFactureUpdateManyWithoutFactureNestedInput = {
    create?: XOR<DetailFactureCreateWithoutFactureInput, DetailFactureUncheckedCreateWithoutFactureInput> | DetailFactureCreateWithoutFactureInput[] | DetailFactureUncheckedCreateWithoutFactureInput[]
    connectOrCreate?: DetailFactureCreateOrConnectWithoutFactureInput | DetailFactureCreateOrConnectWithoutFactureInput[]
    upsert?: DetailFactureUpsertWithWhereUniqueWithoutFactureInput | DetailFactureUpsertWithWhereUniqueWithoutFactureInput[]
    createMany?: DetailFactureCreateManyFactureInputEnvelope
    set?: DetailFactureWhereUniqueInput | DetailFactureWhereUniqueInput[]
    disconnect?: DetailFactureWhereUniqueInput | DetailFactureWhereUniqueInput[]
    delete?: DetailFactureWhereUniqueInput | DetailFactureWhereUniqueInput[]
    connect?: DetailFactureWhereUniqueInput | DetailFactureWhereUniqueInput[]
    update?: DetailFactureUpdateWithWhereUniqueWithoutFactureInput | DetailFactureUpdateWithWhereUniqueWithoutFactureInput[]
    updateMany?: DetailFactureUpdateManyWithWhereWithoutFactureInput | DetailFactureUpdateManyWithWhereWithoutFactureInput[]
    deleteMany?: DetailFactureScalarWhereInput | DetailFactureScalarWhereInput[]
  }

  export type DetailFactureUncheckedUpdateManyWithoutFactureNestedInput = {
    create?: XOR<DetailFactureCreateWithoutFactureInput, DetailFactureUncheckedCreateWithoutFactureInput> | DetailFactureCreateWithoutFactureInput[] | DetailFactureUncheckedCreateWithoutFactureInput[]
    connectOrCreate?: DetailFactureCreateOrConnectWithoutFactureInput | DetailFactureCreateOrConnectWithoutFactureInput[]
    upsert?: DetailFactureUpsertWithWhereUniqueWithoutFactureInput | DetailFactureUpsertWithWhereUniqueWithoutFactureInput[]
    createMany?: DetailFactureCreateManyFactureInputEnvelope
    set?: DetailFactureWhereUniqueInput | DetailFactureWhereUniqueInput[]
    disconnect?: DetailFactureWhereUniqueInput | DetailFactureWhereUniqueInput[]
    delete?: DetailFactureWhereUniqueInput | DetailFactureWhereUniqueInput[]
    connect?: DetailFactureWhereUniqueInput | DetailFactureWhereUniqueInput[]
    update?: DetailFactureUpdateWithWhereUniqueWithoutFactureInput | DetailFactureUpdateWithWhereUniqueWithoutFactureInput[]
    updateMany?: DetailFactureUpdateManyWithWhereWithoutFactureInput | DetailFactureUpdateManyWithWhereWithoutFactureInput[]
    deleteMany?: DetailFactureScalarWhereInput | DetailFactureScalarWhereInput[]
  }

  export type JournalTypeCreateNestedOneWithoutJournalsInput = {
    create?: XOR<JournalTypeCreateWithoutJournalsInput, JournalTypeUncheckedCreateWithoutJournalsInput>
    connectOrCreate?: JournalTypeCreateOrConnectWithoutJournalsInput
    connect?: JournalTypeWhereUniqueInput
  }

  export type JournalTypeUpdateOneWithoutJournalsNestedInput = {
    create?: XOR<JournalTypeCreateWithoutJournalsInput, JournalTypeUncheckedCreateWithoutJournalsInput>
    connectOrCreate?: JournalTypeCreateOrConnectWithoutJournalsInput
    upsert?: JournalTypeUpsertWithoutJournalsInput
    disconnect?: JournalTypeWhereInput | boolean
    delete?: JournalTypeWhereInput | boolean
    connect?: JournalTypeWhereUniqueInput
    update?: XOR<XOR<JournalTypeUpdateToOneWithWhereWithoutJournalsInput, JournalTypeUpdateWithoutJournalsInput>, JournalTypeUncheckedUpdateWithoutJournalsInput>
  }

  export type JournalCreateNestedManyWithoutJournalTypeInput = {
    create?: XOR<JournalCreateWithoutJournalTypeInput, JournalUncheckedCreateWithoutJournalTypeInput> | JournalCreateWithoutJournalTypeInput[] | JournalUncheckedCreateWithoutJournalTypeInput[]
    connectOrCreate?: JournalCreateOrConnectWithoutJournalTypeInput | JournalCreateOrConnectWithoutJournalTypeInput[]
    createMany?: JournalCreateManyJournalTypeInputEnvelope
    connect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
  }

  export type ClientCreateNestedOneWithoutJournalTypeInput = {
    create?: XOR<ClientCreateWithoutJournalTypeInput, ClientUncheckedCreateWithoutJournalTypeInput>
    connectOrCreate?: ClientCreateOrConnectWithoutJournalTypeInput
    connect?: ClientWhereUniqueInput
  }

  export type FactureImportCreateNestedManyWithoutJournalTypeInput = {
    create?: XOR<FactureImportCreateWithoutJournalTypeInput, FactureImportUncheckedCreateWithoutJournalTypeInput> | FactureImportCreateWithoutJournalTypeInput[] | FactureImportUncheckedCreateWithoutJournalTypeInput[]
    connectOrCreate?: FactureImportCreateOrConnectWithoutJournalTypeInput | FactureImportCreateOrConnectWithoutJournalTypeInput[]
    createMany?: FactureImportCreateManyJournalTypeInputEnvelope
    connect?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
  }

  export type JournalUncheckedCreateNestedManyWithoutJournalTypeInput = {
    create?: XOR<JournalCreateWithoutJournalTypeInput, JournalUncheckedCreateWithoutJournalTypeInput> | JournalCreateWithoutJournalTypeInput[] | JournalUncheckedCreateWithoutJournalTypeInput[]
    connectOrCreate?: JournalCreateOrConnectWithoutJournalTypeInput | JournalCreateOrConnectWithoutJournalTypeInput[]
    createMany?: JournalCreateManyJournalTypeInputEnvelope
    connect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
  }

  export type FactureImportUncheckedCreateNestedManyWithoutJournalTypeInput = {
    create?: XOR<FactureImportCreateWithoutJournalTypeInput, FactureImportUncheckedCreateWithoutJournalTypeInput> | FactureImportCreateWithoutJournalTypeInput[] | FactureImportUncheckedCreateWithoutJournalTypeInput[]
    connectOrCreate?: FactureImportCreateOrConnectWithoutJournalTypeInput | FactureImportCreateOrConnectWithoutJournalTypeInput[]
    createMany?: FactureImportCreateManyJournalTypeInputEnvelope
    connect?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
  }

  export type JournalUpdateManyWithoutJournalTypeNestedInput = {
    create?: XOR<JournalCreateWithoutJournalTypeInput, JournalUncheckedCreateWithoutJournalTypeInput> | JournalCreateWithoutJournalTypeInput[] | JournalUncheckedCreateWithoutJournalTypeInput[]
    connectOrCreate?: JournalCreateOrConnectWithoutJournalTypeInput | JournalCreateOrConnectWithoutJournalTypeInput[]
    upsert?: JournalUpsertWithWhereUniqueWithoutJournalTypeInput | JournalUpsertWithWhereUniqueWithoutJournalTypeInput[]
    createMany?: JournalCreateManyJournalTypeInputEnvelope
    set?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    disconnect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    delete?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    connect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    update?: JournalUpdateWithWhereUniqueWithoutJournalTypeInput | JournalUpdateWithWhereUniqueWithoutJournalTypeInput[]
    updateMany?: JournalUpdateManyWithWhereWithoutJournalTypeInput | JournalUpdateManyWithWhereWithoutJournalTypeInput[]
    deleteMany?: JournalScalarWhereInput | JournalScalarWhereInput[]
  }

  export type ClientUpdateOneRequiredWithoutJournalTypeNestedInput = {
    create?: XOR<ClientCreateWithoutJournalTypeInput, ClientUncheckedCreateWithoutJournalTypeInput>
    connectOrCreate?: ClientCreateOrConnectWithoutJournalTypeInput
    upsert?: ClientUpsertWithoutJournalTypeInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutJournalTypeInput, ClientUpdateWithoutJournalTypeInput>, ClientUncheckedUpdateWithoutJournalTypeInput>
  }

  export type FactureImportUpdateManyWithoutJournalTypeNestedInput = {
    create?: XOR<FactureImportCreateWithoutJournalTypeInput, FactureImportUncheckedCreateWithoutJournalTypeInput> | FactureImportCreateWithoutJournalTypeInput[] | FactureImportUncheckedCreateWithoutJournalTypeInput[]
    connectOrCreate?: FactureImportCreateOrConnectWithoutJournalTypeInput | FactureImportCreateOrConnectWithoutJournalTypeInput[]
    upsert?: FactureImportUpsertWithWhereUniqueWithoutJournalTypeInput | FactureImportUpsertWithWhereUniqueWithoutJournalTypeInput[]
    createMany?: FactureImportCreateManyJournalTypeInputEnvelope
    set?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
    disconnect?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
    delete?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
    connect?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
    update?: FactureImportUpdateWithWhereUniqueWithoutJournalTypeInput | FactureImportUpdateWithWhereUniqueWithoutJournalTypeInput[]
    updateMany?: FactureImportUpdateManyWithWhereWithoutJournalTypeInput | FactureImportUpdateManyWithWhereWithoutJournalTypeInput[]
    deleteMany?: FactureImportScalarWhereInput | FactureImportScalarWhereInput[]
  }

  export type JournalUncheckedUpdateManyWithoutJournalTypeNestedInput = {
    create?: XOR<JournalCreateWithoutJournalTypeInput, JournalUncheckedCreateWithoutJournalTypeInput> | JournalCreateWithoutJournalTypeInput[] | JournalUncheckedCreateWithoutJournalTypeInput[]
    connectOrCreate?: JournalCreateOrConnectWithoutJournalTypeInput | JournalCreateOrConnectWithoutJournalTypeInput[]
    upsert?: JournalUpsertWithWhereUniqueWithoutJournalTypeInput | JournalUpsertWithWhereUniqueWithoutJournalTypeInput[]
    createMany?: JournalCreateManyJournalTypeInputEnvelope
    set?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    disconnect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    delete?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    connect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    update?: JournalUpdateWithWhereUniqueWithoutJournalTypeInput | JournalUpdateWithWhereUniqueWithoutJournalTypeInput[]
    updateMany?: JournalUpdateManyWithWhereWithoutJournalTypeInput | JournalUpdateManyWithWhereWithoutJournalTypeInput[]
    deleteMany?: JournalScalarWhereInput | JournalScalarWhereInput[]
  }

  export type FactureImportUncheckedUpdateManyWithoutJournalTypeNestedInput = {
    create?: XOR<FactureImportCreateWithoutJournalTypeInput, FactureImportUncheckedCreateWithoutJournalTypeInput> | FactureImportCreateWithoutJournalTypeInput[] | FactureImportUncheckedCreateWithoutJournalTypeInput[]
    connectOrCreate?: FactureImportCreateOrConnectWithoutJournalTypeInput | FactureImportCreateOrConnectWithoutJournalTypeInput[]
    upsert?: FactureImportUpsertWithWhereUniqueWithoutJournalTypeInput | FactureImportUpsertWithWhereUniqueWithoutJournalTypeInput[]
    createMany?: FactureImportCreateManyJournalTypeInputEnvelope
    set?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
    disconnect?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
    delete?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
    connect?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
    update?: FactureImportUpdateWithWhereUniqueWithoutJournalTypeInput | FactureImportUpdateWithWhereUniqueWithoutJournalTypeInput[]
    updateMany?: FactureImportUpdateManyWithWhereWithoutJournalTypeInput | FactureImportUpdateManyWithWhereWithoutJournalTypeInput[]
    deleteMany?: FactureImportScalarWhereInput | FactureImportScalarWhereInput[]
  }

  export type FactureImportCreateNestedManyWithoutMarchandiseInput = {
    create?: XOR<FactureImportCreateWithoutMarchandiseInput, FactureImportUncheckedCreateWithoutMarchandiseInput> | FactureImportCreateWithoutMarchandiseInput[] | FactureImportUncheckedCreateWithoutMarchandiseInput[]
    connectOrCreate?: FactureImportCreateOrConnectWithoutMarchandiseInput | FactureImportCreateOrConnectWithoutMarchandiseInput[]
    createMany?: FactureImportCreateManyMarchandiseInputEnvelope
    connect?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
  }

  export type FactureImportUncheckedCreateNestedManyWithoutMarchandiseInput = {
    create?: XOR<FactureImportCreateWithoutMarchandiseInput, FactureImportUncheckedCreateWithoutMarchandiseInput> | FactureImportCreateWithoutMarchandiseInput[] | FactureImportUncheckedCreateWithoutMarchandiseInput[]
    connectOrCreate?: FactureImportCreateOrConnectWithoutMarchandiseInput | FactureImportCreateOrConnectWithoutMarchandiseInput[]
    createMany?: FactureImportCreateManyMarchandiseInputEnvelope
    connect?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
  }

  export type FactureImportUpdateManyWithoutMarchandiseNestedInput = {
    create?: XOR<FactureImportCreateWithoutMarchandiseInput, FactureImportUncheckedCreateWithoutMarchandiseInput> | FactureImportCreateWithoutMarchandiseInput[] | FactureImportUncheckedCreateWithoutMarchandiseInput[]
    connectOrCreate?: FactureImportCreateOrConnectWithoutMarchandiseInput | FactureImportCreateOrConnectWithoutMarchandiseInput[]
    upsert?: FactureImportUpsertWithWhereUniqueWithoutMarchandiseInput | FactureImportUpsertWithWhereUniqueWithoutMarchandiseInput[]
    createMany?: FactureImportCreateManyMarchandiseInputEnvelope
    set?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
    disconnect?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
    delete?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
    connect?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
    update?: FactureImportUpdateWithWhereUniqueWithoutMarchandiseInput | FactureImportUpdateWithWhereUniqueWithoutMarchandiseInput[]
    updateMany?: FactureImportUpdateManyWithWhereWithoutMarchandiseInput | FactureImportUpdateManyWithWhereWithoutMarchandiseInput[]
    deleteMany?: FactureImportScalarWhereInput | FactureImportScalarWhereInput[]
  }

  export type FactureImportUncheckedUpdateManyWithoutMarchandiseNestedInput = {
    create?: XOR<FactureImportCreateWithoutMarchandiseInput, FactureImportUncheckedCreateWithoutMarchandiseInput> | FactureImportCreateWithoutMarchandiseInput[] | FactureImportUncheckedCreateWithoutMarchandiseInput[]
    connectOrCreate?: FactureImportCreateOrConnectWithoutMarchandiseInput | FactureImportCreateOrConnectWithoutMarchandiseInput[]
    upsert?: FactureImportUpsertWithWhereUniqueWithoutMarchandiseInput | FactureImportUpsertWithWhereUniqueWithoutMarchandiseInput[]
    createMany?: FactureImportCreateManyMarchandiseInputEnvelope
    set?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
    disconnect?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
    delete?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
    connect?: FactureImportWhereUniqueInput | FactureImportWhereUniqueInput[]
    update?: FactureImportUpdateWithWhereUniqueWithoutMarchandiseInput | FactureImportUpdateWithWhereUniqueWithoutMarchandiseInput[]
    updateMany?: FactureImportUpdateManyWithWhereWithoutMarchandiseInput | FactureImportUpdateManyWithWhereWithoutMarchandiseInput[]
    deleteMany?: FactureImportScalarWhereInput | FactureImportScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutPaiementInput = {
    create?: XOR<ClientCreateWithoutPaiementInput, ClientUncheckedCreateWithoutPaiementInput>
    connectOrCreate?: ClientCreateOrConnectWithoutPaiementInput
    connect?: ClientWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumStatusRowFieldUpdateOperationsInput = {
    set?: $Enums.StatusRow
  }

  export type ClientUpdateOneRequiredWithoutPaiementNestedInput = {
    create?: XOR<ClientCreateWithoutPaiementInput, ClientUncheckedCreateWithoutPaiementInput>
    connectOrCreate?: ClientCreateOrConnectWithoutPaiementInput
    upsert?: ClientUpsertWithoutPaiementInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutPaiementInput, ClientUpdateWithoutPaiementInput>, ClientUncheckedUpdateWithoutPaiementInput>
  }

  export type DetailFactureCreateNestedManyWithoutRubriqueFactureInput = {
    create?: XOR<DetailFactureCreateWithoutRubriqueFactureInput, DetailFactureUncheckedCreateWithoutRubriqueFactureInput> | DetailFactureCreateWithoutRubriqueFactureInput[] | DetailFactureUncheckedCreateWithoutRubriqueFactureInput[]
    connectOrCreate?: DetailFactureCreateOrConnectWithoutRubriqueFactureInput | DetailFactureCreateOrConnectWithoutRubriqueFactureInput[]
    createMany?: DetailFactureCreateManyRubriqueFactureInputEnvelope
    connect?: DetailFactureWhereUniqueInput | DetailFactureWhereUniqueInput[]
  }

  export type DetailFactureUncheckedCreateNestedManyWithoutRubriqueFactureInput = {
    create?: XOR<DetailFactureCreateWithoutRubriqueFactureInput, DetailFactureUncheckedCreateWithoutRubriqueFactureInput> | DetailFactureCreateWithoutRubriqueFactureInput[] | DetailFactureUncheckedCreateWithoutRubriqueFactureInput[]
    connectOrCreate?: DetailFactureCreateOrConnectWithoutRubriqueFactureInput | DetailFactureCreateOrConnectWithoutRubriqueFactureInput[]
    createMany?: DetailFactureCreateManyRubriqueFactureInputEnvelope
    connect?: DetailFactureWhereUniqueInput | DetailFactureWhereUniqueInput[]
  }

  export type DetailFactureUpdateManyWithoutRubriqueFactureNestedInput = {
    create?: XOR<DetailFactureCreateWithoutRubriqueFactureInput, DetailFactureUncheckedCreateWithoutRubriqueFactureInput> | DetailFactureCreateWithoutRubriqueFactureInput[] | DetailFactureUncheckedCreateWithoutRubriqueFactureInput[]
    connectOrCreate?: DetailFactureCreateOrConnectWithoutRubriqueFactureInput | DetailFactureCreateOrConnectWithoutRubriqueFactureInput[]
    upsert?: DetailFactureUpsertWithWhereUniqueWithoutRubriqueFactureInput | DetailFactureUpsertWithWhereUniqueWithoutRubriqueFactureInput[]
    createMany?: DetailFactureCreateManyRubriqueFactureInputEnvelope
    set?: DetailFactureWhereUniqueInput | DetailFactureWhereUniqueInput[]
    disconnect?: DetailFactureWhereUniqueInput | DetailFactureWhereUniqueInput[]
    delete?: DetailFactureWhereUniqueInput | DetailFactureWhereUniqueInput[]
    connect?: DetailFactureWhereUniqueInput | DetailFactureWhereUniqueInput[]
    update?: DetailFactureUpdateWithWhereUniqueWithoutRubriqueFactureInput | DetailFactureUpdateWithWhereUniqueWithoutRubriqueFactureInput[]
    updateMany?: DetailFactureUpdateManyWithWhereWithoutRubriqueFactureInput | DetailFactureUpdateManyWithWhereWithoutRubriqueFactureInput[]
    deleteMany?: DetailFactureScalarWhereInput | DetailFactureScalarWhereInput[]
  }

  export type DetailFactureUncheckedUpdateManyWithoutRubriqueFactureNestedInput = {
    create?: XOR<DetailFactureCreateWithoutRubriqueFactureInput, DetailFactureUncheckedCreateWithoutRubriqueFactureInput> | DetailFactureCreateWithoutRubriqueFactureInput[] | DetailFactureUncheckedCreateWithoutRubriqueFactureInput[]
    connectOrCreate?: DetailFactureCreateOrConnectWithoutRubriqueFactureInput | DetailFactureCreateOrConnectWithoutRubriqueFactureInput[]
    upsert?: DetailFactureUpsertWithWhereUniqueWithoutRubriqueFactureInput | DetailFactureUpsertWithWhereUniqueWithoutRubriqueFactureInput[]
    createMany?: DetailFactureCreateManyRubriqueFactureInputEnvelope
    set?: DetailFactureWhereUniqueInput | DetailFactureWhereUniqueInput[]
    disconnect?: DetailFactureWhereUniqueInput | DetailFactureWhereUniqueInput[]
    delete?: DetailFactureWhereUniqueInput | DetailFactureWhereUniqueInput[]
    connect?: DetailFactureWhereUniqueInput | DetailFactureWhereUniqueInput[]
    update?: DetailFactureUpdateWithWhereUniqueWithoutRubriqueFactureInput | DetailFactureUpdateWithWhereUniqueWithoutRubriqueFactureInput[]
    updateMany?: DetailFactureUpdateManyWithWhereWithoutRubriqueFactureInput | DetailFactureUpdateManyWithWhereWithoutRubriqueFactureInput[]
    deleteMany?: DetailFactureScalarWhereInput | DetailFactureScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumSTATUSFACTUREFilter<$PrismaModel = never> = {
    equals?: $Enums.STATUSFACTURE | EnumSTATUSFACTUREFieldRefInput<$PrismaModel>
    in?: $Enums.STATUSFACTURE[] | ListEnumSTATUSFACTUREFieldRefInput<$PrismaModel>
    notIn?: $Enums.STATUSFACTURE[] | ListEnumSTATUSFACTUREFieldRefInput<$PrismaModel>
    not?: NestedEnumSTATUSFACTUREFilter<$PrismaModel> | $Enums.STATUSFACTURE
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTYPEFACTURATIONNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TYPEFACTURATION | EnumTYPEFACTURATIONFieldRefInput<$PrismaModel> | null
    in?: $Enums.TYPEFACTURATION[] | ListEnumTYPEFACTURATIONFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TYPEFACTURATION[] | ListEnumTYPEFACTURATIONFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTYPEFACTURATIONNullableFilter<$PrismaModel> | $Enums.TYPEFACTURATION | null
  }

  export type NestedEnumNIVEAUSAISIEFilter<$PrismaModel = never> = {
    equals?: $Enums.NIVEAUSAISIE | EnumNIVEAUSAISIEFieldRefInput<$PrismaModel>
    in?: $Enums.NIVEAUSAISIE[] | ListEnumNIVEAUSAISIEFieldRefInput<$PrismaModel>
    notIn?: $Enums.NIVEAUSAISIE[] | ListEnumNIVEAUSAISIEFieldRefInput<$PrismaModel>
    not?: NestedEnumNIVEAUSAISIEFilter<$PrismaModel> | $Enums.NIVEAUSAISIE
  }

  export type NestedEnumSTATUSFACTUREWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.STATUSFACTURE | EnumSTATUSFACTUREFieldRefInput<$PrismaModel>
    in?: $Enums.STATUSFACTURE[] | ListEnumSTATUSFACTUREFieldRefInput<$PrismaModel>
    notIn?: $Enums.STATUSFACTURE[] | ListEnumSTATUSFACTUREFieldRefInput<$PrismaModel>
    not?: NestedEnumSTATUSFACTUREWithAggregatesFilter<$PrismaModel> | $Enums.STATUSFACTURE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSTATUSFACTUREFilter<$PrismaModel>
    _max?: NestedEnumSTATUSFACTUREFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumTYPEFACTURATIONNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TYPEFACTURATION | EnumTYPEFACTURATIONFieldRefInput<$PrismaModel> | null
    in?: $Enums.TYPEFACTURATION[] | ListEnumTYPEFACTURATIONFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TYPEFACTURATION[] | ListEnumTYPEFACTURATIONFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTYPEFACTURATIONNullableWithAggregatesFilter<$PrismaModel> | $Enums.TYPEFACTURATION | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTYPEFACTURATIONNullableFilter<$PrismaModel>
    _max?: NestedEnumTYPEFACTURATIONNullableFilter<$PrismaModel>
  }

  export type NestedEnumNIVEAUSAISIEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NIVEAUSAISIE | EnumNIVEAUSAISIEFieldRefInput<$PrismaModel>
    in?: $Enums.NIVEAUSAISIE[] | ListEnumNIVEAUSAISIEFieldRefInput<$PrismaModel>
    notIn?: $Enums.NIVEAUSAISIE[] | ListEnumNIVEAUSAISIEFieldRefInput<$PrismaModel>
    not?: NestedEnumNIVEAUSAISIEWithAggregatesFilter<$PrismaModel> | $Enums.NIVEAUSAISIE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNIVEAUSAISIEFilter<$PrismaModel>
    _max?: NestedEnumNIVEAUSAISIEFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumStatusRowFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusRow | EnumStatusRowFieldRefInput<$PrismaModel>
    in?: $Enums.StatusRow[] | ListEnumStatusRowFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusRow[] | ListEnumStatusRowFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusRowFilter<$PrismaModel> | $Enums.StatusRow
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumStatusRowWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusRow | EnumStatusRowFieldRefInput<$PrismaModel>
    in?: $Enums.StatusRow[] | ListEnumStatusRowFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusRow[] | ListEnumStatusRowFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusRowWithAggregatesFilter<$PrismaModel> | $Enums.StatusRow
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusRowFilter<$PrismaModel>
    _max?: NestedEnumStatusRowFilter<$PrismaModel>
  }

  export type FactureImportCreateWithoutCamionInput = {
    id?: string
    dossier?: string | null
    dateFacture?: Date | string | null
    manifeste?: string | null
    t1?: string | null
    declarationId?: string | null
    declarationDate?: Date | string | null
    liquidationId?: string | null
    liquidationDate?: Date | string | null
    quittanceId?: string | null
    quittanceDate?: Date | string | null
    quittanceMontant?: number
    poids?: string | null
    colis?: string | null
    status?: $Enums.STATUSFACTURE
    createdAt?: Date | string
    montant?: number | null
    typeFact?: $Enums.TYPEFACTURATION | null
    niveauSaisie?: $Enums.NIVEAUSAISIE
    numeroFacture?: string | null
    journalType: JournalTypeCreateNestedOneWithoutFactureImportInput
    marchandise: MarchandiseCreateNestedOneWithoutFacturesInput
    detailFacture?: DetailFactureCreateNestedManyWithoutFactureInput
  }

  export type FactureImportUncheckedCreateWithoutCamionInput = {
    id?: string
    dossier?: string | null
    dateFacture?: Date | string | null
    journalTypeId: string
    manifeste?: string | null
    t1?: string | null
    marchandiseId: string
    declarationId?: string | null
    declarationDate?: Date | string | null
    liquidationId?: string | null
    liquidationDate?: Date | string | null
    quittanceId?: string | null
    quittanceDate?: Date | string | null
    quittanceMontant?: number
    poids?: string | null
    colis?: string | null
    status?: $Enums.STATUSFACTURE
    createdAt?: Date | string
    montant?: number | null
    typeFact?: $Enums.TYPEFACTURATION | null
    niveauSaisie?: $Enums.NIVEAUSAISIE
    numeroFacture?: string | null
    detailFacture?: DetailFactureUncheckedCreateNestedManyWithoutFactureInput
  }

  export type FactureImportCreateOrConnectWithoutCamionInput = {
    where: FactureImportWhereUniqueInput
    create: XOR<FactureImportCreateWithoutCamionInput, FactureImportUncheckedCreateWithoutCamionInput>
  }

  export type FactureImportCreateManyCamionInputEnvelope = {
    data: FactureImportCreateManyCamionInput | FactureImportCreateManyCamionInput[]
    skipDuplicates?: boolean
  }

  export type FactureImportUpsertWithWhereUniqueWithoutCamionInput = {
    where: FactureImportWhereUniqueInput
    update: XOR<FactureImportUpdateWithoutCamionInput, FactureImportUncheckedUpdateWithoutCamionInput>
    create: XOR<FactureImportCreateWithoutCamionInput, FactureImportUncheckedCreateWithoutCamionInput>
  }

  export type FactureImportUpdateWithWhereUniqueWithoutCamionInput = {
    where: FactureImportWhereUniqueInput
    data: XOR<FactureImportUpdateWithoutCamionInput, FactureImportUncheckedUpdateWithoutCamionInput>
  }

  export type FactureImportUpdateManyWithWhereWithoutCamionInput = {
    where: FactureImportScalarWhereInput
    data: XOR<FactureImportUpdateManyMutationInput, FactureImportUncheckedUpdateManyWithoutCamionInput>
  }

  export type FactureImportScalarWhereInput = {
    AND?: FactureImportScalarWhereInput | FactureImportScalarWhereInput[]
    OR?: FactureImportScalarWhereInput[]
    NOT?: FactureImportScalarWhereInput | FactureImportScalarWhereInput[]
    id?: StringFilter<"FactureImport"> | string
    dossier?: StringNullableFilter<"FactureImport"> | string | null
    dateFacture?: DateTimeNullableFilter<"FactureImport"> | Date | string | null
    journalTypeId?: StringFilter<"FactureImport"> | string
    manifeste?: StringNullableFilter<"FactureImport"> | string | null
    t1?: StringNullableFilter<"FactureImport"> | string | null
    camionId?: StringFilter<"FactureImport"> | string
    marchandiseId?: StringFilter<"FactureImport"> | string
    declarationId?: StringNullableFilter<"FactureImport"> | string | null
    declarationDate?: DateTimeNullableFilter<"FactureImport"> | Date | string | null
    liquidationId?: StringNullableFilter<"FactureImport"> | string | null
    liquidationDate?: DateTimeNullableFilter<"FactureImport"> | Date | string | null
    quittanceId?: StringNullableFilter<"FactureImport"> | string | null
    quittanceDate?: DateTimeNullableFilter<"FactureImport"> | Date | string | null
    quittanceMontant?: FloatFilter<"FactureImport"> | number
    poids?: StringNullableFilter<"FactureImport"> | string | null
    colis?: StringNullableFilter<"FactureImport"> | string | null
    status?: EnumSTATUSFACTUREFilter<"FactureImport"> | $Enums.STATUSFACTURE
    createdAt?: DateTimeFilter<"FactureImport"> | Date | string
    montant?: FloatNullableFilter<"FactureImport"> | number | null
    typeFact?: EnumTYPEFACTURATIONNullableFilter<"FactureImport"> | $Enums.TYPEFACTURATION | null
    niveauSaisie?: EnumNIVEAUSAISIEFilter<"FactureImport"> | $Enums.NIVEAUSAISIE
    numeroFacture?: StringNullableFilter<"FactureImport"> | string | null
  }

  export type PaiementCreateWithoutClientInput = {
    id?: string
    datePaiement: Date | string
    motif?: string | null
    montant: number
    archived?: boolean
    createdAt?: Date | string
    status?: $Enums.StatusRow
    numeroInvoice?: string | null
  }

  export type PaiementUncheckedCreateWithoutClientInput = {
    id?: string
    datePaiement: Date | string
    motif?: string | null
    montant: number
    archived?: boolean
    createdAt?: Date | string
    status?: $Enums.StatusRow
    numeroInvoice?: string | null
  }

  export type PaiementCreateOrConnectWithoutClientInput = {
    where: PaiementWhereUniqueInput
    create: XOR<PaiementCreateWithoutClientInput, PaiementUncheckedCreateWithoutClientInput>
  }

  export type PaiementCreateManyClientInputEnvelope = {
    data: PaiementCreateManyClientInput | PaiementCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type JournalTypeCreateWithoutClientInput = {
    id?: string
    libelle: string
    formatJournal: string
    derniereImpression?: string | null
    solde?: number | null
    journals?: JournalCreateNestedManyWithoutJournalTypeInput
    FactureImport?: FactureImportCreateNestedManyWithoutJournalTypeInput
  }

  export type JournalTypeUncheckedCreateWithoutClientInput = {
    id?: string
    libelle: string
    formatJournal: string
    derniereImpression?: string | null
    solde?: number | null
    journals?: JournalUncheckedCreateNestedManyWithoutJournalTypeInput
    FactureImport?: FactureImportUncheckedCreateNestedManyWithoutJournalTypeInput
  }

  export type JournalTypeCreateOrConnectWithoutClientInput = {
    where: JournalTypeWhereUniqueInput
    create: XOR<JournalTypeCreateWithoutClientInput, JournalTypeUncheckedCreateWithoutClientInput>
  }

  export type JournalTypeCreateManyClientInputEnvelope = {
    data: JournalTypeCreateManyClientInput | JournalTypeCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type PaiementUpsertWithWhereUniqueWithoutClientInput = {
    where: PaiementWhereUniqueInput
    update: XOR<PaiementUpdateWithoutClientInput, PaiementUncheckedUpdateWithoutClientInput>
    create: XOR<PaiementCreateWithoutClientInput, PaiementUncheckedCreateWithoutClientInput>
  }

  export type PaiementUpdateWithWhereUniqueWithoutClientInput = {
    where: PaiementWhereUniqueInput
    data: XOR<PaiementUpdateWithoutClientInput, PaiementUncheckedUpdateWithoutClientInput>
  }

  export type PaiementUpdateManyWithWhereWithoutClientInput = {
    where: PaiementScalarWhereInput
    data: XOR<PaiementUpdateManyMutationInput, PaiementUncheckedUpdateManyWithoutClientInput>
  }

  export type PaiementScalarWhereInput = {
    AND?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
    OR?: PaiementScalarWhereInput[]
    NOT?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
    id?: StringFilter<"Paiement"> | string
    datePaiement?: DateTimeFilter<"Paiement"> | Date | string
    motif?: StringNullableFilter<"Paiement"> | string | null
    montant?: FloatFilter<"Paiement"> | number
    idClient?: StringFilter<"Paiement"> | string
    archived?: BoolFilter<"Paiement"> | boolean
    createdAt?: DateTimeFilter<"Paiement"> | Date | string
    status?: EnumStatusRowFilter<"Paiement"> | $Enums.StatusRow
    numeroInvoice?: StringNullableFilter<"Paiement"> | string | null
  }

  export type JournalTypeUpsertWithWhereUniqueWithoutClientInput = {
    where: JournalTypeWhereUniqueInput
    update: XOR<JournalTypeUpdateWithoutClientInput, JournalTypeUncheckedUpdateWithoutClientInput>
    create: XOR<JournalTypeCreateWithoutClientInput, JournalTypeUncheckedCreateWithoutClientInput>
  }

  export type JournalTypeUpdateWithWhereUniqueWithoutClientInput = {
    where: JournalTypeWhereUniqueInput
    data: XOR<JournalTypeUpdateWithoutClientInput, JournalTypeUncheckedUpdateWithoutClientInput>
  }

  export type JournalTypeUpdateManyWithWhereWithoutClientInput = {
    where: JournalTypeScalarWhereInput
    data: XOR<JournalTypeUpdateManyMutationInput, JournalTypeUncheckedUpdateManyWithoutClientInput>
  }

  export type JournalTypeScalarWhereInput = {
    AND?: JournalTypeScalarWhereInput | JournalTypeScalarWhereInput[]
    OR?: JournalTypeScalarWhereInput[]
    NOT?: JournalTypeScalarWhereInput | JournalTypeScalarWhereInput[]
    id?: StringFilter<"JournalType"> | string
    libelle?: StringFilter<"JournalType"> | string
    formatJournal?: StringFilter<"JournalType"> | string
    ClientId?: StringFilter<"JournalType"> | string
    derniereImpression?: StringNullableFilter<"JournalType"> | string | null
    solde?: FloatNullableFilter<"JournalType"> | number | null
  }

  export type FactureImportCreateWithoutDetailFactureInput = {
    id?: string
    dossier?: string | null
    dateFacture?: Date | string | null
    manifeste?: string | null
    t1?: string | null
    declarationId?: string | null
    declarationDate?: Date | string | null
    liquidationId?: string | null
    liquidationDate?: Date | string | null
    quittanceId?: string | null
    quittanceDate?: Date | string | null
    quittanceMontant?: number
    poids?: string | null
    colis?: string | null
    status?: $Enums.STATUSFACTURE
    createdAt?: Date | string
    montant?: number | null
    typeFact?: $Enums.TYPEFACTURATION | null
    niveauSaisie?: $Enums.NIVEAUSAISIE
    numeroFacture?: string | null
    journalType: JournalTypeCreateNestedOneWithoutFactureImportInput
    camion: CamionCreateNestedOneWithoutFacturesInput
    marchandise: MarchandiseCreateNestedOneWithoutFacturesInput
  }

  export type FactureImportUncheckedCreateWithoutDetailFactureInput = {
    id?: string
    dossier?: string | null
    dateFacture?: Date | string | null
    journalTypeId: string
    manifeste?: string | null
    t1?: string | null
    camionId: string
    marchandiseId: string
    declarationId?: string | null
    declarationDate?: Date | string | null
    liquidationId?: string | null
    liquidationDate?: Date | string | null
    quittanceId?: string | null
    quittanceDate?: Date | string | null
    quittanceMontant?: number
    poids?: string | null
    colis?: string | null
    status?: $Enums.STATUSFACTURE
    createdAt?: Date | string
    montant?: number | null
    typeFact?: $Enums.TYPEFACTURATION | null
    niveauSaisie?: $Enums.NIVEAUSAISIE
    numeroFacture?: string | null
  }

  export type FactureImportCreateOrConnectWithoutDetailFactureInput = {
    where: FactureImportWhereUniqueInput
    create: XOR<FactureImportCreateWithoutDetailFactureInput, FactureImportUncheckedCreateWithoutDetailFactureInput>
  }

  export type RubriqueFactureCreateWithoutDetailFactureInput = {
    id?: string
    produit?: string | null
    libelle?: string | null
    identifiant: string
    compte?: string | null
    compteAnalytique?: string | null
  }

  export type RubriqueFactureUncheckedCreateWithoutDetailFactureInput = {
    id?: string
    produit?: string | null
    libelle?: string | null
    identifiant: string
    compte?: string | null
    compteAnalytique?: string | null
  }

  export type RubriqueFactureCreateOrConnectWithoutDetailFactureInput = {
    where: RubriqueFactureWhereUniqueInput
    create: XOR<RubriqueFactureCreateWithoutDetailFactureInput, RubriqueFactureUncheckedCreateWithoutDetailFactureInput>
  }

  export type FactureImportUpsertWithoutDetailFactureInput = {
    update: XOR<FactureImportUpdateWithoutDetailFactureInput, FactureImportUncheckedUpdateWithoutDetailFactureInput>
    create: XOR<FactureImportCreateWithoutDetailFactureInput, FactureImportUncheckedCreateWithoutDetailFactureInput>
    where?: FactureImportWhereInput
  }

  export type FactureImportUpdateToOneWithWhereWithoutDetailFactureInput = {
    where?: FactureImportWhereInput
    data: XOR<FactureImportUpdateWithoutDetailFactureInput, FactureImportUncheckedUpdateWithoutDetailFactureInput>
  }

  export type FactureImportUpdateWithoutDetailFactureInput = {
    id?: StringFieldUpdateOperationsInput | string
    dossier?: NullableStringFieldUpdateOperationsInput | string | null
    dateFacture?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manifeste?: NullableStringFieldUpdateOperationsInput | string | null
    t1?: NullableStringFieldUpdateOperationsInput | string | null
    declarationId?: NullableStringFieldUpdateOperationsInput | string | null
    declarationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liquidationId?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceId?: NullableStringFieldUpdateOperationsInput | string | null
    quittanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceMontant?: FloatFieldUpdateOperationsInput | number
    poids?: NullableStringFieldUpdateOperationsInput | string | null
    colis?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSTATUSFACTUREFieldUpdateOperationsInput | $Enums.STATUSFACTURE
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    typeFact?: NullableEnumTYPEFACTURATIONFieldUpdateOperationsInput | $Enums.TYPEFACTURATION | null
    niveauSaisie?: EnumNIVEAUSAISIEFieldUpdateOperationsInput | $Enums.NIVEAUSAISIE
    numeroFacture?: NullableStringFieldUpdateOperationsInput | string | null
    journalType?: JournalTypeUpdateOneRequiredWithoutFactureImportNestedInput
    camion?: CamionUpdateOneRequiredWithoutFacturesNestedInput
    marchandise?: MarchandiseUpdateOneRequiredWithoutFacturesNestedInput
  }

  export type FactureImportUncheckedUpdateWithoutDetailFactureInput = {
    id?: StringFieldUpdateOperationsInput | string
    dossier?: NullableStringFieldUpdateOperationsInput | string | null
    dateFacture?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journalTypeId?: StringFieldUpdateOperationsInput | string
    manifeste?: NullableStringFieldUpdateOperationsInput | string | null
    t1?: NullableStringFieldUpdateOperationsInput | string | null
    camionId?: StringFieldUpdateOperationsInput | string
    marchandiseId?: StringFieldUpdateOperationsInput | string
    declarationId?: NullableStringFieldUpdateOperationsInput | string | null
    declarationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liquidationId?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceId?: NullableStringFieldUpdateOperationsInput | string | null
    quittanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceMontant?: FloatFieldUpdateOperationsInput | number
    poids?: NullableStringFieldUpdateOperationsInput | string | null
    colis?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSTATUSFACTUREFieldUpdateOperationsInput | $Enums.STATUSFACTURE
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    typeFact?: NullableEnumTYPEFACTURATIONFieldUpdateOperationsInput | $Enums.TYPEFACTURATION | null
    niveauSaisie?: EnumNIVEAUSAISIEFieldUpdateOperationsInput | $Enums.NIVEAUSAISIE
    numeroFacture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RubriqueFactureUpsertWithoutDetailFactureInput = {
    update: XOR<RubriqueFactureUpdateWithoutDetailFactureInput, RubriqueFactureUncheckedUpdateWithoutDetailFactureInput>
    create: XOR<RubriqueFactureCreateWithoutDetailFactureInput, RubriqueFactureUncheckedCreateWithoutDetailFactureInput>
    where?: RubriqueFactureWhereInput
  }

  export type RubriqueFactureUpdateToOneWithWhereWithoutDetailFactureInput = {
    where?: RubriqueFactureWhereInput
    data: XOR<RubriqueFactureUpdateWithoutDetailFactureInput, RubriqueFactureUncheckedUpdateWithoutDetailFactureInput>
  }

  export type RubriqueFactureUpdateWithoutDetailFactureInput = {
    id?: StringFieldUpdateOperationsInput | string
    produit?: NullableStringFieldUpdateOperationsInput | string | null
    libelle?: NullableStringFieldUpdateOperationsInput | string | null
    identifiant?: StringFieldUpdateOperationsInput | string
    compte?: NullableStringFieldUpdateOperationsInput | string | null
    compteAnalytique?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RubriqueFactureUncheckedUpdateWithoutDetailFactureInput = {
    id?: StringFieldUpdateOperationsInput | string
    produit?: NullableStringFieldUpdateOperationsInput | string | null
    libelle?: NullableStringFieldUpdateOperationsInput | string | null
    identifiant?: StringFieldUpdateOperationsInput | string
    compte?: NullableStringFieldUpdateOperationsInput | string | null
    compteAnalytique?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalTypeCreateWithoutFactureImportInput = {
    id?: string
    libelle: string
    formatJournal: string
    derniereImpression?: string | null
    solde?: number | null
    journals?: JournalCreateNestedManyWithoutJournalTypeInput
    Client: ClientCreateNestedOneWithoutJournalTypeInput
  }

  export type JournalTypeUncheckedCreateWithoutFactureImportInput = {
    id?: string
    libelle: string
    formatJournal: string
    ClientId: string
    derniereImpression?: string | null
    solde?: number | null
    journals?: JournalUncheckedCreateNestedManyWithoutJournalTypeInput
  }

  export type JournalTypeCreateOrConnectWithoutFactureImportInput = {
    where: JournalTypeWhereUniqueInput
    create: XOR<JournalTypeCreateWithoutFactureImportInput, JournalTypeUncheckedCreateWithoutFactureImportInput>
  }

  export type CamionCreateWithoutFacturesInput = {
    id?: string
    libelle: string
  }

  export type CamionUncheckedCreateWithoutFacturesInput = {
    id?: string
    libelle: string
  }

  export type CamionCreateOrConnectWithoutFacturesInput = {
    where: CamionWhereUniqueInput
    create: XOR<CamionCreateWithoutFacturesInput, CamionUncheckedCreateWithoutFacturesInput>
  }

  export type MarchandiseCreateWithoutFacturesInput = {
    id?: string
    libelle: string
  }

  export type MarchandiseUncheckedCreateWithoutFacturesInput = {
    id?: string
    libelle: string
  }

  export type MarchandiseCreateOrConnectWithoutFacturesInput = {
    where: MarchandiseWhereUniqueInput
    create: XOR<MarchandiseCreateWithoutFacturesInput, MarchandiseUncheckedCreateWithoutFacturesInput>
  }

  export type DetailFactureCreateWithoutFactureInput = {
    id?: string
    qte?: number
    prix?: number
    rubriqueFacture: RubriqueFactureCreateNestedOneWithoutDetailFactureInput
  }

  export type DetailFactureUncheckedCreateWithoutFactureInput = {
    id?: string
    rubriqueFactureId: string
    qte?: number
    prix?: number
  }

  export type DetailFactureCreateOrConnectWithoutFactureInput = {
    where: DetailFactureWhereUniqueInput
    create: XOR<DetailFactureCreateWithoutFactureInput, DetailFactureUncheckedCreateWithoutFactureInput>
  }

  export type DetailFactureCreateManyFactureInputEnvelope = {
    data: DetailFactureCreateManyFactureInput | DetailFactureCreateManyFactureInput[]
    skipDuplicates?: boolean
  }

  export type JournalTypeUpsertWithoutFactureImportInput = {
    update: XOR<JournalTypeUpdateWithoutFactureImportInput, JournalTypeUncheckedUpdateWithoutFactureImportInput>
    create: XOR<JournalTypeCreateWithoutFactureImportInput, JournalTypeUncheckedCreateWithoutFactureImportInput>
    where?: JournalTypeWhereInput
  }

  export type JournalTypeUpdateToOneWithWhereWithoutFactureImportInput = {
    where?: JournalTypeWhereInput
    data: XOR<JournalTypeUpdateWithoutFactureImportInput, JournalTypeUncheckedUpdateWithoutFactureImportInput>
  }

  export type JournalTypeUpdateWithoutFactureImportInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    formatJournal?: StringFieldUpdateOperationsInput | string
    derniereImpression?: NullableStringFieldUpdateOperationsInput | string | null
    solde?: NullableFloatFieldUpdateOperationsInput | number | null
    journals?: JournalUpdateManyWithoutJournalTypeNestedInput
    Client?: ClientUpdateOneRequiredWithoutJournalTypeNestedInput
  }

  export type JournalTypeUncheckedUpdateWithoutFactureImportInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    formatJournal?: StringFieldUpdateOperationsInput | string
    ClientId?: StringFieldUpdateOperationsInput | string
    derniereImpression?: NullableStringFieldUpdateOperationsInput | string | null
    solde?: NullableFloatFieldUpdateOperationsInput | number | null
    journals?: JournalUncheckedUpdateManyWithoutJournalTypeNestedInput
  }

  export type CamionUpsertWithoutFacturesInput = {
    update: XOR<CamionUpdateWithoutFacturesInput, CamionUncheckedUpdateWithoutFacturesInput>
    create: XOR<CamionCreateWithoutFacturesInput, CamionUncheckedCreateWithoutFacturesInput>
    where?: CamionWhereInput
  }

  export type CamionUpdateToOneWithWhereWithoutFacturesInput = {
    where?: CamionWhereInput
    data: XOR<CamionUpdateWithoutFacturesInput, CamionUncheckedUpdateWithoutFacturesInput>
  }

  export type CamionUpdateWithoutFacturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
  }

  export type CamionUncheckedUpdateWithoutFacturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
  }

  export type MarchandiseUpsertWithoutFacturesInput = {
    update: XOR<MarchandiseUpdateWithoutFacturesInput, MarchandiseUncheckedUpdateWithoutFacturesInput>
    create: XOR<MarchandiseCreateWithoutFacturesInput, MarchandiseUncheckedCreateWithoutFacturesInput>
    where?: MarchandiseWhereInput
  }

  export type MarchandiseUpdateToOneWithWhereWithoutFacturesInput = {
    where?: MarchandiseWhereInput
    data: XOR<MarchandiseUpdateWithoutFacturesInput, MarchandiseUncheckedUpdateWithoutFacturesInput>
  }

  export type MarchandiseUpdateWithoutFacturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
  }

  export type MarchandiseUncheckedUpdateWithoutFacturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
  }

  export type DetailFactureUpsertWithWhereUniqueWithoutFactureInput = {
    where: DetailFactureWhereUniqueInput
    update: XOR<DetailFactureUpdateWithoutFactureInput, DetailFactureUncheckedUpdateWithoutFactureInput>
    create: XOR<DetailFactureCreateWithoutFactureInput, DetailFactureUncheckedCreateWithoutFactureInput>
  }

  export type DetailFactureUpdateWithWhereUniqueWithoutFactureInput = {
    where: DetailFactureWhereUniqueInput
    data: XOR<DetailFactureUpdateWithoutFactureInput, DetailFactureUncheckedUpdateWithoutFactureInput>
  }

  export type DetailFactureUpdateManyWithWhereWithoutFactureInput = {
    where: DetailFactureScalarWhereInput
    data: XOR<DetailFactureUpdateManyMutationInput, DetailFactureUncheckedUpdateManyWithoutFactureInput>
  }

  export type DetailFactureScalarWhereInput = {
    AND?: DetailFactureScalarWhereInput | DetailFactureScalarWhereInput[]
    OR?: DetailFactureScalarWhereInput[]
    NOT?: DetailFactureScalarWhereInput | DetailFactureScalarWhereInput[]
    id?: StringFilter<"DetailFacture"> | string
    factureId?: StringFilter<"DetailFacture"> | string
    rubriqueFactureId?: StringFilter<"DetailFacture"> | string
    qte?: IntFilter<"DetailFacture"> | number
    prix?: FloatFilter<"DetailFacture"> | number
  }

  export type JournalTypeCreateWithoutJournalsInput = {
    id?: string
    libelle: string
    formatJournal: string
    derniereImpression?: string | null
    solde?: number | null
    Client: ClientCreateNestedOneWithoutJournalTypeInput
    FactureImport?: FactureImportCreateNestedManyWithoutJournalTypeInput
  }

  export type JournalTypeUncheckedCreateWithoutJournalsInput = {
    id?: string
    libelle: string
    formatJournal: string
    ClientId: string
    derniereImpression?: string | null
    solde?: number | null
    FactureImport?: FactureImportUncheckedCreateNestedManyWithoutJournalTypeInput
  }

  export type JournalTypeCreateOrConnectWithoutJournalsInput = {
    where: JournalTypeWhereUniqueInput
    create: XOR<JournalTypeCreateWithoutJournalsInput, JournalTypeUncheckedCreateWithoutJournalsInput>
  }

  export type JournalTypeUpsertWithoutJournalsInput = {
    update: XOR<JournalTypeUpdateWithoutJournalsInput, JournalTypeUncheckedUpdateWithoutJournalsInput>
    create: XOR<JournalTypeCreateWithoutJournalsInput, JournalTypeUncheckedCreateWithoutJournalsInput>
    where?: JournalTypeWhereInput
  }

  export type JournalTypeUpdateToOneWithWhereWithoutJournalsInput = {
    where?: JournalTypeWhereInput
    data: XOR<JournalTypeUpdateWithoutJournalsInput, JournalTypeUncheckedUpdateWithoutJournalsInput>
  }

  export type JournalTypeUpdateWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    formatJournal?: StringFieldUpdateOperationsInput | string
    derniereImpression?: NullableStringFieldUpdateOperationsInput | string | null
    solde?: NullableFloatFieldUpdateOperationsInput | number | null
    Client?: ClientUpdateOneRequiredWithoutJournalTypeNestedInput
    FactureImport?: FactureImportUpdateManyWithoutJournalTypeNestedInput
  }

  export type JournalTypeUncheckedUpdateWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    formatJournal?: StringFieldUpdateOperationsInput | string
    ClientId?: StringFieldUpdateOperationsInput | string
    derniereImpression?: NullableStringFieldUpdateOperationsInput | string | null
    solde?: NullableFloatFieldUpdateOperationsInput | number | null
    FactureImport?: FactureImportUncheckedUpdateManyWithoutJournalTypeNestedInput
  }

  export type JournalCreateWithoutJournalTypeInput = {
    id?: string
    numero?: number
  }

  export type JournalUncheckedCreateWithoutJournalTypeInput = {
    id?: string
    numero?: number
  }

  export type JournalCreateOrConnectWithoutJournalTypeInput = {
    where: JournalWhereUniqueInput
    create: XOR<JournalCreateWithoutJournalTypeInput, JournalUncheckedCreateWithoutJournalTypeInput>
  }

  export type JournalCreateManyJournalTypeInputEnvelope = {
    data: JournalCreateManyJournalTypeInput | JournalCreateManyJournalTypeInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutJournalTypeInput = {
    id?: string
    nom_client?: string | null
    code?: string | null
    num_nif?: string | null
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    rccm?: string | null
    idNat?: string | null
    isFacturedForImport?: string | null
    isFacturedForExport?: string | null
    isFacturedForTva?: string | null
    lastPrintedDeclation?: Date | string | null
    enabled?: string | null
    paiement?: PaiementCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutJournalTypeInput = {
    id?: string
    nom_client?: string | null
    code?: string | null
    num_nif?: string | null
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    rccm?: string | null
    idNat?: string | null
    isFacturedForImport?: string | null
    isFacturedForExport?: string | null
    isFacturedForTva?: string | null
    lastPrintedDeclation?: Date | string | null
    enabled?: string | null
    paiement?: PaiementUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutJournalTypeInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutJournalTypeInput, ClientUncheckedCreateWithoutJournalTypeInput>
  }

  export type FactureImportCreateWithoutJournalTypeInput = {
    id?: string
    dossier?: string | null
    dateFacture?: Date | string | null
    manifeste?: string | null
    t1?: string | null
    declarationId?: string | null
    declarationDate?: Date | string | null
    liquidationId?: string | null
    liquidationDate?: Date | string | null
    quittanceId?: string | null
    quittanceDate?: Date | string | null
    quittanceMontant?: number
    poids?: string | null
    colis?: string | null
    status?: $Enums.STATUSFACTURE
    createdAt?: Date | string
    montant?: number | null
    typeFact?: $Enums.TYPEFACTURATION | null
    niveauSaisie?: $Enums.NIVEAUSAISIE
    numeroFacture?: string | null
    camion: CamionCreateNestedOneWithoutFacturesInput
    marchandise: MarchandiseCreateNestedOneWithoutFacturesInput
    detailFacture?: DetailFactureCreateNestedManyWithoutFactureInput
  }

  export type FactureImportUncheckedCreateWithoutJournalTypeInput = {
    id?: string
    dossier?: string | null
    dateFacture?: Date | string | null
    manifeste?: string | null
    t1?: string | null
    camionId: string
    marchandiseId: string
    declarationId?: string | null
    declarationDate?: Date | string | null
    liquidationId?: string | null
    liquidationDate?: Date | string | null
    quittanceId?: string | null
    quittanceDate?: Date | string | null
    quittanceMontant?: number
    poids?: string | null
    colis?: string | null
    status?: $Enums.STATUSFACTURE
    createdAt?: Date | string
    montant?: number | null
    typeFact?: $Enums.TYPEFACTURATION | null
    niveauSaisie?: $Enums.NIVEAUSAISIE
    numeroFacture?: string | null
    detailFacture?: DetailFactureUncheckedCreateNestedManyWithoutFactureInput
  }

  export type FactureImportCreateOrConnectWithoutJournalTypeInput = {
    where: FactureImportWhereUniqueInput
    create: XOR<FactureImportCreateWithoutJournalTypeInput, FactureImportUncheckedCreateWithoutJournalTypeInput>
  }

  export type FactureImportCreateManyJournalTypeInputEnvelope = {
    data: FactureImportCreateManyJournalTypeInput | FactureImportCreateManyJournalTypeInput[]
    skipDuplicates?: boolean
  }

  export type JournalUpsertWithWhereUniqueWithoutJournalTypeInput = {
    where: JournalWhereUniqueInput
    update: XOR<JournalUpdateWithoutJournalTypeInput, JournalUncheckedUpdateWithoutJournalTypeInput>
    create: XOR<JournalCreateWithoutJournalTypeInput, JournalUncheckedCreateWithoutJournalTypeInput>
  }

  export type JournalUpdateWithWhereUniqueWithoutJournalTypeInput = {
    where: JournalWhereUniqueInput
    data: XOR<JournalUpdateWithoutJournalTypeInput, JournalUncheckedUpdateWithoutJournalTypeInput>
  }

  export type JournalUpdateManyWithWhereWithoutJournalTypeInput = {
    where: JournalScalarWhereInput
    data: XOR<JournalUpdateManyMutationInput, JournalUncheckedUpdateManyWithoutJournalTypeInput>
  }

  export type JournalScalarWhereInput = {
    AND?: JournalScalarWhereInput | JournalScalarWhereInput[]
    OR?: JournalScalarWhereInput[]
    NOT?: JournalScalarWhereInput | JournalScalarWhereInput[]
    id?: StringFilter<"Journal"> | string
    journalTypeId?: StringNullableFilter<"Journal"> | string | null
    numero?: IntFilter<"Journal"> | number
  }

  export type ClientUpsertWithoutJournalTypeInput = {
    update: XOR<ClientUpdateWithoutJournalTypeInput, ClientUncheckedUpdateWithoutJournalTypeInput>
    create: XOR<ClientCreateWithoutJournalTypeInput, ClientUncheckedCreateWithoutJournalTypeInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutJournalTypeInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutJournalTypeInput, ClientUncheckedUpdateWithoutJournalTypeInput>
  }

  export type ClientUpdateWithoutJournalTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom_client?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    num_nif?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rccm?: NullableStringFieldUpdateOperationsInput | string | null
    idNat?: NullableStringFieldUpdateOperationsInput | string | null
    isFacturedForImport?: NullableStringFieldUpdateOperationsInput | string | null
    isFacturedForExport?: NullableStringFieldUpdateOperationsInput | string | null
    isFacturedForTva?: NullableStringFieldUpdateOperationsInput | string | null
    lastPrintedDeclation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabled?: NullableStringFieldUpdateOperationsInput | string | null
    paiement?: PaiementUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutJournalTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom_client?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    num_nif?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rccm?: NullableStringFieldUpdateOperationsInput | string | null
    idNat?: NullableStringFieldUpdateOperationsInput | string | null
    isFacturedForImport?: NullableStringFieldUpdateOperationsInput | string | null
    isFacturedForExport?: NullableStringFieldUpdateOperationsInput | string | null
    isFacturedForTva?: NullableStringFieldUpdateOperationsInput | string | null
    lastPrintedDeclation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabled?: NullableStringFieldUpdateOperationsInput | string | null
    paiement?: PaiementUncheckedUpdateManyWithoutClientNestedInput
  }

  export type FactureImportUpsertWithWhereUniqueWithoutJournalTypeInput = {
    where: FactureImportWhereUniqueInput
    update: XOR<FactureImportUpdateWithoutJournalTypeInput, FactureImportUncheckedUpdateWithoutJournalTypeInput>
    create: XOR<FactureImportCreateWithoutJournalTypeInput, FactureImportUncheckedCreateWithoutJournalTypeInput>
  }

  export type FactureImportUpdateWithWhereUniqueWithoutJournalTypeInput = {
    where: FactureImportWhereUniqueInput
    data: XOR<FactureImportUpdateWithoutJournalTypeInput, FactureImportUncheckedUpdateWithoutJournalTypeInput>
  }

  export type FactureImportUpdateManyWithWhereWithoutJournalTypeInput = {
    where: FactureImportScalarWhereInput
    data: XOR<FactureImportUpdateManyMutationInput, FactureImportUncheckedUpdateManyWithoutJournalTypeInput>
  }

  export type FactureImportCreateWithoutMarchandiseInput = {
    id?: string
    dossier?: string | null
    dateFacture?: Date | string | null
    manifeste?: string | null
    t1?: string | null
    declarationId?: string | null
    declarationDate?: Date | string | null
    liquidationId?: string | null
    liquidationDate?: Date | string | null
    quittanceId?: string | null
    quittanceDate?: Date | string | null
    quittanceMontant?: number
    poids?: string | null
    colis?: string | null
    status?: $Enums.STATUSFACTURE
    createdAt?: Date | string
    montant?: number | null
    typeFact?: $Enums.TYPEFACTURATION | null
    niveauSaisie?: $Enums.NIVEAUSAISIE
    numeroFacture?: string | null
    journalType: JournalTypeCreateNestedOneWithoutFactureImportInput
    camion: CamionCreateNestedOneWithoutFacturesInput
    detailFacture?: DetailFactureCreateNestedManyWithoutFactureInput
  }

  export type FactureImportUncheckedCreateWithoutMarchandiseInput = {
    id?: string
    dossier?: string | null
    dateFacture?: Date | string | null
    journalTypeId: string
    manifeste?: string | null
    t1?: string | null
    camionId: string
    declarationId?: string | null
    declarationDate?: Date | string | null
    liquidationId?: string | null
    liquidationDate?: Date | string | null
    quittanceId?: string | null
    quittanceDate?: Date | string | null
    quittanceMontant?: number
    poids?: string | null
    colis?: string | null
    status?: $Enums.STATUSFACTURE
    createdAt?: Date | string
    montant?: number | null
    typeFact?: $Enums.TYPEFACTURATION | null
    niveauSaisie?: $Enums.NIVEAUSAISIE
    numeroFacture?: string | null
    detailFacture?: DetailFactureUncheckedCreateNestedManyWithoutFactureInput
  }

  export type FactureImportCreateOrConnectWithoutMarchandiseInput = {
    where: FactureImportWhereUniqueInput
    create: XOR<FactureImportCreateWithoutMarchandiseInput, FactureImportUncheckedCreateWithoutMarchandiseInput>
  }

  export type FactureImportCreateManyMarchandiseInputEnvelope = {
    data: FactureImportCreateManyMarchandiseInput | FactureImportCreateManyMarchandiseInput[]
    skipDuplicates?: boolean
  }

  export type FactureImportUpsertWithWhereUniqueWithoutMarchandiseInput = {
    where: FactureImportWhereUniqueInput
    update: XOR<FactureImportUpdateWithoutMarchandiseInput, FactureImportUncheckedUpdateWithoutMarchandiseInput>
    create: XOR<FactureImportCreateWithoutMarchandiseInput, FactureImportUncheckedCreateWithoutMarchandiseInput>
  }

  export type FactureImportUpdateWithWhereUniqueWithoutMarchandiseInput = {
    where: FactureImportWhereUniqueInput
    data: XOR<FactureImportUpdateWithoutMarchandiseInput, FactureImportUncheckedUpdateWithoutMarchandiseInput>
  }

  export type FactureImportUpdateManyWithWhereWithoutMarchandiseInput = {
    where: FactureImportScalarWhereInput
    data: XOR<FactureImportUpdateManyMutationInput, FactureImportUncheckedUpdateManyWithoutMarchandiseInput>
  }

  export type ClientCreateWithoutPaiementInput = {
    id?: string
    nom_client?: string | null
    code?: string | null
    num_nif?: string | null
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    rccm?: string | null
    idNat?: string | null
    isFacturedForImport?: string | null
    isFacturedForExport?: string | null
    isFacturedForTva?: string | null
    lastPrintedDeclation?: Date | string | null
    enabled?: string | null
    journalType?: JournalTypeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutPaiementInput = {
    id?: string
    nom_client?: string | null
    code?: string | null
    num_nif?: string | null
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    rccm?: string | null
    idNat?: string | null
    isFacturedForImport?: string | null
    isFacturedForExport?: string | null
    isFacturedForTva?: string | null
    lastPrintedDeclation?: Date | string | null
    enabled?: string | null
    journalType?: JournalTypeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutPaiementInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutPaiementInput, ClientUncheckedCreateWithoutPaiementInput>
  }

  export type ClientUpsertWithoutPaiementInput = {
    update: XOR<ClientUpdateWithoutPaiementInput, ClientUncheckedUpdateWithoutPaiementInput>
    create: XOR<ClientCreateWithoutPaiementInput, ClientUncheckedCreateWithoutPaiementInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutPaiementInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutPaiementInput, ClientUncheckedUpdateWithoutPaiementInput>
  }

  export type ClientUpdateWithoutPaiementInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom_client?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    num_nif?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rccm?: NullableStringFieldUpdateOperationsInput | string | null
    idNat?: NullableStringFieldUpdateOperationsInput | string | null
    isFacturedForImport?: NullableStringFieldUpdateOperationsInput | string | null
    isFacturedForExport?: NullableStringFieldUpdateOperationsInput | string | null
    isFacturedForTva?: NullableStringFieldUpdateOperationsInput | string | null
    lastPrintedDeclation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabled?: NullableStringFieldUpdateOperationsInput | string | null
    journalType?: JournalTypeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutPaiementInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom_client?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    num_nif?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    rccm?: NullableStringFieldUpdateOperationsInput | string | null
    idNat?: NullableStringFieldUpdateOperationsInput | string | null
    isFacturedForImport?: NullableStringFieldUpdateOperationsInput | string | null
    isFacturedForExport?: NullableStringFieldUpdateOperationsInput | string | null
    isFacturedForTva?: NullableStringFieldUpdateOperationsInput | string | null
    lastPrintedDeclation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabled?: NullableStringFieldUpdateOperationsInput | string | null
    journalType?: JournalTypeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type DetailFactureCreateWithoutRubriqueFactureInput = {
    id?: string
    qte?: number
    prix?: number
    facture: FactureImportCreateNestedOneWithoutDetailFactureInput
  }

  export type DetailFactureUncheckedCreateWithoutRubriqueFactureInput = {
    id?: string
    factureId: string
    qte?: number
    prix?: number
  }

  export type DetailFactureCreateOrConnectWithoutRubriqueFactureInput = {
    where: DetailFactureWhereUniqueInput
    create: XOR<DetailFactureCreateWithoutRubriqueFactureInput, DetailFactureUncheckedCreateWithoutRubriqueFactureInput>
  }

  export type DetailFactureCreateManyRubriqueFactureInputEnvelope = {
    data: DetailFactureCreateManyRubriqueFactureInput | DetailFactureCreateManyRubriqueFactureInput[]
    skipDuplicates?: boolean
  }

  export type DetailFactureUpsertWithWhereUniqueWithoutRubriqueFactureInput = {
    where: DetailFactureWhereUniqueInput
    update: XOR<DetailFactureUpdateWithoutRubriqueFactureInput, DetailFactureUncheckedUpdateWithoutRubriqueFactureInput>
    create: XOR<DetailFactureCreateWithoutRubriqueFactureInput, DetailFactureUncheckedCreateWithoutRubriqueFactureInput>
  }

  export type DetailFactureUpdateWithWhereUniqueWithoutRubriqueFactureInput = {
    where: DetailFactureWhereUniqueInput
    data: XOR<DetailFactureUpdateWithoutRubriqueFactureInput, DetailFactureUncheckedUpdateWithoutRubriqueFactureInput>
  }

  export type DetailFactureUpdateManyWithWhereWithoutRubriqueFactureInput = {
    where: DetailFactureScalarWhereInput
    data: XOR<DetailFactureUpdateManyMutationInput, DetailFactureUncheckedUpdateManyWithoutRubriqueFactureInput>
  }

  export type FactureImportCreateManyCamionInput = {
    id?: string
    dossier?: string | null
    dateFacture?: Date | string | null
    journalTypeId: string
    manifeste?: string | null
    t1?: string | null
    marchandiseId: string
    declarationId?: string | null
    declarationDate?: Date | string | null
    liquidationId?: string | null
    liquidationDate?: Date | string | null
    quittanceId?: string | null
    quittanceDate?: Date | string | null
    quittanceMontant?: number
    poids?: string | null
    colis?: string | null
    status?: $Enums.STATUSFACTURE
    createdAt?: Date | string
    montant?: number | null
    typeFact?: $Enums.TYPEFACTURATION | null
    niveauSaisie?: $Enums.NIVEAUSAISIE
    numeroFacture?: string | null
  }

  export type FactureImportUpdateWithoutCamionInput = {
    id?: StringFieldUpdateOperationsInput | string
    dossier?: NullableStringFieldUpdateOperationsInput | string | null
    dateFacture?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manifeste?: NullableStringFieldUpdateOperationsInput | string | null
    t1?: NullableStringFieldUpdateOperationsInput | string | null
    declarationId?: NullableStringFieldUpdateOperationsInput | string | null
    declarationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liquidationId?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceId?: NullableStringFieldUpdateOperationsInput | string | null
    quittanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceMontant?: FloatFieldUpdateOperationsInput | number
    poids?: NullableStringFieldUpdateOperationsInput | string | null
    colis?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSTATUSFACTUREFieldUpdateOperationsInput | $Enums.STATUSFACTURE
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    typeFact?: NullableEnumTYPEFACTURATIONFieldUpdateOperationsInput | $Enums.TYPEFACTURATION | null
    niveauSaisie?: EnumNIVEAUSAISIEFieldUpdateOperationsInput | $Enums.NIVEAUSAISIE
    numeroFacture?: NullableStringFieldUpdateOperationsInput | string | null
    journalType?: JournalTypeUpdateOneRequiredWithoutFactureImportNestedInput
    marchandise?: MarchandiseUpdateOneRequiredWithoutFacturesNestedInput
    detailFacture?: DetailFactureUpdateManyWithoutFactureNestedInput
  }

  export type FactureImportUncheckedUpdateWithoutCamionInput = {
    id?: StringFieldUpdateOperationsInput | string
    dossier?: NullableStringFieldUpdateOperationsInput | string | null
    dateFacture?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journalTypeId?: StringFieldUpdateOperationsInput | string
    manifeste?: NullableStringFieldUpdateOperationsInput | string | null
    t1?: NullableStringFieldUpdateOperationsInput | string | null
    marchandiseId?: StringFieldUpdateOperationsInput | string
    declarationId?: NullableStringFieldUpdateOperationsInput | string | null
    declarationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liquidationId?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceId?: NullableStringFieldUpdateOperationsInput | string | null
    quittanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceMontant?: FloatFieldUpdateOperationsInput | number
    poids?: NullableStringFieldUpdateOperationsInput | string | null
    colis?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSTATUSFACTUREFieldUpdateOperationsInput | $Enums.STATUSFACTURE
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    typeFact?: NullableEnumTYPEFACTURATIONFieldUpdateOperationsInput | $Enums.TYPEFACTURATION | null
    niveauSaisie?: EnumNIVEAUSAISIEFieldUpdateOperationsInput | $Enums.NIVEAUSAISIE
    numeroFacture?: NullableStringFieldUpdateOperationsInput | string | null
    detailFacture?: DetailFactureUncheckedUpdateManyWithoutFactureNestedInput
  }

  export type FactureImportUncheckedUpdateManyWithoutCamionInput = {
    id?: StringFieldUpdateOperationsInput | string
    dossier?: NullableStringFieldUpdateOperationsInput | string | null
    dateFacture?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journalTypeId?: StringFieldUpdateOperationsInput | string
    manifeste?: NullableStringFieldUpdateOperationsInput | string | null
    t1?: NullableStringFieldUpdateOperationsInput | string | null
    marchandiseId?: StringFieldUpdateOperationsInput | string
    declarationId?: NullableStringFieldUpdateOperationsInput | string | null
    declarationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liquidationId?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceId?: NullableStringFieldUpdateOperationsInput | string | null
    quittanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceMontant?: FloatFieldUpdateOperationsInput | number
    poids?: NullableStringFieldUpdateOperationsInput | string | null
    colis?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSTATUSFACTUREFieldUpdateOperationsInput | $Enums.STATUSFACTURE
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    typeFact?: NullableEnumTYPEFACTURATIONFieldUpdateOperationsInput | $Enums.TYPEFACTURATION | null
    niveauSaisie?: EnumNIVEAUSAISIEFieldUpdateOperationsInput | $Enums.NIVEAUSAISIE
    numeroFacture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaiementCreateManyClientInput = {
    id?: string
    datePaiement: Date | string
    motif?: string | null
    montant: number
    archived?: boolean
    createdAt?: Date | string
    status?: $Enums.StatusRow
    numeroInvoice?: string | null
  }

  export type JournalTypeCreateManyClientInput = {
    id?: string
    libelle: string
    formatJournal: string
    derniereImpression?: string | null
    solde?: number | null
  }

  export type PaiementUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    montant?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusRowFieldUpdateOperationsInput | $Enums.StatusRow
    numeroInvoice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaiementUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    montant?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusRowFieldUpdateOperationsInput | $Enums.StatusRow
    numeroInvoice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaiementUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    montant?: FloatFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusRowFieldUpdateOperationsInput | $Enums.StatusRow
    numeroInvoice?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalTypeUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    formatJournal?: StringFieldUpdateOperationsInput | string
    derniereImpression?: NullableStringFieldUpdateOperationsInput | string | null
    solde?: NullableFloatFieldUpdateOperationsInput | number | null
    journals?: JournalUpdateManyWithoutJournalTypeNestedInput
    FactureImport?: FactureImportUpdateManyWithoutJournalTypeNestedInput
  }

  export type JournalTypeUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    formatJournal?: StringFieldUpdateOperationsInput | string
    derniereImpression?: NullableStringFieldUpdateOperationsInput | string | null
    solde?: NullableFloatFieldUpdateOperationsInput | number | null
    journals?: JournalUncheckedUpdateManyWithoutJournalTypeNestedInput
    FactureImport?: FactureImportUncheckedUpdateManyWithoutJournalTypeNestedInput
  }

  export type JournalTypeUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    formatJournal?: StringFieldUpdateOperationsInput | string
    derniereImpression?: NullableStringFieldUpdateOperationsInput | string | null
    solde?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DetailFactureCreateManyFactureInput = {
    id?: string
    rubriqueFactureId: string
    qte?: number
    prix?: number
  }

  export type DetailFactureUpdateWithoutFactureInput = {
    id?: StringFieldUpdateOperationsInput | string
    qte?: IntFieldUpdateOperationsInput | number
    prix?: FloatFieldUpdateOperationsInput | number
    rubriqueFacture?: RubriqueFactureUpdateOneRequiredWithoutDetailFactureNestedInput
  }

  export type DetailFactureUncheckedUpdateWithoutFactureInput = {
    id?: StringFieldUpdateOperationsInput | string
    rubriqueFactureId?: StringFieldUpdateOperationsInput | string
    qte?: IntFieldUpdateOperationsInput | number
    prix?: FloatFieldUpdateOperationsInput | number
  }

  export type DetailFactureUncheckedUpdateManyWithoutFactureInput = {
    id?: StringFieldUpdateOperationsInput | string
    rubriqueFactureId?: StringFieldUpdateOperationsInput | string
    qte?: IntFieldUpdateOperationsInput | number
    prix?: FloatFieldUpdateOperationsInput | number
  }

  export type JournalCreateManyJournalTypeInput = {
    id?: string
    numero?: number
  }

  export type FactureImportCreateManyJournalTypeInput = {
    id?: string
    dossier?: string | null
    dateFacture?: Date | string | null
    manifeste?: string | null
    t1?: string | null
    camionId: string
    marchandiseId: string
    declarationId?: string | null
    declarationDate?: Date | string | null
    liquidationId?: string | null
    liquidationDate?: Date | string | null
    quittanceId?: string | null
    quittanceDate?: Date | string | null
    quittanceMontant?: number
    poids?: string | null
    colis?: string | null
    status?: $Enums.STATUSFACTURE
    createdAt?: Date | string
    montant?: number | null
    typeFact?: $Enums.TYPEFACTURATION | null
    niveauSaisie?: $Enums.NIVEAUSAISIE
    numeroFacture?: string | null
  }

  export type JournalUpdateWithoutJournalTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
  }

  export type JournalUncheckedUpdateWithoutJournalTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
  }

  export type JournalUncheckedUpdateManyWithoutJournalTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
  }

  export type FactureImportUpdateWithoutJournalTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    dossier?: NullableStringFieldUpdateOperationsInput | string | null
    dateFacture?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manifeste?: NullableStringFieldUpdateOperationsInput | string | null
    t1?: NullableStringFieldUpdateOperationsInput | string | null
    declarationId?: NullableStringFieldUpdateOperationsInput | string | null
    declarationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liquidationId?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceId?: NullableStringFieldUpdateOperationsInput | string | null
    quittanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceMontant?: FloatFieldUpdateOperationsInput | number
    poids?: NullableStringFieldUpdateOperationsInput | string | null
    colis?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSTATUSFACTUREFieldUpdateOperationsInput | $Enums.STATUSFACTURE
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    typeFact?: NullableEnumTYPEFACTURATIONFieldUpdateOperationsInput | $Enums.TYPEFACTURATION | null
    niveauSaisie?: EnumNIVEAUSAISIEFieldUpdateOperationsInput | $Enums.NIVEAUSAISIE
    numeroFacture?: NullableStringFieldUpdateOperationsInput | string | null
    camion?: CamionUpdateOneRequiredWithoutFacturesNestedInput
    marchandise?: MarchandiseUpdateOneRequiredWithoutFacturesNestedInput
    detailFacture?: DetailFactureUpdateManyWithoutFactureNestedInput
  }

  export type FactureImportUncheckedUpdateWithoutJournalTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    dossier?: NullableStringFieldUpdateOperationsInput | string | null
    dateFacture?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manifeste?: NullableStringFieldUpdateOperationsInput | string | null
    t1?: NullableStringFieldUpdateOperationsInput | string | null
    camionId?: StringFieldUpdateOperationsInput | string
    marchandiseId?: StringFieldUpdateOperationsInput | string
    declarationId?: NullableStringFieldUpdateOperationsInput | string | null
    declarationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liquidationId?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceId?: NullableStringFieldUpdateOperationsInput | string | null
    quittanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceMontant?: FloatFieldUpdateOperationsInput | number
    poids?: NullableStringFieldUpdateOperationsInput | string | null
    colis?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSTATUSFACTUREFieldUpdateOperationsInput | $Enums.STATUSFACTURE
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    typeFact?: NullableEnumTYPEFACTURATIONFieldUpdateOperationsInput | $Enums.TYPEFACTURATION | null
    niveauSaisie?: EnumNIVEAUSAISIEFieldUpdateOperationsInput | $Enums.NIVEAUSAISIE
    numeroFacture?: NullableStringFieldUpdateOperationsInput | string | null
    detailFacture?: DetailFactureUncheckedUpdateManyWithoutFactureNestedInput
  }

  export type FactureImportUncheckedUpdateManyWithoutJournalTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    dossier?: NullableStringFieldUpdateOperationsInput | string | null
    dateFacture?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manifeste?: NullableStringFieldUpdateOperationsInput | string | null
    t1?: NullableStringFieldUpdateOperationsInput | string | null
    camionId?: StringFieldUpdateOperationsInput | string
    marchandiseId?: StringFieldUpdateOperationsInput | string
    declarationId?: NullableStringFieldUpdateOperationsInput | string | null
    declarationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liquidationId?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceId?: NullableStringFieldUpdateOperationsInput | string | null
    quittanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceMontant?: FloatFieldUpdateOperationsInput | number
    poids?: NullableStringFieldUpdateOperationsInput | string | null
    colis?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSTATUSFACTUREFieldUpdateOperationsInput | $Enums.STATUSFACTURE
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    typeFact?: NullableEnumTYPEFACTURATIONFieldUpdateOperationsInput | $Enums.TYPEFACTURATION | null
    niveauSaisie?: EnumNIVEAUSAISIEFieldUpdateOperationsInput | $Enums.NIVEAUSAISIE
    numeroFacture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FactureImportCreateManyMarchandiseInput = {
    id?: string
    dossier?: string | null
    dateFacture?: Date | string | null
    journalTypeId: string
    manifeste?: string | null
    t1?: string | null
    camionId: string
    declarationId?: string | null
    declarationDate?: Date | string | null
    liquidationId?: string | null
    liquidationDate?: Date | string | null
    quittanceId?: string | null
    quittanceDate?: Date | string | null
    quittanceMontant?: number
    poids?: string | null
    colis?: string | null
    status?: $Enums.STATUSFACTURE
    createdAt?: Date | string
    montant?: number | null
    typeFact?: $Enums.TYPEFACTURATION | null
    niveauSaisie?: $Enums.NIVEAUSAISIE
    numeroFacture?: string | null
  }

  export type FactureImportUpdateWithoutMarchandiseInput = {
    id?: StringFieldUpdateOperationsInput | string
    dossier?: NullableStringFieldUpdateOperationsInput | string | null
    dateFacture?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manifeste?: NullableStringFieldUpdateOperationsInput | string | null
    t1?: NullableStringFieldUpdateOperationsInput | string | null
    declarationId?: NullableStringFieldUpdateOperationsInput | string | null
    declarationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liquidationId?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceId?: NullableStringFieldUpdateOperationsInput | string | null
    quittanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceMontant?: FloatFieldUpdateOperationsInput | number
    poids?: NullableStringFieldUpdateOperationsInput | string | null
    colis?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSTATUSFACTUREFieldUpdateOperationsInput | $Enums.STATUSFACTURE
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    typeFact?: NullableEnumTYPEFACTURATIONFieldUpdateOperationsInput | $Enums.TYPEFACTURATION | null
    niveauSaisie?: EnumNIVEAUSAISIEFieldUpdateOperationsInput | $Enums.NIVEAUSAISIE
    numeroFacture?: NullableStringFieldUpdateOperationsInput | string | null
    journalType?: JournalTypeUpdateOneRequiredWithoutFactureImportNestedInput
    camion?: CamionUpdateOneRequiredWithoutFacturesNestedInput
    detailFacture?: DetailFactureUpdateManyWithoutFactureNestedInput
  }

  export type FactureImportUncheckedUpdateWithoutMarchandiseInput = {
    id?: StringFieldUpdateOperationsInput | string
    dossier?: NullableStringFieldUpdateOperationsInput | string | null
    dateFacture?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journalTypeId?: StringFieldUpdateOperationsInput | string
    manifeste?: NullableStringFieldUpdateOperationsInput | string | null
    t1?: NullableStringFieldUpdateOperationsInput | string | null
    camionId?: StringFieldUpdateOperationsInput | string
    declarationId?: NullableStringFieldUpdateOperationsInput | string | null
    declarationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liquidationId?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceId?: NullableStringFieldUpdateOperationsInput | string | null
    quittanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceMontant?: FloatFieldUpdateOperationsInput | number
    poids?: NullableStringFieldUpdateOperationsInput | string | null
    colis?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSTATUSFACTUREFieldUpdateOperationsInput | $Enums.STATUSFACTURE
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    typeFact?: NullableEnumTYPEFACTURATIONFieldUpdateOperationsInput | $Enums.TYPEFACTURATION | null
    niveauSaisie?: EnumNIVEAUSAISIEFieldUpdateOperationsInput | $Enums.NIVEAUSAISIE
    numeroFacture?: NullableStringFieldUpdateOperationsInput | string | null
    detailFacture?: DetailFactureUncheckedUpdateManyWithoutFactureNestedInput
  }

  export type FactureImportUncheckedUpdateManyWithoutMarchandiseInput = {
    id?: StringFieldUpdateOperationsInput | string
    dossier?: NullableStringFieldUpdateOperationsInput | string | null
    dateFacture?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journalTypeId?: StringFieldUpdateOperationsInput | string
    manifeste?: NullableStringFieldUpdateOperationsInput | string | null
    t1?: NullableStringFieldUpdateOperationsInput | string | null
    camionId?: StringFieldUpdateOperationsInput | string
    declarationId?: NullableStringFieldUpdateOperationsInput | string | null
    declarationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    liquidationId?: NullableStringFieldUpdateOperationsInput | string | null
    liquidationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceId?: NullableStringFieldUpdateOperationsInput | string | null
    quittanceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quittanceMontant?: FloatFieldUpdateOperationsInput | number
    poids?: NullableStringFieldUpdateOperationsInput | string | null
    colis?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSTATUSFACTUREFieldUpdateOperationsInput | $Enums.STATUSFACTURE
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: NullableFloatFieldUpdateOperationsInput | number | null
    typeFact?: NullableEnumTYPEFACTURATIONFieldUpdateOperationsInput | $Enums.TYPEFACTURATION | null
    niveauSaisie?: EnumNIVEAUSAISIEFieldUpdateOperationsInput | $Enums.NIVEAUSAISIE
    numeroFacture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DetailFactureCreateManyRubriqueFactureInput = {
    id?: string
    factureId: string
    qte?: number
    prix?: number
  }

  export type DetailFactureUpdateWithoutRubriqueFactureInput = {
    id?: StringFieldUpdateOperationsInput | string
    qte?: IntFieldUpdateOperationsInput | number
    prix?: FloatFieldUpdateOperationsInput | number
    facture?: FactureImportUpdateOneRequiredWithoutDetailFactureNestedInput
  }

  export type DetailFactureUncheckedUpdateWithoutRubriqueFactureInput = {
    id?: StringFieldUpdateOperationsInput | string
    factureId?: StringFieldUpdateOperationsInput | string
    qte?: IntFieldUpdateOperationsInput | number
    prix?: FloatFieldUpdateOperationsInput | number
  }

  export type DetailFactureUncheckedUpdateManyWithoutRubriqueFactureInput = {
    id?: StringFieldUpdateOperationsInput | string
    factureId?: StringFieldUpdateOperationsInput | string
    qte?: IntFieldUpdateOperationsInput | number
    prix?: FloatFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}